<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="深入JS学习, N的博客">
    <meta name="description" content="敲敲敲">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>深入JS学习 | N的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">N的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">N的博客</div>
        <div class="logo-desc">
            
            敲敲敲
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/nhnjs" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/nhnjs" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">深入JS学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;

    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-02-19
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="第一节-浏览器工作原理和-V8-引擎"><a href="#第一节-浏览器工作原理和-V8-引擎" class="headerlink" title="第一节 浏览器工作原理和 V8 引擎"></a>第一节 浏览器工作原理和 V8 引擎</h2><h3 id="1-浏览器的工作原理"><a href="#1-浏览器的工作原理" class="headerlink" title="1. 浏览器的工作原理"></a>1. 浏览器的工作原理</h3><p><img src="/2022/021964822/image-20220105184125114.png"></p>
<p><strong>服务器返回给我们一个网页 当浏览器解析到 link 标签下载 css 文件解析到 script 标签就下载 js 文件</strong></p>
<h3 id="2-浏览器的渲染过程"><a href="#2-浏览器的渲染过程" class="headerlink" title="2. 浏览器的渲染过程"></a>2. 浏览器的渲染过程</h3><p><img src="/2022/021964822/image-20220107083615216.png"></p>
<h3 id="3-JavaScript-引擎"><a href="#3-JavaScript-引擎" class="headerlink" title="3. JavaScript 引擎"></a>3. JavaScript 引擎</h3><p>JavaScript 引擎就是把 js 代码转换为机器代码，由 cpu 执行。</p>
<h3 id="4-v8-引擎"><a href="#4-v8-引擎" class="headerlink" title="4. v8 引擎"></a>4. v8 引擎</h3><p><strong>js 代码的执行过程</strong></p>
<p><img src="/2022/021964822/image-20220107084700472.png"></p>
<p><strong>JS 代码被解析成—》 抽象语法树 —–》然后又被转化为字节码 ——》 执行</strong></p>
<p><img src="/2022/021964822/image-20220107103233302.png"></p>
<h3 id="5-全局代码在内存中执行"><a href="#5-全局代码在内存中执行" class="headerlink" title="5. 全局代码在内存中执行"></a>5. 全局代码在内存中执行</h3><ol>
<li><p>js 引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）<br>该对象所有的作用域（scope）都可以访问；<br>里面会包含 Date、Array、String、Number、setTimeout、setInterval 等等；<br>其中还有一个 window 属性指向自己；<br>初始化全局对象</p>
<p><img src="/2022/021964822/image-20220107113037238.png"></p>
</li>
<li><p>js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ECS），它是用于执行代码的调用栈。</p>
<p><img src="/2022/021964822/image-20220107145209389.png"></p>
</li>
<li><p>执行全局代码时，会构建一个 GEC 放入调用栈中执行</p>
<p>GEC 被放入到 ECS 中里面包含两部分内容：<br>第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，<br>但是并不会赋值；<br>ü 这个过程也称之为变量的作用域提升（hoisting）<br>p 第二部分：在代码执行中，对变量赋值，或者执行其他的函数；</p>
<p><img src="/2022/021964822/image-20220107142254901.png"></p>
</li>
</ol>
<h2 id="第二节-内存管理和内存泄漏"><a href="#第二节-内存管理和内存泄漏" class="headerlink" title="第二节 内存管理和内存泄漏"></a>第二节 内存管理和内存泄漏</h2><p>当我们查找一个变量是，真实的查找路径是沿着作用域链查找。</p>
<h3 id="1-全局作用域下遇到函数的执行顺序"><a href="#1-全局作用域下遇到函数的执行顺序" class="headerlink" title="1. 全局作用域下遇到函数的执行顺序"></a>1. 全局作用域下遇到函数的执行顺序</h3><ol>
<li><p>创建 GO 对象 由于是在编译过程 属性值是 undefined 但是函数的属性值是地址</p>
<p>由于是函数另外单独开辟一块空间存储 作用域在我们编译的时候就已经确认</p>
<p><img src="/2022/021964822/image-20220107151802976.png"></p>
</li>
<li><p>想要执行代码就要放入 ECStack 调用栈</p>
<p><img src="/2022/021964822/image-20220107152059292.png"></p>
</li>
<li><p>创建 GEC 全局执行上下文添加到调用栈</p>
<p>GEC 中包含了 ：</p>
<ul>
<li>VO ：就是 GO</li>
<li>执行代码</li>
</ul>
<p><img src="/2022/021964822/image-20220107152227611.png"></p>
</li>
<li><p>开始执行代码 当执行到函数时 创建 AO 对象</p>
<p><img src="/2022/021964822/image-20220107152522891.png"></p>
</li>
<li><p>创建一个 FEC 函数执行上下文 添加到调用栈中</p>
<p><img src="/2022/021964822/image-20220107152604616.png"></p>
</li>
<li><p>FEC 中 VO 指向 AO</p>
<p>scope chain （作用域链）: AO+parent Scope</p>
</li>
</ol>
<h3 id="2-全局代码执行过程函数嵌套在内存中的过程"><a href="#2-全局代码执行过程函数嵌套在内存中的过程" class="headerlink" title="2. 全局代码执行过程函数嵌套在内存中的过程"></a>2. 全局代码执行过程函数嵌套在内存中的过程</h3><pre><code class="js">var name = &quot;why&quot;;
foo(123);
function foo(num) &#123;
  console.log(m);
  var m = 10;
  var n = 20;

  function bar() &#123;
    console.log(name);
  &#125;

  bar();
&#125;
</code></pre>
<ol>
<li><p>创建 GO globalobject 对象 还未执行代码所以 name 值为 undefined foo 是一个函数 所以另外开一个空间储存 函数体以及作用域</p>
<p><img src="/2022/021964822/image-20220107153607587.png"></p>
<p><strong>在函数编译时候作用域就已经确定了</strong></p>
<p><img src="/2022/021964822/image-20220107153705578.png"></p>
</li>
<li><p>在调用栈中 创建全局执行上下文</p>
<p><img src="/2022/021964822/image-20220107153854595.png"></p>
</li>
<li><p>执行到 foo（）时 创建 AO 对象</p>
<p><img src="/2022/021964822/image-20220107153949057.png"></p>
</li>
<li><p>创建 FEC 函数执行上下文 VO 指向 AO 原型链 ：AO +父级作用域</p>
<p><img src="/2022/021964822/image-20220107154048087.png"></p>
</li>
<li><p>开始执行代码 执行到 bar（）时 创建一个 AO 为空</p>
<p><img src="/2022/021964822/image-20220107154241154.png"></p>
</li>
<li><p>在调用栈中在创建一个 FEC 函数执行上下文</p>
<p><img src="/2022/021964822/image-20220107154313948.png"></p>
</li>
<li><p>执行代码输出 name 由于 bar 函数中没有 name 变量定义 我们根据作用域链查找 上一级 foo 函数中也没有 name 变量在根据作用域链查找上一级 GO 中有 name 值 所以输出打印 why</p>
</li>
</ol>
<p><strong>这就是作用域链的原理</strong></p>
<h3 id="3-变量环境和记录"><a href="#3-变量环境和记录" class="headerlink" title="3. 变量环境和记录"></a>3. 变量环境和记录</h3><p>新的 es 规范中 vo 概念被更换为 ve 环境变量</p>
<h3 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h3><p>代码执行过程中都需要给它分配内存</p>
<p><img src="/2022/021964822/image-20220107163453421.png"></p>
<p><strong>JS 中在我们定义变量时就分配内存了</strong></p>
<ul>
<li>JS 对于基本数据类型内存分配会在执行时，直接在栈空间进行分配</li>
<li>JS 对于复杂数据类型内存分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用</li>
</ul>
<p><img src="/2022/021964822/image-20220107164118116.png"></p>
<h3 id="5-JS-的垃圾回收"><a href="#5-JS-的垃圾回收" class="headerlink" title="5. JS 的垃圾回收"></a>5. JS 的垃圾回收</h3><p>垃圾回收也叫 GC，JS 自带垃圾回收。</p>
<h2 id="第三节-深入-JS-闭包"><a href="#第三节-深入-JS-闭包" class="headerlink" title="第三节 深入 JS 闭包"></a>第三节 深入 JS 闭包</h2><h3 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1. 高阶函数"></a>1. 高阶函数</h3><p><strong>把一个函数接收另外一个函数作为参数或者把另外一个函数作为返回值 就被称为高阶函数。</strong></p>
<h3 id="2-数组中的常见高阶函数"><a href="#2-数组中的常见高阶函数" class="headerlink" title="2. 数组中的常见高阶函数"></a>2. 数组中的常见高阶函数</h3><ul>
<li><p>filter（）：返回符合 function 条件的新数组</p>
<pre><code class="js">arr.filter(function(数组的元素，索引，数组)&#123;&#125;)
</code></pre>
</li>
<li><p>find() 返回符合条件的第一个元素</p>
<pre><code class="js">let re = arr.find(function (value, index, arr) &#123;
  return value &gt; 3;
&#125;);
console.log(re);
</code></pre>
</li>
<li><p>reduce reduce(第一个参数是一个回调函数（第一个参数上一个循环的返回值，本次循环的元素，索引，数组），第二个参数初始值)</p>
<pre><code class="js">// reduce实现数组累加

let re = arr.reduce(function (pre, value, index, arr) &#123;
  return pre + value;
&#125;, 0);

console.log(re);
</code></pre>
</li>
<li><p>findIndex() 返回符合条件的第一个元素下标</p>
<pre><code class="js">let re = arr.findIndex(function (value, index, arr) &#123;
  return value &gt; 3;
&#125;);
console.log(re);
</code></pre>
</li>
<li><p>forEach() forEach 中没有 continue break 关键字 无法终止遍历</p>
<pre><code class="js">arr.forEach(function (value, index, arr) &#123;
  console.log(value, index);
&#125;);
</code></pre>
</li>
<li><p>map() 会返回一个新的数组 映射</p>
<pre><code class="js">let re = arr.map(function (value, index, arr) &#123;
  return value * 2;
&#125;);
console.log(re, arr);
</code></pre>
</li>
</ul>
<h3 id="3-闭包的定义"><a href="#3-闭包的定义" class="headerlink" title="3.闭包的定义"></a>3.闭包的定义</h3><p><strong>个人理解总结</strong></p>
<ul>
<li>一个普通的函数 function，如果他可以访问外层作用域的自由变量，那么这个函数就是一个闭包；</li>
<li>从广义的角度来说：Javascript 中的函数都是闭包。</li>
<li>从狭义的角度来说：<strong>Javascript 中一个函数，如果访问了上层作用域的变量，那么它是一个闭包</strong></li>
</ul>
<h3 id="4-闭包的内存泄漏"><a href="#4-闭包的内存泄漏" class="headerlink" title="4. 闭包的内存泄漏"></a>4. 闭包的内存泄漏</h3><p>内存泄不泄露取决于我们后边用不用这个变量</p>
<p><strong>解决闭包的内存泄漏：</strong></p>
<p>只需要把指向改为 null 就可以销毁</p>
<h2 id="第四节-闭包内存-this-指向"><a href="#第四节-闭包内存-this-指向" class="headerlink" title="第四节 闭包内存 this 指向"></a>第四节 闭包内存 this 指向</h2><h3 id="1-AO-中不用的自由变量销毁"><a href="#1-AO-中不用的自由变量销毁" class="headerlink" title="1. AO 中不用的自由变量销毁"></a>1. AO 中不用的自由变量销毁</h3><p>AO 的自由变量如果没有用到的变量，那么 v8 引擎自己会把没有用到的变量销毁掉。</p>
<h3 id="2-JS-中-this-的作用"><a href="#2-JS-中-this-的作用" class="headerlink" title="2. JS 中 this 的作用"></a>2. JS 中 this 的作用</h3><p>可以没有 this，但是有 this 可以提高编码的效率很方便。</p>
<p>大多数情况下 this 出现在函数中</p>
<h3 id="3-this-在全局作用域下的指向"><a href="#3-this-在全局作用域下的指向" class="headerlink" title="3. this 在全局作用域下的指向"></a>3. this 在全局作用域下的指向</h3><ul>
<li>浏览器中：this 指向 window (global Object)</li>
<li>node 环境中：this 指向{}</li>
</ul>
<h3 id="4-this-的绑定规则"><a href="#4-this-的绑定规则" class="headerlink" title="4. this 的绑定规则"></a>4. this 的绑定规则</h3><p><strong>this 与函数定义位置无关，与函数的调用方式有关</strong></p>
<ul>
<li><p>默认绑定</p>
<p>独立函数调用，this 指向 window</p>
<pre><code class="js">foo(); //独立函数调用
</code></pre>
</li>
<li><p>隐式绑定</p>
<p>隐式绑定的前提条件：必须在调用的对象内部有一个对函数的引用（比如一个属性）</p>
<p>通过某个对象调用，通过某个对象发起的函数调用</p>
<pre><code class="js">obj.foo()(
  //通过obj对象调用foo函数
  obj.foo
)(); //和第一种是一样的
</code></pre>
</li>
<li><p>显示绑定</p>
<p>call 和 apply 在执行函数时，是可以明确地绑定 this，这个规则叫做显示绑定</p>
<p>call 和 apply 的区别在于传参，apply 以数组的形式传参 ，call 是以，分隔参数</p>
<pre><code>foo.call(指定this的指向);
</code></pre>
<pre><code class="js">foo.apply(指定this的指向);
</code></pre>
<p>bind 绑定</p>
<p>bind 绑定会返回一个函数</p>
<pre><code class="js">var newfoo = foo.bind(指定this的指向);
</code></pre>
<p><strong>显示绑定与默认绑定冲突：显示绑定优先</strong></p>
</li>
<li><p>new 绑定</p>
<p>我们通过一个 new 关键字调用一个函数时（构造器），这个时候 this 是在调用这个构造器时创建出来的对象</p>
<p>this=创建出来的对象</p>
<p>这个过程就是 new 绑定</p>
<pre><code class="js">function Person(name, age) &#123;
  this.name = name;
  this.age = age;
&#125;
var p1 = new Person(&quot;why&quot;, 18);
</code></pre>
</li>
</ul>
<h2 id="第五节-this-绑定的优先级"><a href="#第五节-this-绑定的优先级" class="headerlink" title="第五节 this 绑定的优先级"></a>第五节 this 绑定的优先级</h2><h3 id="1-绑定规则的优先级"><a href="#1-绑定规则的优先级" class="headerlink" title="1. 绑定规则的优先级"></a>1. 绑定规则的优先级</h3><ul>
<li>默认规则的优先级最低</li>
<li>显示绑定优先级高于隐式绑定</li>
<li>new 绑定优先级高于隐式绑定 new 的优先级高于显示绑定 不能和 call/apply 关键字一起使用</li>
<li>new 绑定》显示绑定》隐式绑定》默认绑定</li>
</ul>
<h3 id="2-特殊绑定-忽略显示绑定"><a href="#2-特殊绑定-忽略显示绑定" class="headerlink" title="2. 特殊绑定 -忽略显示绑定"></a>2. 特殊绑定 -忽略显示绑定</h3><p>apply/call/bind 当传入的参数是 null 或者 undefined 时 this 的指向为 window</p>
<h3 id="3-箭头函数-（参数）-gt-执行体"><a href="#3-箭头函数-（参数）-gt-执行体" class="headerlink" title="3. 箭头函数 （参数）=&gt;{执行体}"></a>3. 箭头函数 （参数）=&gt;{执行体}</h3><ul>
<li>箭头函数不会绑定 this ， arguments 属性</li>
<li>箭头函数不能 作为构造函数来使用 不能和 new 一起来使用</li>
</ul>
<p><strong>箭头函数常见的简写：</strong></p>
<ol>
<li><p>当我们只有一个参数时：（）可以省略 num=&gt;{};</p>
</li>
<li><p>如果函数执行体只有一行代码大括号{}也可以省略并且他会默认将这行代码的执行结果作为返回值 参数=&gt;执行代码</p>
</li>
<li><p>如果一个箭头函数，只有一行代码并且返回值是一个对象 在对象外加一个（）让它当做一个整个返回</p>
<p>var bar=（）=&gt;({name：‘why’，age：18})</p>
</li>
</ol>
<h3 id="4-箭头函数的-this-获取"><a href="#4-箭头函数的-this-获取" class="headerlink" title="4. 箭头函数的 this 获取"></a>4. 箭头函数的 this 获取</h3><p>箭头函数中不适用 4 种 this 绑定规则，而是往上层作用域查找上层作用域的 this</p>
<p>函数只要执行就会放到执行上下文栈中 箭头函数也会</p>
<p>如果箭头函数上层作用域没有找到就去在上一层</p>
<h2 id="第六节-手写-call-apply-bind-arguments-函数"><a href="#第六节-手写-call-apply-bind-arguments-函数" class="headerlink" title="第六节 手写 call-apply-bind arguments 函数"></a>第六节 手写 call-apply-bind arguments 函数</h2><h3 id="1-实现-call-apply-bind"><a href="#1-实现-call-apply-bind" class="headerlink" title="1. 实现 call apply bind"></a>1. 实现 call apply bind</h3><h4 id="1-1-JS-实现-call"><a href="#1-1-JS-实现-call" class="headerlink" title="1-1 JS 实现 call"></a>1-1 JS 实现 call</h4><pre><code class="js">// 手写call
Function.prototype.hycall = function (thisArg, ...nums) &#123;
  // 1. 需要获取被执行的函数
  var that = this;
  // 2.对thisArg转成对象类型（防止传入非对象类型）
  // 判断要绑定的this指向 是不是为空
  thisArg =
    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;
  // 3.调用被执行的函数
  thisArg.that = that;
  var result = thisArg.that(...nums);
  delete thisArg.that;
  // 4. 将最终的结果返回
  return result;
&#125;;
</code></pre>
<ol>
<li><p>获取需要被执行的函数</p>
<p>根据 this 指向就可以获取被执行的函数</p>
<pre><code class="js">Function.prototype._call = function (thisArg, ...nums) &#123;
  var fn = this;
&#125;;
</code></pre>
</li>
<li><p>对 thisArg 转成对象类型（防止传入非对象类型）</p>
<pre><code class="js">// 2.对thisArg转成对象类型（防止传入非对象类型）
// 判断要绑定的this指向 是不是为空
thisArg = thisArg ? Object(thisArg) : window;
</code></pre>
</li>
<li><p>调用需要被执行的函数</p>
<pre><code class="js">// 3.调用被执行的函数
thisArg.fn = fn;
var result = thisArg.fn(...nums);
delete thisArg.fn;
</code></pre>
</li>
<li><p>将最终的结果返回</p>
<pre><code class="js">// 4. 将最终的结果返回
return result;
</code></pre>
</li>
</ol>
<p><strong>当我们不知道函数中要传入多少个参数时 可以使用扩展运算符 …后边跟上参数名</strong></p>
<p><strong>展开运算符 …参数名</strong></p>
<h4 id="1-2-实现-apply"><a href="#1-2-实现-apply" class="headerlink" title="1-2 实现 apply"></a>1-2 实现 apply</h4><pre><code class="js">// 手写apply
Function.prototype.hyapply = function (thisArg, argArray) &#123;
  var that = this;
  thisArg =
    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;
  thisArg.that = that;
  var result;
  argArray = argArray || [];
  result = thisArg.that(...argArray);
  delete thisArg.that;
  return result;
&#125;;
</code></pre>
<ol>
<li><p>获取需要被执行的函数</p>
<pre><code class="js">Function.prototype._call = function (thisArg, arrayArg) &#123;
  var fn = this;
&#125;;
</code></pre>
</li>
<li><p>对 thisArg 转成对象类型（防止传入非对象类型）</p>
<pre><code class="js">//对thisArg转成对象类型（防止传入非对象类型）
thisArg =
  thisArg !== null &amp;&amp; thisArg !== undefined ? Obejct(thisArg) : window;
</code></pre>
</li>
<li><p>调用需要被执行的函数</p>
<pre><code class="js">thisArg.fn = fn;
var result;
arrayArg = arrayArg || [];
result = thisArg.fn(...arrayArg);
delete thisArg.fn;
</code></pre>
</li>
<li><p>将最终的结果返回</p>
<pre><code class="js">return result;
</code></pre>
</li>
</ol>
<h4 id="1-3-bind-方法实现"><a href="#1-3-bind-方法实现" class="headerlink" title="1-3 bind 方法实现"></a>1-3 bind 方法实现</h4><pre><code class="js">// 手写bind
Function.prototype.hybind = function (thisArg, ...argArray) &#123;
  var that = this;
  thisArg =
    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;
  return function (...arr) &#123;
    thisArg.that = that;
    var arg = [...argArray, ...arr];
    var result = thisArg.that(...arg);
    delete thisArg.that;
    return result;
  &#125;;
&#125;;
</code></pre>
<ol>
<li><p>获取调用函数</p>
<pre><code class="js">Function.prototype.hybind = function (thisArg, ...argArray) &#123;
  var fn = this;
&#125;;
</code></pre>
</li>
<li><p>绑定 this</p>
<pre><code class="js">thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? thisArg : window;
</code></pre>
</li>
<li><p>调用函数</p>
<pre><code class="js">function proxyfn(...args) &#123;
  thisArg.fn = fn;
  var arr = [...argArray, ...args];
  var result = thisArg.fn(...arr);
  delete thisArg.fn;
  return result;
&#125;
</code></pre>
</li>
<li><p>返回结果</p>
<pre><code class="js">return proxfn;
</code></pre>
</li>
</ol>
<h3 id="2-认识-arguments"><a href="#2-认识-arguments" class="headerlink" title="2. 认识 arguments"></a>2. 认识 arguments</h3><p>arguments 是一个类数组对象，长得像是一个数组，本质是一个对象</p>
<p>不能调用数组的方法</p>
<p><strong>常见的对 arguments 的三个操作</strong></p>
<ol>
<li>获取参数的长度</li>
<li>根据索引值获取某一个参数</li>
<li>callee 获取当前 arguments 所在的函数</li>
</ol>
<h3 id="3-arguments-转为数组"><a href="#3-arguments-转为数组" class="headerlink" title="3. arguments 转为数组"></a>3. arguments 转为数组</h3><p>1.第一种方法</p>
<p>var newarr=Array.prototype.slice.call(arguments)</p>
<p>2.第二种 遍历 arguments 把每一项加到新数组中</p>
<p>3.第三种方法 es6 语法 var newarr= Array.from（arguments）</p>
<p>4.第四种方法 扩展运算符 var newArr=[…arguments]</p>
<h3 id="4-箭头函数中没有-arguments"><a href="#4-箭头函数中没有-arguments" class="headerlink" title="4. 箭头函数中没有 arguments"></a>4. 箭头函数中没有 arguments</h3><p>在箭头函数中么没有 arguments 他就会去上层作用域查找。</p>
<p>在全局环境下：</p>
<p>浏览器中没有 arguments</p>
<p>node 环境下：有</p>
<h2 id="第七节-函数式编程-（回头再仔细观看目前先了解）"><a href="#第七节-函数式编程-（回头再仔细观看目前先了解）" class="headerlink" title="第七节 函数式编程 （回头再仔细观看目前先了解）"></a>第七节 函数式编程 （回头再仔细观看目前先了解）</h2><h3 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1. 函数式编程"></a>1. 函数式编程</h3><p>一种编程的方式</p>
<h3 id="2-纯函数"><a href="#2-纯函数" class="headerlink" title="2. 纯函数"></a>2. 纯函数</h3><p>概念:</p>
<ul>
<li>确定的输入，一定会产生确定的输出</li>
<li>在函数执行过程中，不能产生副作用</li>
</ul>
<p><strong>副作用：在执行函数时，除了返回函数值之外，还对调用函数产生了附加影响，比如修改了全局变量，修改参数或者改变外部的存储</strong></p>
<h3 id="3-函数柯里化"><a href="#3-函数柯里化" class="headerlink" title="3. 函数柯里化"></a>3. 函数柯里化</h3><p>概念：值传递给函数一部分参数来调用它，让他返回一个函数去处理剩余参数 这个过程就叫做柯里化</p>
<p><img src="/2022/021964822/image-20220110221137680.png"></p>
<h3 id="4-柯里化的实现"><a href="#4-柯里化的实现" class="headerlink" title="4. 柯里化的实现"></a>4. 柯里化的实现</h3><p><img src="/2022/021964822/image-20220111124307191.png"></p>
<h3 id="5-理解组合函数"><a href="#5-理解组合函数" class="headerlink" title="5. 理解组合函数"></a>5. 理解组合函数</h3><p><img src="/2022/021964822/image-20220111124728862.png"></p>
<h2 id="第八节-面向对象"><a href="#第八节-面向对象" class="headerlink" title="第八节 面向对象"></a>第八节 面向对象</h2><h3 id="1-with-语句"><a href="#1-with-语句" class="headerlink" title="1. with 语句"></a>1. with 语句</h3><p>with 语句：可以形成自己的作用域</p>
<p>with（参数是一个对象）{ }</p>
<p>查找变量先去对象中查找再去上层作用域中查找</p>
<p><strong>不推荐使用</strong></p>
<h3 id="2-eval-函数"><a href="#2-eval-函数" class="headerlink" title="2. eval 函数"></a>2. eval 函数</h3><p>eval 是一个特殊的函数，全局函数，将传入的字符当做 js 代码执行</p>
<p><strong>不推荐使用 可读性差 不能被 js 引擎优化</strong></p>
<h3 id="3-认识严格模式"><a href="#3-认识严格模式" class="headerlink" title="3. 认识严格模式"></a>3. 认识严格模式</h3><p>具有限制性的 js 模式，从而使代码隐式的脱离了 懒散模式</p>
<p>“use strict”;</p>
<p><img src="/2022/021964822/image-20220111135259635.png"></p>
<h3 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4. 面向对象"></a>4. 面向对象</h3><h4 id="4-1-创建对象的方式一"><a href="#4-1-创建对象的方式一" class="headerlink" title="4-1 创建对象的方式一"></a>4-1 创建对象的方式一</h4><p>var obj=new Object（）</p>
<p>obj.name=’123’</p>
<h4 id="4-2-创建对象方式二"><a href="#4-2-创建对象方式二" class="headerlink" title="4-2 创建对象方式二"></a>4-2 创建对象方式二</h4><p>var obj={</p>
<p>​ name：‘456’</p>
<p>}</p>
<h3 id="5-对对象属性的操作"><a href="#5-对对象属性的操作" class="headerlink" title="5. 对对象属性的操作"></a>5. 对对象属性的操作</h3><p>想要对对象进行比较精准的操作控制时需要使用 Object.defineProperty(第一个参数对那个对象进行操作，第二个传参数对那个属性进行操作，第三个参数要定义或修改的属性描述符 是个对象{})</p>
<pre><code class="js">//定义单个属性符
Object.definedProperty（）
</code></pre>
<p><img src="/2022/021964822/image-20220111144926574.png"></p>
<h3 id="6-Object-defineProperty（obj，name，-）的数据属性描述符"><a href="#6-Object-defineProperty（obj，name，-）的数据属性描述符" class="headerlink" title="6. Object.defineProperty（obj，name，{}）的数据属性描述符"></a>6. Object.defineProperty（obj，name，{}）的数据属性描述符</h3><p><img src="/2022/021964822/image-20220111145110625.png"></p>
<h3 id="7-Object-defineProperty（obj，name，-）-存取属性描述符"><a href="#7-Object-defineProperty（obj，name，-）-存取属性描述符" class="headerlink" title="7.Object.defineProperty（obj，name，{}） 存取属性描述符"></a>7.Object.defineProperty（obj，name，{}） 存取属性描述符</h3><p><img src="/2022/021964822/image-20220111150939972.png"></p>
<p>存取属性描述符的应用场景：</p>
<ol>
<li><strong>当我们需要私有属性不希望被外界使用赋值</strong></li>
<li><strong>我们希望能截获某一个属性他访问和设置值得过程时，也会使用存储属性描述符</strong></li>
</ol>
<p>存储属性描述符存在时，writable 和 value 就不会存在这两组只能存在一个</p>
<p>JS 严格意义上没有私有属性，但是社区规范_开头的是私有属性</p>
<h2 id="第九节-原型-继承"><a href="#第九节-原型-继承" class="headerlink" title="第九节 原型 继承"></a>第九节 原型 继承</h2><h3 id="1-定义多个属性描述符"><a href="#1-定义多个属性描述符" class="headerlink" title="1. 定义多个属性描述符"></a>1. 定义多个属性描述符</h3><p>Object.definedProperties（） 定义多个属性</p>
<pre><code class="js">Object.definedProperties(obj,&#123;
    name:&#123;
        configurable:true,
        enumerable:true,
        writable:true,
        value:&quot;why&quot;
    &#125;,
    age:&#123;
        configurable:false,
        enumerable:false,
     get：function（）&#123;
       return this._age;
    &#125;,
    set:function(value)&#123;
        this._age=value
    &#125;
&#125;)
</code></pre>
<h3 id="2-对象方法的补充"><a href="#2-对象方法的补充" class="headerlink" title="2. 对象方法的补充"></a>2. 对象方法的补充</h3><ul>
<li><p>获取某一个特定属性的描述符</p>
<p>Object.getOwnPropertyDescriptor（obj，”属性名”）</p>
</li>
<li><p>获取对象所有属性的描述符</p>
<p>Object.getOwnPropertyDescriptors（obj）</p>
</li>
</ul>
<h3 id="3-Object-的方法对对象的限制"><a href="#3-Object-的方法对对象的限制" class="headerlink" title="3. Object 的方法对对象的限制"></a>3. Object 的方法对对象的限制</h3><ul>
<li><p>禁止对象继续添加新的属性</p>
<p>Object.preventExtensions（obj）</p>
</li>
<li><p>禁止对象配置/删除里面的属性</p>
<p>Object.seal（obj）</p>
</li>
<li><p>让属性不可以修改</p>
<p>Object.freeze（obj）</p>
</li>
</ul>
<h3 id="4-创建对象方案"><a href="#4-创建对象方案" class="headerlink" title="4. 创建对象方案"></a>4. 创建对象方案</h3><ol>
<li><p>工厂模式创建对象</p>
<p>利用函数批量创建对象</p>
<p><img src="/2022/021964822/image-20220111173836223.png"></p>
</li>
<li><p>利用构造函数创建对象</p>
<p>一个函数通过 new 关键字调用，那么这个函数就是构造函数了</p>
</li>
</ol>
<h3 id="5-new-关键字的运行过程"><a href="#5-new-关键字的运行过程" class="headerlink" title="5. new 关键字的运行过程"></a><strong>5. new 关键字的运行过程</strong></h3><ol>
<li><strong>在内存中开辟一个新的对象</strong></li>
<li><strong>这个对象内部的[[prototype]]属性会赋值为该构造函数的 prototype 属性</strong></li>
<li><strong>this 指向这个对象</strong></li>
<li><strong>执行函数的内部代码</strong></li>
<li><strong>返回这个对象</strong></li>
</ol>
<h3 id="6-对象的原型"><a href="#6-对象的原型" class="headerlink" title="6. 对象的原型"></a>6. 对象的原型</h3><p>获取对象的原型 每个对象都有一个[[prototype]] 这个属性称之为对象的原型 （隐式原型）</p>
<p>Object.getPrototypeOf（obj）</p>
<p>obj. ** proto ** 是浏览器给的方法不符合规范但是可以调试用 存在浏览器兼容问题</p>
<h3 id="7-函数的原型"><a href="#7-函数的原型" class="headerlink" title="7. 函数的原型"></a>7. 函数的原型</h3><p>函数作为对象来说，它也是有[[prototype]] 隐式原型</p>
<p>函数还会多出来一个显示原型属性：prototype</p>
<p>函数的原型中有一个属性 constructor 它指向构造函数本身 但是它是不可枚举状态</p>
<p>批量往原型中添加属性方法：</p>
<pre><code class="js">foo.prototype=&#123;
 name：&#39;haonan&#39;,
 age:18,
 sex:&#39;男&#39;
&#125;
//不要忘记添加constructor   因为本来原型中constructor属性就是不可枚举  所以要通过objectdefinedproperty这个方法才能完整添加
Object.definedProperty(foo.prototype,&#39;constructor&#39;,&#123;
    enmurible:false,
    writable:true,
    value:foo,
    configrable:true
&#125;)
</code></pre>
<h2 id="第十节-原型链-继承"><a href="#第十节-原型链-继承" class="headerlink" title="第十节 原型链 继承"></a>第十节 原型链 继承</h2><h3 id="1-可枚举属性的补充"><a href="#1-可枚举属性的补充" class="headerlink" title="1. 可枚举属性的补充"></a>1. 可枚举属性的补充</h3><p>我们设置对象属性不可枚举但是在浏览器中可以显示，但是它依然不可枚举，浏览器为了方便我们调试显示出来。</p>
<h3 id="2-面向对象的三大特性"><a href="#2-面向对象的三大特性" class="headerlink" title="2. 面向对象的三大特性"></a>2. 面向对象的三大特性</h3><p>封装 继承 多态</p>
<p>封装：将我们的属性和方法封装到一个类中，可以称之为封装的过程。</p>
<p>继承：是多态的前提（纯面向对象中），重复利用一些代码</p>
<p>多态：不同的对象在执行时表现出不同的形态。</p>
<h3 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3. 原型链"></a>3. 原型链</h3><h4 id="3-1原型链（-proto-）的概念："><a href="#3-1原型链（-proto-）的概念：" class="headerlink" title="3-1原型链（ proto ）的概念："></a>3-1<strong>原型链（</strong> proto <strong>）的概念：</strong></h4><p><strong>当我们查找对象中的一个属性时，先查找这个对象有没有，如果没有时会去原型对象上查找，如果原型对象上没有时会去原型对象里的原型对象上查找，一直查找到顶层原型对象 Object，这个查找过程形成了一个链式查找这就叫做原型链。</strong></p>
<h4 id="3-2-原型链的顶层对象"><a href="#3-2-原型链的顶层对象" class="headerlink" title="3-2 原型链的顶层对象"></a>3-2 原型链的顶层对象</h4><p>Object 原型对象的 ** proto ** 指向 null</p>
<p>原型链查找到 Object 原型对象时就会停止查找，也就是 Object 原型对象就是顶层的原型。</p>
<h4 id="3-3-顶层原型来自哪里"><a href="#3-3-顶层原型来自哪里" class="headerlink" title="3-3 顶层原型来自哪里"></a>3-3 顶层原型来自哪里</h4><p>Object 的 prototype 就是我们的顶层原型</p>
<p>var obj={ }创建对象 是 var obj2=new Object（） 的语法糖写法</p>
<p>本质上 Object 就是一个函数</p>
<p><strong>Object 是所有类的父类</strong></p>
<p>由此可以得出结论 ： 原型链最顶层的原型对象就是 Object 的原型对象。</p>
<h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h3><p>继承就是把一些公共的属性方法封装到父类中，特有的方法属性放到子类中，但是子类可以调用父类的属性和方法。</p>
<h4 id="4-1-原型链原理继承"><a href="#4-1-原型链原理继承" class="headerlink" title="4-1 原型链原理继承"></a>4-1 原型链原理继承</h4><p>把子类的原型设置为父类的实例化</p>
<p><strong>但是要注意书写位置 要写在紧跟着子类构造函数下边</strong></p>
<p>Student.prototype=new Person();</p>
<pre><code class="js">function Person（）&#123;
    this.name=&#39;why&#39;
    this.friends=[]
&#125;
Person.prototype.eating=function()&#123;
    console.log(this.name&#39;eating&#39;)
&#125;
function Student ()&#123;
    this.sno=111
&#125;
var p=new Person() // &#123;name=&#39;why&#39;,friends:[]&#125;
Student.prototype=p;
Student.prototype.studying=function()&#123;
    console.log(this.name+&#39;studing&#39;)
&#125;
var stu1=new Student()
var stu2=new Student()
//获取引用 ，修改引用中的值 会互相影响
stud2.friends.push(&#39;kobe&#39;)
console.log(stu1.friends) // 都是kobe  相互影响
console.log(stu2.friends) // kobe
</code></pre>
<p><strong><font color="red">原型链实现继承弊端:</font></strong></p>
<ol>
<li><strong><font color="red">打印 stu 对象继承的属性是看不到的</font></strong></li>
<li><strong><font color="red">创建出两个 stu 对象</font></strong></li>
<li><strong><font color="red">在前面实现类的过程中是没有传递参数的</font></strong></li>
</ol>
<h4 id="4-2-借用构造函数继承"><a href="#4-2-借用构造函数继承" class="headerlink" title="4-2 借用构造函数继承"></a>4-2 借用构造函数继承</h4><p>在子类中 调用一下父类方法 把子类的 this 传入父类 传入子类参数</p>
<p><strong>解决了原型继承的弊端</strong></p>
<p><strong>Person.call(this，name，age，friends)</strong></p>
<pre><code class="js">function Person(name,age,friends)&#123;
    this.name=name
    this.age=age
    this.friends=[]
&#125;
Person.prototype.eating=function()&#123;
    console.log(this.name&#39;eating&#39;)
&#125;
function Student (name,age,friends,sno)&#123;
    // 解决了可以传递参数  并且不是在Student类中  通过调用 Person  把Student的this传入
    Person.call(this,name,age,friends)
    this.sno=sno
&#125;
var p=new Person() // &#123;name=&#39;why&#39;,friends:[]&#125;
Student.prototype=p;
Student.prototype.studying=function()&#123;
    console.log(this.name+&#39;studing&#39;)
&#125;
var stu1=new Student(&quot;why&quot;,18,[&#39;lilei&#39;])
var stu2=new Student(&quot;kobe&quot;,30,[&quot;james&quot;])
</code></pre>
<p><strong><font color="red">借用构造函数继承弊端:</font></strong></p>
<ol>
<li><strong><font color="red">Person 函数至少被调用了两次</font></strong></li>
<li><strong><font color="red">stu 的原型对象上会多出一些属性，但是这些属性没有存在的必要</font></strong></li>
</ol>
<h4 id="4-3-原型式继承函数-对象上的继承"><a href="#4-3-原型式继承函数-对象上的继承" class="headerlink" title="4-3 原型式继承函数(对象上的继承)"></a>4-3 原型式继承函数(对象上的继承)</h4><p>创建一个函数传入一个对象参数，把一个对象的原型设置为传入的对象参数</p>
<p>老式原型式继承函数</p>
<pre><code class="js">function createObject1(obj) &#123;
  function Fn() &#123;&#125;
  Fn.prototype = obj;
  var newObj = new Fn();
  return newObj;
&#125;
</code></pre>
<p>新式原型式继承函数</p>
<pre><code class="js">function createObject2(o) &#123;
  var newObj = &#123;&#125;;
  Object.setPrototypeOf(newObj, o);
  return newObj;
&#125;
</code></pre>
<p>最新版 esma 规范原型式继承函数</p>
<pre><code class="js">var newObj = Object.create(obj);
</code></pre>
<h4 id="4-4-寄生式继承函数（理解即可）"><a href="#4-4-寄生式继承函数（理解即可）" class="headerlink" title="4-4 寄生式继承函数（理解即可）"></a>4-4 寄生式继承函数（理解即可）</h4><p>结合工厂函数 以及原型式继承函数的方法</p>
<h4 id="4-5-寄生组合式继承-（最终版继承）"><a href="#4-5-寄生组合式继承-（最终版继承）" class="headerlink" title="4-5 寄生组合式继承 （最终版继承）"></a>4-5 寄生组合式继承 （最终版继承）</h4><p>利用寄生函数 与借用构造函数 组合的形式实现最终版继承</p>
<pre><code class="js">function Person (name,age,friends)&#123;
    this.name=name
    this.age=age
    this.friends=friends
&#125;
Person.prototype.eating=function()&#123;
    console.log(&#39;eatting&#39;)
&#125;
Person.prototype.running=function()&#123;
    console.log(&#39;running&#39;)
&#125;
function Students(name,age,friends,sno)&#123;
    Person.call(this,name,age,friends);
    this.sno=sno
&#125;
//寄生组合式函数
function creatObject(o)&#123;
   function Fn()&#123;&#125;
   Fn.prototype=o
   return new Fn()

&#125;
function inheritPrototype(SubType(子类),SuperType(父类))&#123;
    SubType.prototype=creatObject(SuperType.prototype);
    Object.defineProperty(SubType.prototype,&#39;constructor&#39;,&#123;
        enumerable:false,
        configurable:true,
        writable:true,
        value:SubType
    &#125;)
&#125;
inheritPrototype(Student,Person);
</code></pre>
<h3 id="5-原型判断的方法补充"><a href="#5-原型判断的方法补充" class="headerlink" title="5. 原型判断的方法补充"></a>5. 原型判断的方法补充</h3><h4 id="5-1-hasOwnProperty（）"><a href="#5-1-hasOwnProperty（）" class="headerlink" title="5-1 hasOwnProperty（）"></a>5-1 hasOwnProperty（）</h4><p>对象名.hasOwnProperty(属性名)</p>
<p><strong>‘属性名’ in 对象名 in 操作符不管在对象中还是原型中都返回 true</strong></p>
<h4 id="5-2-instanceof"><a href="#5-2-instanceof" class="headerlink" title="5-2 instanceof"></a>5-2 instanceof</h4><p>检测构造函数的 prototype 是否出现在某个实例对象的原型链上</p>
<p>只能判断函数</p>
<h4 id="5-3-isPrototypeOf"><a href="#5-3-isPrototypeOf" class="headerlink" title="5-3 isPrototypeOf"></a>5-3 isPrototypeOf</h4><p>用于检测某个对象是否出现在某个实例对象的原型链上</p>
<p>区别：只能判断对象</p>
<h3 id="6-对象-函数-原型的关系"><a href="#6-对象-函数-原型的关系" class="headerlink" title="6. 对象-函数-原型的关系"></a>6. 对象-函数-原型的关系</h3><p>函数其实也可以看成一个对象 也可以看成函数 所以它拥有 prototype 属性 以及对象拥有的** proto **</p>
<p><strong>从函数的角度看</strong>：</p>
<p>Function 的原型对象继承于 Object 的原型对象</p>
<p>Function.prototype.** proto **===Object.prototype</p>
<p><strong>从对象的角度看</strong>：</p>
<p>但是因为 Object 其实也是一个函数 所以 Object 的 ** proto ** 又指向了 Function 的 prototype</p>
<p>Object.** proto ** ===Function.prototype</p>
<p><img src="/2022/021964822/image-20220115113159991.png"></p>
<h2 id="第十一节-Es6-中的-class"><a href="#第十一节-Es6-中的-class" class="headerlink" title="第十一节 Es6 中的 class"></a>第十一节 Es6 中的 class</h2><h4 id="1-class-定义类的方式"><a href="#1-class-定义类的方式" class="headerlink" title="1. class 定义类的方式"></a>1. class 定义类的方式</h4><pre><code class="js">//类的声明  普遍用法
class Person&#123;

&#125;
typeof（person） //function


// 类的表达式  用的比较少
var anni=class &#123;&#125;
</code></pre>
<h4 id="2-类的构造方法"><a href="#2-类的构造方法" class="headerlink" title="2. 类的构造方法"></a>2. 类的构造方法</h4><p><strong>注意：一个类只能有一个构造函数，如果没写构造函数 默认生成一个空的构造函数</strong></p>
<pre><code class="js">class Person &#123;
  // 类的 构造方法
  constructor(name, age) &#123;
    this.name = name;
    this.age = age;
  &#125;
&#125;
var str = new Person(&quot;why&quot;, 18);
</code></pre>
<p><strong>当我们通过 new 关键字操作类的时候，会调用 constructor 这个函数，并执行以下操作：</strong></p>
<ol>
<li>在内存中创建一个新的对象（空对象）</li>
<li>这个对象内部的[[prototype]]属性会被赋值为该类的 prototype 属性；</li>
<li>构造函数内部的 this，会指向创建出来的新对象</li>
<li>执行构造函数的内部代码（函数体代码）</li>
<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>
</ol>
<h3 id="3-class-中的方法定义"><a href="#3-class-中的方法定义" class="headerlink" title="3. class 中的方法定义"></a>3. class 中的方法定义</h3><pre><code class="js">class Person &#123;
  constructor(name, age) &#123;
    this.name = name;
    this.age = age;
    this._address = &quot;青岛&quot;;
  &#125;
  //直接写在下面
  eating() &#123;
    console.log(this.name + &quot;eating&quot;);
  &#125;
  //类的访问器方法定义
  get address() &#123;
    console.log(&quot;拦截访问操作&quot;);
    return this._address;
  &#125;
  set address(newAddress) &#123;
    console.log(&quot;拦截设置操作&quot;);
    this._address = newAddress;
  &#125;
  //类的静态方法  static关键字创建 也叫作类方法
  //通过类调用的方法  Person.creatPerson()
  static creatPerson() &#123;&#125;
&#125;
</code></pre>
<h3 id="4-es6-实现继承"><a href="#4-es6-实现继承" class="headerlink" title="4. es6 实现继承"></a>4. es6 实现继承</h3><p>extends 关键字</p>
<p>super 关键字调用父类的构造函数 使用位置有三个：构造方法中 类的访问器方法 类的静态方法中</p>
<p>super 第一个用法 super（） 调用父类的构造方法</p>
<p>super 第二个用法 super.父类中的方法() 复用父类方法的逻辑</p>
<pre><code class="js">class Person&#123;
    constructor(name.age)&#123;
        this.name=name
        this.age=age
    &#125;
    running()&#123;
        console.log(&#39;running&#39;)
    &#125;
&#125;

class Student extends Person&#123;
    constructor(name，age，sno)&#123;
        //访问this之前或者使用return之前必须通过super调用父类构造函数
        super(name,age)
        this.sno=sno
    &#125;
    //对父类方法重写 在running方法的基础之上
    running()&#123;
        super.running()
        console.log(&#39;456&#39;)
    &#125;
&#125;
</code></pre>
<h3 id="5-Es6-代码转-Es5-代码"><a href="#5-Es6-代码转-Es5-代码" class="headerlink" title="5. Es6 代码转 Es5 代码"></a>5. Es6 代码转 Es5 代码</h3><p>由于有的浏览器不支持 es6 代码，所以我们还是要将代码转成 es5 代码</p>
<h3 id="6-怎么阅读源码"><a href="#6-怎么阅读源码" class="headerlink" title="6. 怎么阅读源码"></a>6. 怎么阅读源码</h3><ol>
<li><strong>一定不要浮躁</strong></li>
<li><strong>看源码忘记前面使用 Bookmarks vscode 插件阅读源码插件 ctrl+alt+k</strong></li>
<li>**读完一个函数还是不知道干什么的，只能不断地提高自己积累 **</li>
<li><strong>debugger 通过 debugger 调试代码</strong></li>
</ol>
<h2 id="第十二节-ES6-ES12（一）"><a href="#第十二节-ES6-ES12（一）" class="headerlink" title="第十二节 ES6 -ES12（一）"></a>第十二节 ES6 -ES12（一）</h2><h3 id="1-继承内置类"><a href="#1-继承内置类" class="headerlink" title="1. 继承内置类"></a>1. 继承内置类</h3><p>不写继承 默认继承 Object</p>
<p>想继承其他内置类</p>
<pre><code class="js">class Person extends Array &#123;&#125;
</code></pre>
<h3 id="2-类的混入-minxin"><a href="#2-类的混入-minxin" class="headerlink" title="2. 类的混入 minxin"></a>2. 类的混入 minxin</h3><p><strong>Js 只能有一个父类：单继承</strong></p>
<h3 id="3-Javascript-中的多态"><a href="#3-Javascript-中的多态" class="headerlink" title="3. Javascript 中的多态"></a>3. Javascript 中的多态</h3><p>多态：不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现。</p>
<h3 id="4-Es6-对象字面量增强写法"><a href="#4-Es6-对象字面量增强写法" class="headerlink" title="4. Es6 对象字面量增强写法"></a>4. Es6 对象字面量增强写法</h3><pre><code class="js">var name = &quot;why&quot;;
var age = 18;
var obj = &#123;
  //1.可以省略掉value值  如果key值和value值一致 属性的简写
  name,
  age,
  foo: function () &#123;&#125;,
  // 2. foo可以简写成这样 方法的简写
  foo() &#123;&#125;,
  // 3. 计算属性名 computed property name
  [name + 123]: &quot;hehehe&quot;,
&#125;;
</code></pre>
<h3 id="5-解构"><a href="#5-解构" class="headerlink" title="5. 解构"></a>5. 解构</h3><ol>
<li><p><strong>数组的解构</strong></p>
<pre><code class="js">var names =[&quot;abc&quot;,&quot;cba&quot;,&quot;nba&quot;]
var [item1,item2,item3]=names

//只解构后边两个元素
var [,item2，item3] =names

//解构出一个元素后边的元素放入某个数组中
var [itema,...newNames]=names

//解构的默认值 当itemd没有结构出值得时候默认值是a
var [itema,itemb,itemc,itemd=&quot;aaa&quot;]=names
</code></pre>
</li>
<li><p><strong>对象的解构</strong></p>
<pre><code class="js">var obj = &#123;
  name: &quot;why&quot;,
  age: 18,
  height: 1.88,
&#125;;
//对象的解构用 &#123;&#125;
var &#123; name, age, height &#125; = obj;

//更改解构出来的名字
var &#123; name: newName &#125; = obj;

//默认值
var &#123; address: newAddress = &quot;广州市&quot; &#125; = obj;
</code></pre>
</li>
</ol>
<h3 id="6-let-const"><a href="#6-let-const" class="headerlink" title="6. let/const"></a>6. let/const</h3><h4 id="6-1-let-const-基本使用"><a href="#6-1-let-const-基本使用" class="headerlink" title="6-1 let/const 基本使用"></a>6-1 let/const 基本使用</h4><ul>
<li><p><strong>let 声明变量</strong></p>
<pre><code class="js">let var =123
</code></pre>
</li>
<li><p><strong>const 声明常量</strong></p>
<pre><code class="js">const obj&#123;
    name:&#39;haonan&#39;,
    age:18
&#125;
obj.name=&#39;why&#39;
</code></pre>
</li>
</ul>
<p>注意事项：</p>
<p><strong>1.但是声明引用类型时，可以通过引用找到对应的对象 修改对象内部的属性</strong></p>
<p><strong>2.通过 let/const 定义的变量名不能重复定义</strong></p>
<h4 id="6-2-let-const-作用域提升"><a href="#6-2-let-const-作用域提升" class="headerlink" title="6-2 let/const 作用域提升"></a>6-2 let/const 作用域提升</h4><p><strong>let/const 是没有进行作用域提升，但是在执行上下文创建阶段被创建出来</strong></p>
<h4 id="6-3-let-const-和-window-的关系"><a href="#6-3-let-const-和-window-的关系" class="headerlink" title="6-3 let/const 和 window 的关系"></a>6-3 let/const 和 window 的关系</h4><p>用 var 声明变量在全局，会在 window 上添加一个属性 let/const 不会再 window 上添加属性</p>
<p>let/const 声明的变量 在最新规范中，存放到 ve 中 varibles_：VaribleMap 里面</p>
<p>window 单独由浏览器提供 所以 window 访问不了 let/const 声明的变量</p>
<h4 id="6-4-块级作用域"><a href="#6-4-块级作用域" class="headerlink" title="6-4 块级作用域"></a>6-4 块级作用域</h4><p><strong>块级作用域：{}中声明的变量只能在{}中使用，es5 中没有块级作用域。</strong></p>
<p><strong>ES5 中只有两个作用域：全局作用域 函数作用域</strong>。</p>
<p><strong>es6 中的块级作用域：let/const/function/class 声明的类型有效</strong></p>
<p><strong>if 语句 switch 语句 for 块级代码的代码块就是块级作用域</strong></p>
<h2 id="第十三节-ES6-ES12（二）"><a href="#第十三节-ES6-ES12（二）" class="headerlink" title="第十三节 ES6 -ES12（二）"></a>第十三节 ES6 -ES12（二）</h2><h3 id="1-暂时性死区"><a href="#1-暂时性死区" class="headerlink" title="1. 暂时性死区"></a>1. 暂时性死区</h3><p><strong>使用 let/const 声明的变量，在声明之前不可以访问</strong></p>
<h3 id="2-var-let-const-的选择"><a href="#2-var-let-const-的选择" class="headerlink" title="2. var let const 的选择"></a>2. var let const 的选择</h3><p><strong>实际工作中不用 var 声明变量，推荐使用 let/const，优先使用 const</strong></p>
<p>能用 const 就用 const</p>
<h3 id="3-字符串模板"><a href="#3-字符串模板" class="headerlink" title="3. 字符串模板"></a>3. 字符串模板</h3><p><strong>`` 可以优雅的拼接字符串变量</strong></p>
<pre><code class="js">const name = &quot;why&quot;;
const str = `hello$&#123;name&#125;`;
console.log(str); // hello why
</code></pre>
<p>也可以在模板字符串中写表达式</p>
<pre><code class="js">function doubleAge() &#123;
  return age * 2;
&#125;
const str = `hello$&#123;doubleAge()&#125;`;
</code></pre>
<h3 id="4-标签模板字符串"><a href="#4-标签模板字符串" class="headerlink" title="4. 标签模板字符串"></a>4. 标签模板字符串</h3><p>另外一种调用函数的方法</p>
<pre><code class="js">function foo(m, n) &#123;
  console.log(m, n);
&#125;
foo();
//利用标签模板字符串调用函数 基本上很少这样使用
// 第一个参数依然是模板字符串中的整个字符串被切成多块 放入一个数组中
// 第二个参数是模板字符串中 第一个$&#123;&#125;
foo`hello$&#123;name&#125;wro$&#123;age&#125;ld`;
</code></pre>
<h3 id="5-函数参数的默认值"><a href="#5-函数参数的默认值" class="headerlink" title="5. 函数参数的默认值"></a>5. 函数参数的默认值</h3><h4 id="5-1-ES5-中函数参数的默认值："><a href="#5-1-ES5-中函数参数的默认值：" class="headerlink" title="5-1 ES5 中函数参数的默认值："></a>5-1 ES5 中函数参数的默认值：</h4><p>缺点：可读性差写起来麻烦 有 bug</p>
<pre><code class="js">function foo(m, n) &#123;
  m = m || &quot;123&quot;;
  n = n || &quot;456&quot;;
&#125;
</code></pre>
<h4 id="5-2-ES6-中的函数默认参数"><a href="#5-2-ES6-中的函数默认参数" class="headerlink" title="5-2 ES6 中的函数默认参数"></a>5-2 ES6 中的函数默认参数</h4><pre><code class="js">function foo(m = &quot;123&quot;, n = &quot;456&quot;) &#123;&#125;
foo();
</code></pre>
<h4 id="5-3-对象参数和默认值以及解构："><a href="#5-3-对象参数和默认值以及解构：" class="headerlink" title="5-3 对象参数和默认值以及解构："></a>5-3 对象参数和默认值以及解构：</h4><pre><code class="js">function printInfo(&#123; name, age &#125; = &#123; name: &quot;why&quot;, age: 18 &#125;) &#123;
  console.log(name, age);
&#125;

//另一种写法
function printInfo(&#123; name = &quot;why&quot;, age = 18 &#125;) &#123;
  console.log(name, age);
&#125;
</code></pre>
<p><strong>有默认值的形参放到最后</strong></p>
<h4 id="5-4-有默认值的函数的-length-属性"><a href="#5-4-有默认值的函数的-length-属性" class="headerlink" title="5-4 有默认值的函数的 length 属性"></a>5-4 有默认值的函数的 length 属性</h4><p>有默认值的参数不算在 length 里面包括，这个参数以后的也都不会算在 length 里面</p>
<h3 id="6-函数的剩余参数"><a href="#6-函数的剩余参数" class="headerlink" title="6. 函数的剩余参数"></a>6. 函数的剩余参数</h3><p>如果最后一个参数是…前缀的，那么它将会将剩余的参数放到数组中</p>
<pre><code class="js">function foo(m, n, ...args) &#123;
  console.log(m, n);
  console.log(args);
&#125;
foo(20, 30, 40, 50, 60);
</code></pre>
<p><strong>剩余参数拿到的是一个真正的数组，可以使用数组的方法</strong></p>
<h3 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7. 箭头函数"></a>7. 箭头函数</h3><p>（）=&gt;{ }</p>
<p>箭头函数没有 prototype 没有显式原型</p>
<p>没有 arguments 要去上层作用域查找</p>
<p>没有 this 要去上层作用域查找</p>
<h3 id="8-展开语法"><a href="#8-展开语法" class="headerlink" title="8. 展开语法"></a>8. 展开语法</h3><p>不仅可以展开数组 也可以展开字符串</p>
<pre><code class="js">const names = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];
const name = &quot;why&quot;;
const info = &#123; name: &quot;why&quot;, age: 18 &#125;;
//1.函数调用时
function foo(x, y, z) &#123;
  console.log(x, y, z);
&#125;
//展开运算符
foo(...names);
//2. 构造数组时
const newNames = [...names, ...name];
//3. ES2018 构建对象字面量时使用展开运算符
const obj = &#123; ...info, address: &quot;广州市&quot; &#125;;
console.log(obj);
</code></pre>
<p><strong>展开运算符其实是进行浅拷贝</strong></p>
<h3 id="9-数值的表示"><a href="#9-数值的表示" class="headerlink" title="9. 数值的表示"></a>9. 数值的表示</h3><p>ES6 中规范了二进制八进制的方式</p>
<p>二进制：0b 开头</p>
<p>八进制：0o 开头</p>
<p>十六进制：0x 开头</p>
<p>大的数值连接符 ：10<em>000_000</em></p>
<h3 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10. Symbol"></a>10. Symbol</h3><h4 id="10-1-Symbol-是什么"><a href="#10-1-Symbol-是什么" class="headerlink" title="10-1 Symbol 是什么"></a>10-1 Symbol 是什么</h4><p><strong>Symbol 是一种基本数据类型，可以生成一个独一无二的值。</strong></p>
<h4 id="10-2-Es5-中没有-Symbol-类型的弊端"><a href="#10-2-Es5-中没有-Symbol-类型的弊端" class="headerlink" title="10-2 Es5 中没有 Symbol 类型的弊端"></a>10-2 Es5 中没有 Symbol 类型的弊端</h4><p>ES6 之前对象的属性名其实都是字符串类型，容易造成属性名冲突</p>
<p>ES6 之后对象的属性名可以使用字符串也可以使用 Symbol 值</p>
<h4 id="10-3-Symbol-的用法"><a href="#10-3-Symbol-的用法" class="headerlink" title="10-3 Symbol 的用法"></a>10-3 Symbol 的用法</h4><pre><code class="js">//第一种写法
const s1 = Symbol();
const s2 = Symbol();
const obj = &#123;
  [s1]: &quot;abc&quot;,
&#125;;
//第二种写法
obj[s1] = &quot;nba&quot;;
//第三种写法
Object.definedProperty(obj, s4, &#123;
  enmuerable: true,
  configurable: true,
  writable: true,
  value: &quot;mba&quot;,
&#125;);
//获取
console.log(obj[s1], obj[s2]);
</code></pre>
<h4 id="10-4-怎么获取-Symbol"><a href="#10-4-怎么获取-Symbol" class="headerlink" title="10-4 怎么获取 Symbol"></a>10-4 怎么获取 Symbol</h4><ul>
<li><p><strong>获取的时候不能通过.语法获取</strong></p>
</li>
<li><p>**使用 Symbol 作为 key 的属性名，在遍历/Object.keys 等中是获取不到的 **</p>
</li>
<li><p><strong>通过 Object.getownPropertySymbols(obj)获取所有的 Symbol 的 key</strong></p>
</li>
<li><p><strong>获取普通属性 Object.getOwnPropertyNames(obj)或者 Object.keys（）</strong></p>
</li>
</ul>
<h4 id="10-5-遍历-Symbol"><a href="#10-5-遍历-Symbol" class="headerlink" title="10-5 遍历 Symbol"></a>10-5 遍历 Symbol</h4><ul>
<li><p><strong>遍历方式</strong>：</p>
</li>
<li><ol>
<li><p>const sKeys=Object.getownPropertySymbols(obj)</p>
</li>
<li><p>for（const skey of sKeys）{</p>
<p>console.log(obj[sKey]）</p>
<p>}</p>
</li>
</ol>
</li>
</ul>
<h4 id="10-6-Symbol-for（）-Symbol-keyfor"><a href="#10-6-Symbol-for（）-Symbol-keyfor" class="headerlink" title="10-6 Symbol.for（）/Symbol.keyfor"></a>10-6 Symbol.for（）/Symbol.keyfor</h4><p>在某些情况下创建一样的 Symbol 值</p>
<ul>
<li>Symbol.for（key）</li>
</ul>
<p>const sa=Symbol.for(‘aaa’);</p>
<p>const sb=Symbol.for(‘aaa’)</p>
<p>获取 Symbol</p>
<ul>
<li>Symbol.keyFor(symbol 值)</li>
</ul>
<p>const key= Symbol.keyFor(sa)</p>
<p>console.log(key)</p>
<p>const sc=Symbol.for(key)</p>
<p>console.log(sa===sc)</p>
<h2 id="第十四节-ES6-ES12（三）"><a href="#第十四节-ES6-ES12（三）" class="headerlink" title="第十四节 ES6 -ES12（三）"></a>第十四节 ES6 -ES12（三）</h2><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><h4 id="在-ES6-之前我们想存储数据只有-数组或者对象两种结构"><a href="#在-ES6-之前我们想存储数据只有-数组或者对象两种结构" class="headerlink" title="在 ES6 之前我们想存储数据只有 数组或者对象两种结构"></a><strong>在 ES6 之前我们想存储数据只有 数组或者对象两种结构</strong></h4><h4 id="ES6-给我们增加了-Set-Map-两种数据结构以及它们的另外形式-WeakSet-WeakMap"><a href="#ES6-给我们增加了-Set-Map-两种数据结构以及它们的另外形式-WeakSet-WeakMap" class="headerlink" title="ES6 给我们增加了 Set Map 两种数据结构以及它们的另外形式 WeakSet WeakMap"></a><strong>ES6 给我们增加了 Set Map 两种数据结构以及它们的另外形式 WeakSet WeakMap</strong></h4><h4 id="数据结构：存放数据的方式"><a href="#数据结构：存放数据的方式" class="headerlink" title="数据结构：存放数据的方式"></a><strong>数据结构：存放数据的方式</strong></h4><h4 id="1-1-Set-是什么"><a href="#1-1-Set-是什么" class="headerlink" title="1-1 Set 是什么"></a>1-1 Set 是什么</h4><ul>
<li>Set 是一个新增的数据结构，可以用来保存数据类似于数组但是和数组的区别是**<font color="red">元素不能重复</font>**</li>
</ul>
<h4 id="1-2-创建-Set-结构"><a href="#1-2-创建-Set-结构" class="headerlink" title="1-2 创建 Set 结构"></a>1-2 创建 Set 结构</h4><pre><code class="js">const set = new Set();
set.add(10);
set.add(20);
set.add(30);
set.add(40);
console.log(set);
</code></pre>
<h4 id="1-3-添加对象是特别注意"><a href="#1-3-添加对象是特别注意" class="headerlink" title="1-3 添加对象是特别注意"></a>1-3 添加对象是特别注意</h4><p><img src="/2022/021964822/image-20220117174405341.png"></p>
<ul>
<li>第一个添加会输出打印两个 {} 因为创建了两个不同的对象在内存中</li>
<li>第二个只会输出一个{} 因为添加的是同一个对象</li>
</ul>
<h4 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1-4 应用场景"></a>1-4 应用场景</h4><ul>
<li><p>对数组去重（去除重复元素）</p>
<pre><code class="js">const arr=[33,10,26,30,33,26]
const arrSet=new Set(arr)
//再将Set结构转为数组结构
const newArr=Array.from(arrSet) 或者 newArr=[...arrSet]
</code></pre>
</li>
</ul>
<h4 id="1-5-Set-常见属性方法"><a href="#1-5-Set-常见属性方法" class="headerlink" title="1-5 Set 常见属性方法"></a>1-5 Set 常见属性方法</h4><ul>
<li><p>size 属性返回对应 Set 结构的数量</p>
<p>.size</p>
</li>
<li><p>add（）方法 添加</p>
</li>
<li><p>delete（元素）删除某个元素</p>
</li>
<li><p>has（元素）判断有没有这个元素 返回布尔值</p>
</li>
<li><p>clear（）清空 set 结构</p>
</li>
</ul>
<h4 id="1-6-遍历-Set"><a href="#1-6-遍历-Set" class="headerlink" title="1-6 遍历 Set"></a>1-6 遍历 Set</h4><ul>
<li>通过 forEach 遍历 arrSet.forEach（）</li>
<li>通过 for of 遍历 set</li>
</ul>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><p><strong>内部的元素也是不能重复</strong></p>
<h4 id="2-1-与-Set-区别"><a href="#2-1-与-Set-区别" class="headerlink" title="2-1 与 Set 区别"></a>2-1 与 Set 区别</h4><ul>
<li><strong>WeakSet 只能存放对象类型不能存放基本数据类型</strong></li>
<li><strong>WeakSet 对对象是弱引用</strong></li>
</ul>
<h4 id="2-2-WeakSet-的方法"><a href="#2-2-WeakSet-的方法" class="headerlink" title="2-2 WeakSet 的方法"></a>2-2 WeakSet 的方法</h4><ul>
<li>add(value):添加某个元素，返回 WeakSet 对象本身</li>
<li>delete（value）：从 WeakSet 中删除和这个值相等的元素，返回布尔值</li>
<li>has（value）：判断 WeakSet 中是否存在某个元素，返回布尔值</li>
</ul>
<h4 id="注意：-WeakSet-不能遍历！！！"><a href="#注意：-WeakSet-不能遍历！！！" class="headerlink" title="注意： WeakSet 不能遍历！！！"></a>注意： WeakSet 不能遍历！！！</h4><h4 id="2-3-WeakSet-应用场景"><a href="#2-3-WeakSet-应用场景" class="headerlink" title="2-3 WeakSet 应用场景"></a>2-3 WeakSet 应用场景</h4><p><img src="/2022/021964822/image-20220117181856580.png"></p>
<h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h3><p>用于存储映射关系可以以对象作为 key 也可以使用基本数据类型作为 key</p>
<h4 id="3-1-和对象储存映射关系的区别"><a href="#3-1-和对象储存映射关系的区别" class="headerlink" title="3-1 和对象储存映射关系的区别"></a>3-1 和对象储存映射关系的区别</h4><ul>
<li>JS 中对象不能使用对象作为 key 的</li>
<li>Map 中可以用对象作为 key</li>
</ul>
<h4 id="3-2-Map-的创建"><a href="#3-2-Map-的创建" class="headerlink" title="3-2 Map 的创建"></a>3-2 Map 的创建</h4><pre><code class="js">//第一种创建方法
const map = new Map();
map.set(obj1, &quot;aaa&quot;);
map.set(obj2, &quot;bbb&quot;);
map.set(obj3, &quot;ccc&quot;);

//第二种创建方法
const map2 = new Map([
  [obj1, &quot;aaaa&quot;],
  [obj2, &quot;bbb&quot;],
  [obj3, &quot;ccc&quot;],
]);
</code></pre>
<h4 id="3-3-Map-常见属性和方法"><a href="#3-3-Map-常见属性和方法" class="headerlink" title="3-3 Map 常见属性和方法"></a>3-3 Map 常见属性和方法</h4><p>属性:</p>
<ul>
<li>size 属性 Map 结构有多少元素</li>
</ul>
<p>方法:</p>
<ul>
<li>set()方法 用于给 Map 结构添加元素</li>
<li>get()方法 get(key) 传入 key 值获取属性值</li>
<li>has() 判断某一个 key 是否存在</li>
<li>delete() 删除某一个元素 返回布尔值</li>
<li>clear() 清除 Map 结构</li>
</ul>
<p>遍历 Map：</p>
<ul>
<li><p>foreach 来遍历</p>
<p>map.forEach()</p>
</li>
<li><p>for of 遍历</p>
<p>for（const item of map2){</p>
<p>​ 这里边 item 是个数组</p>
<p>}</p>
<p>可以使用解构</p>
<p>for（const[key, valeu] of map2）{</p>
<p>​</p>
<p>}</p>
</li>
</ul>
<h3 id="4-Weakmap"><a href="#4-Weakmap" class="headerlink" title="4. Weakmap"></a>4. Weakmap</h3><p><strong>WeakMap 不能进行遍历</strong></p>
<h4 id="4-1-WeakMap-是什么"><a href="#4-1-WeakMap-是什么" class="headerlink" title="4-1 WeakMap 是什么"></a>4-1 WeakMap 是什么</h4><ul>
<li>和 Map 类型相似的另一哥数据结构称之为 WeakMap，也是以键值对的形式存在</li>
</ul>
<h4 id="4-2-和-Map-的区别"><a href="#4-2-和-Map-的区别" class="headerlink" title="4-2 和 Map 的区别"></a>4-2 和 Map 的区别</h4><ul>
<li>key 只能是对象不能设置基本数据类型</li>
<li>WeakMap 里的对象的引用是弱引用</li>
</ul>
<h4 id="4-3-WeakMap-常见方法"><a href="#4-3-WeakMap-常见方法" class="headerlink" title="4-3 WeakMap 常见方法"></a>4-3 WeakMap 常见方法</h4><ul>
<li>get()方法 get(key) 传入 key 值获取属性值</li>
<li>has() 判断某一个 key 是否存在</li>
<li>delete() 删除某一个元素 返回布尔值</li>
</ul>
<h4 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4-4 应用场景"></a>4-4 应用场景</h4><p>Vue3 中的响应式原理</p>
<h3 id="5-ES7-Array-Includes"><a href="#5-ES7-Array-Includes" class="headerlink" title="5. ES7 -Array Includes"></a>5. ES7 -Array Includes</h3><p>判断数组中是否包含某个元素 返回值是布尔值</p>
<p>可以判断数组是否存在 NaN 元素</p>
<p>arr.includes(元素，元素所在的位置)</p>
<pre><code class="js">const arr = [12, 45, 6];
arr.includes(12);
</code></pre>
<h3 id="6-ES7-指数运算符"><a href="#6-ES7-指数运算符" class="headerlink" title="6. ES7 - 指数运算符"></a>6. ES7 - 指数运算符</h3><p>const result=3 ** 3 等于 3 的平方</p>
<p>** 指数运算符</p>
<h2 id="第十五节-ES6-ES12（四）"><a href="#第十五节-ES6-ES12（四）" class="headerlink" title="第十五节 ES6-ES12（四）"></a>第十五节 ES6-ES12（四）</h2><p>node 版本低会导致不支持某些语法运行</p>
<h3 id="1-ES8-Object-values"><a href="#1-ES8-Object-values" class="headerlink" title="1. ES8- Object.values()"></a>1. ES8- Object.values()</h3><p>获取所有的 value 值</p>
<p>Object.keys()获取所有的 key 值</p>
<h3 id="2-ES8-Object-entries"><a href="#2-ES8-Object-entries" class="headerlink" title="2. ES8 - Object.entries"></a>2. ES8 - Object.entries</h3><p>通过 Object.entries()可以获取到一个数组，数组中会存放可枚举属性的键值对数组。</p>
<h3 id="3-ES8-String-Padding-字符串填充"><a href="#3-ES8-String-Padding-字符串填充" class="headerlink" title="3. ES8 - String Padding 字符串填充"></a>3. ES8 - String Padding 字符串填充</h3><ul>
<li><p>从字符串前边填充 padStart（第一个参数代表填充完字符串的长度，第二个参数填充的内容）</p>
<pre><code class="js">const mess = &quot;hello world&quot;;
mess.padStart();
</code></pre>
</li>
<li><p>从字符串末尾填充 padEnd（第一个参数代表填充完字符串的长度，第二个参数填充的内容）</p>
<pre><code class="js">const mess = &quot;hello world&quot;;
mess.padEnd();
</code></pre>
</li>
</ul>
<h3 id="4-ES8-Object-Descriptors"><a href="#4-ES8-Object-Descriptors" class="headerlink" title="4. ES8 - Object Descriptors"></a>4. ES8 - Object Descriptors</h3><ul>
<li>Object.getOwnPropertyDescriptors 获取对象所有的属性描述符</li>
</ul>
<h3 id="5-ES10-flat-flatMap"><a href="#5-ES10-flat-flatMap" class="headerlink" title="5. ES10 - flat flatMap"></a>5. ES10 - flat flatMap</h3><ul>
<li><p>flat（） 将数组进行降维 比如数组里有二维数组会降成一维 参数是降为的次数</p>
<pre><code class="js">const arr = [10, 2, [5, 5], [[3, 5], [68]], 99];
const nar = arr.flat(1); //降维一次
const nsarr = arr.flat(2); //降维两次
</code></pre>
</li>
<li><p>flatMap（）方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组</p>
<p>注意：1.flatMap 先进行 map 操作，在做 flat 操作</p>
<p>​ 2.flatMap 中的 flat 相当于深度为 1</p>
<pre><code class="js">const num = [10, 20, 30];
num.flatMap((item) =&gt; &#123;
  return item * 2;
&#125;);
</code></pre>
</li>
</ul>
<h3 id="6-ES10-Object-fromEntries"><a href="#6-ES10-Object-fromEntries" class="headerlink" title="6. ES10 - Object.fromEntries"></a>6. ES10 - Object.fromEntries</h3><p>将 entries 格式的转为对象</p>
<pre><code class="js">const entries = &#123;name：&#39;why&#39;&#125;
const n=Object.entries(entries);
const z=Object.fromEntries(n)
</code></pre>
<h3 id="7-ES10-trimStart-trimEnd"><a href="#7-ES10-trimStart-trimEnd" class="headerlink" title="7. ES10 - trimStart trimEnd"></a>7. ES10 - trimStart trimEnd</h3><ul>
<li>trimStart（） 去除首部空格</li>
<li>trimEnd（）去除尾部空格</li>
</ul>
<h3 id="8-ES11-BigInt"><a href="#8-ES11-BigInt" class="headerlink" title="8. ES11 - BigInt"></a>8. ES11 - BigInt</h3><p>BigInt 基本数据类型 大的整数</p>
<p>ES11 之前 JS 中不能正确的表示过大的数字</p>
<pre><code class="js">BigInt(要转成大整数的数字);
const bigInt = 90071992547099100n; //加上这个n就是BigInt类型
//BigInt类型相加必须是同类型
</code></pre>
<h3 id="9-ES11-Nullish-Coalescing-operator"><a href="#9-ES11-Nullish-Coalescing-operator" class="headerlink" title="9. ES11 - Nullish-Coalescing-operator"></a>9. ES11 - Nullish-Coalescing-operator</h3><p>空值合并运算符： ？？</p>
<pre><code class="js">const foo=undefined；
const bar=foo？？&quot;defualt value&quot;
当foo的值为null或undefined才有效 bar为default value
</code></pre>
<h3 id="10-ES11-Optional-Chaining"><a href="#10-ES11-Optional-Chaining" class="headerlink" title="10. ES11 - Optional Chaining"></a>10. ES11 - Optional Chaining</h3><p>可选链：让我们代码在进行 null 和 undefined 进行判断的时候更简洁</p>
<p>语法：？. 如果调用的值为 undefined 就直接返回 undefined</p>
<h3 id="11-ES11-globalThis"><a href="#11-ES11-globalThis" class="headerlink" title="11. ES11- globalThis"></a>11. ES11- globalThis</h3><p>获取某一个环境下的全局对象：globalThis</p>
<h3 id="12-ES12-FinalizationRegistry-类"><a href="#12-ES12-FinalizationRegistry-类" class="headerlink" title="12. ES12 - FinalizationRegistry 类"></a>12. ES12 - FinalizationRegistry 类</h3><p>当被销毁掉是触发某些函数</p>
<p><img src="/2022/021964822/image-20220118181304720.png"></p>
<h3 id="13-ES12-WeakRef-类"><a href="#13-ES12-WeakRef-类" class="headerlink" title="13. ES12 - WeakRef 类"></a>13. ES12 - WeakRef 类</h3><p>如果我们想让对象是弱引用就可以使用 WeakRef 类</p>
<p>new WeakRef(绑定的对象)</p>
<p>通过 deref（）获取原来对象的属性</p>
<p><img src="/2022/021964822/image-20220118183020139.png"></p>
<p><img src="/2022/021964822/image-20220118182831974.png"></p>
<h3 id="14-ES12-logical-assgin-operator-逻辑赋值运算符"><a href="#14-ES12-logical-assgin-operator-逻辑赋值运算符" class="headerlink" title="14. ES12 - logical-assgin-operator 逻辑赋值运算符"></a>14. ES12 - logical-assgin-operator 逻辑赋值运算符</h3><ul>
<li><p>||= 逻辑或赋值运算</p>
<pre><code class="js">let message = undefined;
message ||= &quot;default value&quot;;
</code></pre>
</li>
<li><p>&amp;&amp;=逻辑与赋值运算</p>
<pre><code class="js">let info = &#123;
  name: &quot;why&quot;,
&#125;;
info &amp;&amp;= info.name;
</code></pre>
</li>
<li><p>??= 逻辑空赋值运算</p>
<pre><code class="js">let message = &quot;&quot;;
//如果message为空 就赋值为default value
message ??= &quot;default value&quot;;
</code></pre>
</li>
</ul>
<h3 id="15-String-replaceAll-字符串替换"><a href="#15-String-replaceAll-字符串替换" class="headerlink" title="15. String.replaceAll 字符串替换"></a>15. String.replaceAll 字符串替换</h3><h2 id="第十六节-Proxy-Reflect-Vue2-vue3-的响应式原理"><a href="#第十六节-Proxy-Reflect-Vue2-vue3-的响应式原理" class="headerlink" title="第十六节 Proxy Reflect Vue2-vue3 的响应式原理"></a>第十六节 Proxy Reflect Vue2-vue3 的响应式原理</h2><h3 id="1-Proxy-代理"><a href="#1-Proxy-代理" class="headerlink" title="1. Proxy 代理"></a>1. Proxy 代理</h3><h4 id="1-1-proxy-的使用"><a href="#1-1-proxy-的使用" class="headerlink" title="1-1 proxy 的使用"></a>1-1 proxy 的使用</h4><p>Proxy 是一个类</p>
<p>new Proxy(侦听的对象，捕获器{})</p>
<pre><code class="js">const obj=&#123;
    name：&#39;why&#39;,
    age:18
&#125;
const a= new Proxy(obj,&#123;

    get:function(target,key,receiver)&#123;

    &#125;, set:function(target,key,newvalue,reciver)&#123;

    &#125;
&#125;)
</code></pre>
<p><img src="/2022/021964822/image-20220120112811046.png"></p>
<h4 id="1-2-Proxy-的捕获器"><a href="#1-2-Proxy-的捕获器" class="headerlink" title="1-2 Proxy 的捕获器"></a>1-2 Proxy 的捕获器</h4><ul>
<li><p>get 函数：获取值时的捕获器</p>
<ol>
<li>target：目标对象（侦听的对象）</li>
<li>property：被获取的属性 key</li>
<li>reciver：调用的代理对象</li>
</ol>
</li>
<li><p>set 函数：设置值时的捕获器</p>
<ol>
<li>target：目标对象（侦听的对象）</li>
<li>property：被获取的属性 key</li>
<li>value：新属性值</li>
<li>reciver：调用的代理对象</li>
</ol>
</li>
<li><p>has 函数：监听 in 的捕获器</p>
<ol>
<li><p>target：目标对象（侦听的对象）</p>
</li>
<li><p>property：被获取的属性 key</p>
</li>
</ol>
</li>
<li><p>deleteProperty 函数：监听 delete 的捕获器</p>
<ol>
<li><p>target：目标对象（侦听的对象）</p>
</li>
<li><p>property：被获取的属性 key</p>
</li>
</ol>
</li>
</ul>
<h4 id="1-3-Proxy-所有的捕获器"><a href="#1-3-Proxy-所有的捕获器" class="headerlink" title="1-3 Proxy 所有的捕获器"></a>1-3 Proxy 所有的捕获器</h4><p><img src="/2022/021964822/image-20220120114558665.png"></p>
<h4 id="1-4-reciver-参数的作用"><a href="#1-4-reciver-参数的作用" class="headerlink" title="1-4 reciver 参数的作用"></a>1-4 reciver 参数的作用</h4><h3 id="2-Reflect"><a href="#2-Reflect" class="headerlink" title="2. Reflect"></a>2. Reflect</h3><p><strong>注意：使用 Reflect 的方法会返回布尔值</strong></p>
<h4 id="2-1-Reflect-的作用"><a href="#2-1-Reflect-的作用" class="headerlink" title="2-1 Reflect 的作用"></a>2-1 Reflect 的作用</h4><p><strong>它是一个对象，字面意思是反射</strong></p>
<ul>
<li>提供了很多操作 JS 对象的方法，有点像 Object 中操作对象的方法</li>
<li>比如 Reflect.getPrototypeOf（target）类似于 Object.getPrototypeOf（）</li>
</ul>
<h4 id="2-2-为什么要有-Reflect"><a href="#2-2-为什么要有-Reflect" class="headerlink" title="2-2 为什么要有 Reflect"></a>2-2 为什么要有 Reflect</h4><ul>
<li>早起 ESMA 规范没有考虑到对对象本身的操作如何设计会更加规范，所以将这些 API 放到 Object 上</li>
<li>但是 Object 作为一个构造函数这些操作放在上边不合适</li>
<li>所以新增 Reflect ，让我们把这些操作集中到 Reflect 对象上</li>
</ul>
<h4 id="2-3-Reflect-常见方法"><a href="#2-3-Reflect-常见方法" class="headerlink" title="2-3 Reflect 常见方法"></a>2-3 Reflect 常见方法</h4><p><img src="/2022/021964822/image-20220120120124697.png"></p>
<h4 id="2-4-Reflect-结合-Proxy-的使用"><a href="#2-4-Reflect-结合-Proxy-的使用" class="headerlink" title="2-4 Reflect 结合 Proxy 的使用"></a>2-4 Reflect 结合 Proxy 的使用</h4><pre><code class="js">const obj = &#123;
  name: &quot;why&quot;,
  age: 18,
&#125;;
const objProxy = new Proxy(obj, &#123;
  get: function (target, key, recevier) &#123;
    return Reflect.get(target, key);
  &#125;,
  set: function (target, key, newValue, receiver) &#123;
    Reflect.set(target, key, newValue);
  &#125;,
&#125;);
</code></pre>
<h3 id="3-响应式原理（学完-vue-自己在重新过来看视频-17-节-）"><a href="#3-响应式原理（学完-vue-自己在重新过来看视频-17-节-）" class="headerlink" title="3. 响应式原理（学完 vue 自己在重新过来看视频 17 节 ）"></a>3. 响应式原理（学完 vue 自己在重新过来看视频 17 节 ）</h3><p>当我们的变量发生改变时自动重新执行代码。</p>
<h2 id="第十七节-Promise"><a href="#第十七节-Promise" class="headerlink" title="第十七节 Promise"></a>第十七节 Promise</h2><h3 id="1-Promise-是什么"><a href="#1-Promise-是什么" class="headerlink" title="1. Promise 是什么"></a>1. Promise 是什么</h3><ul>
<li>是一个类。</li>
<li>需要给调用者一个承诺：待会给你回调数据时，就可以创建一个 Promise 的对象</li>
<li>通过 new 创建 Promise 对象</li>
</ul>
<h3 id="2-Promise-的使用"><a href="#2-Promise-的使用" class="headerlink" title="2. Promise 的使用"></a>2. Promise 的使用</h3><pre><code class="js">//Promise（（）=》&#123;&#125;）里的这个函数会在调用时自动执行
//resolve ：成功时调用
//reject：失败时调用
const npromise = new Promise((resolve, reject) =&gt; &#123;
  resolve();
  reject();
&#125;);
//成功时的回调
npromise.then(() =&gt; &#123;&#125;);
//失败时的回调
npromise.catch(() =&gt; &#123;&#125;);
</code></pre>
<p><img src="/2022/021964822/image-20220125171001785.png"></p>
<h3 id="3-Promise-中的状态"><a href="#3-Promise-中的状态" class="headerlink" title="3. Promise 中的状态"></a>3. Promise 中的状态</h3><p><img src="/2022/021964822/image-20220125173338143.png"></p>
<p><strong>状态一旦确定就不可更改！！！</strong></p>
<h3 id="4-Promise-的-resolve-参数"><a href="#4-Promise-的-resolve-参数" class="headerlink" title="4. Promise 的 resolve 参数"></a>4. Promise 的 resolve 参数</h3><h4 id="4-1-reslove-参数传入普通值或对象"><a href="#4-1-reslove-参数传入普通值或对象" class="headerlink" title="4-1 reslove 参数传入普通值或对象"></a>4-1 reslove 参数传入普通值或对象</h4><p>Pending 状态–》fuifilled</p>
<h4 id="4-2-reslove-参数传入一个-Promise"><a href="#4-2-reslove-参数传入一个-Promise" class="headerlink" title="4-2 reslove 参数传入一个 Promise"></a>4-2 reslove 参数传入一个 Promise</h4><p>那么当前的 Promise 状态会由传入的 Promise 来决定，相当于状态进行了移交</p>
<pre><code class="js">new Promise((reslove, reject) =&gt; &#123;
  //由这里的promise参数里的状态决定外面
  reslove(新的Promise);
&#125;)
  .then((res) =&gt; &#123;&#125;)
  .catch((err) =&gt; &#123;&#125;);
</code></pre>
<h4 id="4-3-reslove-参数传入一个对象这个对象本身具有-then-方法"><a href="#4-3-reslove-参数传入一个对象这个对象本身具有-then-方法" class="headerlink" title="4-3 reslove 参数传入一个对象这个对象本身具有 then 方法"></a>4-3 reslove 参数传入一个对象这个对象本身具有 then 方法</h4><p>那么也会执行该 then 方法</p>
<h2 id="第十八节-Promise-中-then-以及实现-Promise"><a href="#第十八节-Promise-中-then-以及实现-Promise" class="headerlink" title="第十八节 Promise 中 then 以及实现 Promise"></a>第十八节 Promise 中 then 以及实现 Promise</h2><h3 id="1-Promise-有哪些对象方法"><a href="#1-Promise-有哪些对象方法" class="headerlink" title="1. Promise 有哪些对象方法"></a>1. Promise 有哪些对象方法</h3><ul>
<li>then（）</li>
<li>catch（）</li>
<li>finally（）</li>
</ul>
<h3 id="2-then（）方法"><a href="#2-then（）方法" class="headerlink" title="2. then（）方法"></a>2. then（）方法</h3><ul>
<li><strong>同一个 Promise 可以被多次调用 then 方法</strong></li>
</ul>
<pre><code class="js">promise.then(() =&gt; &#123;&#125;);
promise.then(() =&gt; &#123;&#125;);
promise.then(() =&gt; &#123;&#125;);
</code></pre>
<ul>
<li><p>then 方法传入的回调函数可以有返回值 <strong>它的返回值是 Promise</strong></p>
<ol>
<li><p>如果我们返回的是一个普通值（数字/字符串/对象/undefined），那么这个普通的值被作为一个新的 Promise 的 resolve 值</p>
</li>
<li><p>如果返回的是一个 Promise</p>
<p><img src="/2022/021964822/image-20220125214908799.png"></p>
</li>
<li><p>如果返回的是一个对象 并且该对象实现了 thenable</p>
<p><img src="/2022/021964822/image-20220125215055280.png"></p>
</li>
</ol>
</li>
</ul>
<h3 id="3-catch-方法"><a href="#3-catch-方法" class="headerlink" title="3. catch()方法"></a>3. catch()方法</h3><ul>
<li>当 exxecutor 抛出异常时，也是会调用错误捕获的回调函数的</li>
<li>then 方法有两个参数第二个参数就是错误回调函数</li>
<li>通过 catch 方法传入错误捕获的回调函数</li>
</ul>
<h3 id="4-finally（）方法"><a href="#4-finally（）方法" class="headerlink" title="4. finally（）方法"></a>4. finally（）方法</h3><p>ES9 中增加的</p>
<p><strong>无论 Promise 对象变成 fulfilled 状态 还是 rejected 状态都会执行的代码</strong></p>
<ul>
<li>回调函数没有参数</li>
</ul>
<h3 id="5-Promise-类方法"><a href="#5-Promise-类方法" class="headerlink" title="5. Promise 类方法"></a>5. Promise 类方法</h3><ul>
<li><p>Promise.resolve（） 相当于 const promise2=new Promise（（resolve，reject）=&gt;{resolve({name:”why”})}）</p>
</li>
<li><p>Promise.reject() 方法 直接让 Promise 对象 rejected 状态 <strong>这里无论传入什么值都是一样的</strong></p>
</li>
<li><p>Promise.all([]) 创建多个 Promise 当所有的 Promise 都是 fulfilled 的话执行 reslove 但是有一个为 rreject 的话就都为 rejected</p>
</li>
<li><p>Promise.allSettled([]) 无论是 fulfilled 还是 rejected 时都会有一个结果</p>
</li>
<li><p>Promise.race([]) 只要有一个 promise 编程 fulfilled 状态就结束</p>
</li>
<li><p>Promise.any([]) 至少等到一个状态变成 fulfilled 状态</p>
</li>
</ul>
<h2 id="第十九节-Promise-手写"><a href="#第十九节-Promise-手写" class="headerlink" title="第十九节 Promise 手写"></a>第十九节 Promise 手写</h2><h3 id="简单总结手写-Promise"><a href="#简单总结手写-Promise" class="headerlink" title="简单总结手写 Promise"></a>简单总结手写 Promise</h3><h4 id="一-Promise-规范"><a href="#一-Promise-规范" class="headerlink" title="一. Promise 规范"></a>一. Promise 规范</h4><ul>
<li><a target="_blank" rel="noopener" href="https://promisesaplus.com/">https://promisesaplus.com/</a></li>
</ul>
<h4 id="二-Promise-类设计"><a href="#二-Promise-类设计" class="headerlink" title="二. Promise 类设计"></a>二. Promise 类设计</h4><pre><code class="js">class HYPromise &#123;&#125;
</code></pre>
<pre><code class="js">function HYPromise() &#123;&#125;
</code></pre>
<h4 id="三-构造函数的规划"><a href="#三-构造函数的规划" class="headerlink" title="三. 构造函数的规划"></a>三. 构造函数的规划</h4><pre><code class="js">class HYPromise &#123;

 constructor(*executor*) &#123;

  *// 定义状态*

  *// 定义resolve、reject回调*

  *// resolve执行微任务队列：改变状态、获取value、then传入执行成功回调*

  *// reject执行微任务队列：改变状态、获取reason、then传入执行失败回调*



  *// try catch*

  executor(resolve, reject)

 &#125;

&#125;
</code></pre>
<h4 id="四-then-方法的实现"><a href="#四-then-方法的实现" class="headerlink" title="四. then 方法的实现"></a>四. then 方法的实现</h4><pre><code class="js">class HYPromise &#123;

 then(*onFulfilled*, *onRejected*) &#123;

  *// this.onFulfilled = onFulfilled*

  *// this.onRejected = onRejected*



  *// 1.判断onFulfilled、onRejected，会给默认值*



  *// 2.返回Promise resolve/reject*



  *// 3.判断之前的promise状态是否确定*

  *// onFulfilled/onRejected直接执行（捕获异常）*



  *// 4.添加到数组中push(() =&gt; &#123; 执行 onFulfilled/onRejected 直接执行代码&#125;)*

 &#125;

&#125;
</code></pre>
<h4 id="五-catch-方法"><a href="#五-catch-方法" class="headerlink" title="五. catch 方法"></a>五. catch 方法</h4><pre><code class="js">class HYPromise &#123;

 catch(*onRejected*) &#123;

  return this.then(undefined, onRejected)

 &#125;

&#125;
</code></pre>
<h4 id="六-finally"><a href="#六-finally" class="headerlink" title="六. finally"></a>六. finally</h4><pre><code class="js">class HYPromise &#123;

 finally(*onFinally*) &#123;

  return this.then(() =&gt; &#123;onFinally()&#125;, () =&gt; &#123;onFinally()&#125;)

 &#125;

&#125;
</code></pre>
<h4 id="七-resolve-reject"><a href="#七-resolve-reject" class="headerlink" title="七. resolve/reject"></a>七. resolve/reject</h4><h4 id="八-all-allSettled"><a href="#八-all-allSettled" class="headerlink" title="八. all/allSettled"></a>八. all/allSettled</h4><p>核心：要知道 new Promise 的 resolve、reject 在什么情况下执行</p>
<p>all：</p>
<ul>
<li><p>情况一：所有的都有结果</p>
</li>
<li><p>情况二：有一个 reject</p>
</li>
</ul>
<p>allSettled：</p>
<ul>
<li>情况：所有都有结果，并且一定执行 resolve</li>
</ul>
<h4 id="九-race-any"><a href="#九-race-any" class="headerlink" title="九.race/any"></a>九.race/any</h4><p>race:</p>
<ul>
<li>情况：只要有结果</li>
</ul>
<p>any:</p>
<ul>
<li><p>情况一：必须等到一个 resolve 结果</p>
</li>
<li><p>情况二：都没有 resolve，所有的都是 reject</p>
</li>
</ul>
<h2 id="第二十节-iterator-迭代器-generator-生成器"><a href="#第二十节-iterator-迭代器-generator-生成器" class="headerlink" title="第二十节 iterator 迭代器 generator 生成器"></a>第二十节 iterator 迭代器 generator 生成器</h2><h3 id="1-迭代器-iterator"><a href="#1-迭代器-iterator" class="headerlink" title="1.迭代器 iterator"></a>1.迭代器 iterator</h3><p><strong>JS 中迭代器是一个具体的对象，这个对象需要符合迭代器协议</strong></p>
<p><strong>迭代器是帮助我们对某个数据结构进行遍历的对象</strong></p>
<h4 id="1-1-迭代器协议-（iterator-protocaol）"><a href="#1-1-迭代器协议-（iterator-protocaol）" class="headerlink" title="1-1 迭代器协议 （iterator protocaol）"></a>1-1 迭代器协议 （iterator protocaol）</h4><ul>
<li><p>要有一个 next 方法无参数函数或者一个参数 返回一个对象</p>
</li>
<li><p>返回的对象 中具有 done：boolean 属性和 value</p>
</li>
</ul>
<h4 id="1-2-可迭代对象"><a href="#1-2-可迭代对象" class="headerlink" title="1-2 可迭代对象"></a>1-2 可迭代对象</h4><ul>
<li>当一个对象实现了 iterable protocol 协议时它就是可迭代对象</li>
</ul>
<h4 id="1-3-内置可迭代对象"><a href="#1-3-内置可迭代对象" class="headerlink" title="1-3 内置可迭代对象"></a>1-3 内置可迭代对象</h4><ul>
<li>数组</li>
<li>函数中的 arguments</li>
<li>set/map</li>
<li>String</li>
<li>NodeList 集合 拿到的 dom 元素</li>
</ul>
<h4 id="1-4-可迭代对象的应用场景"><a href="#1-4-可迭代对象的应用场景" class="headerlink" title="1-4 可迭代对象的应用场景"></a>1-4 可迭代对象的应用场景</h4><p><img src="/2022/021964822/image-20220203200507257.png"></p>
<h4 id="1-5-迭代器的中断"><a href="#1-5-迭代器的中断" class="headerlink" title="1-5 迭代器的中断"></a>1-5 迭代器的中断</h4><p><img src="/2022/021964822/image-20220203212906534.png"></p>
<h3 id="2-生成器-generator"><a href="#2-生成器-generator" class="headerlink" title="2. 生成器 generator"></a>2. 生成器 generator</h3><h4 id="2-1-什么是生成器"><a href="#2-1-什么是生成器" class="headerlink" title="2-1 什么是生成器"></a>2-1 什么是生成器</h4><ul>
<li>生成器是 ES6 中新增的一种<strong>函数控制、使用</strong>的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。</li>
</ul>
<h4 id="2-2-生成器函数"><a href="#2-2-生成器函数" class="headerlink" title="2-2 生成器函数"></a>2-2 生成器函数</h4><ul>
<li>生成器函数也是一个函数</li>
<li>需要在 function 后面加个*</li>
<li>生成器函数可以通过 yield 关键字来控制函数的执行流程在哪里要停掉就加 yield</li>
<li>生成器函数返回值是一个生成器 Generator 对象</li>
<li>要返回的值在 yield 后面跟上值就可以返回</li>
</ul>
<h4 id="2-3-生成器的其他方法使用"><a href="#2-3-生成器的其他方法使用" class="headerlink" title="2-3 生成器的其他方法使用"></a>2-3 生成器的其他方法使用</h4><ul>
<li><p>生成器上的 next（）可以传递参数 但是要在前一段的 yield 接收参数</p>
<p><img src="/2022/021964822/image-20220203215905754.png"></p>
</li>
<li><p>生成器的 return 方法 return（） 终止方法</p>
<p><img src="/2022/021964822/image-20220203220421536.png"></p>
</li>
<li><p>生成器抛出异常 throw（）方法抛出异常</p>
<p><img src="/2022/021964822/image-20220205102053916.png"></p>
</li>
</ul>
<h2 id="第二十一节-asnyc-await"><a href="#第二十一节-asnyc-await" class="headerlink" title="第二十一节 asnyc await"></a>第二十一节 asnyc await</h2><h3 id="1-生成器代替迭代器"><a href="#1-生成器代替迭代器" class="headerlink" title="1. 生成器代替迭代器"></a>1. 生成器代替迭代器</h3><h4 id="1-1-第一种写法"><a href="#1-1-第一种写法" class="headerlink" title="1-1 第一种写法"></a>1-1 第一种写法</h4><p><img src="/2022/021964822/image-20220205102544952.png"></p>
<h4 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1-2 第二种写法"></a>1-2 第二种写法</h4><p>yield* 可迭代对象</p>
<p><img src="/2022/021964822/image-20220205102829211.png"></p>
<h3 id="2-异步代码处理方案"><a href="#2-异步代码处理方案" class="headerlink" title="2. 异步代码处理方案"></a>2. 异步代码处理方案</h3><pre><code class="js">function requestData(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      resolve(url);
    &#125;, 2000);
  &#125;);
&#125;

// 第一种方案  回调地域  多次回调
// requestData(&#39;nhn&#39;).then((res) =&gt; &#123;
//     console.log(res);
//     requestData(res + &#39;aaa&#39;).then((res) =&gt; &#123;
//         console.log(res);
//         requestData(res + &#39;bbb&#39;).then((res) =&gt; &#123;
//             console.log(res);
//         &#125;)
//     &#125;)
// &#125;)

// 第二种方案   Promise的then 的返回值解决
// requestData(&#39;nhn&#39;).then((res) =&gt; &#123;
//     return requestData(res + &#39;aaa&#39;)
// &#125;).then((res) =&gt; &#123;
//     return requestData(res + &#39;bbb&#39;)
// &#125;).then((res) =&gt; &#123;
//     console.log(res);
// &#125;)

// 第三种方案  Promise 和generator 解决
// function* getData() &#123;
//     const res1 = yield requestData(&#39;why&#39;)
//     const res2 = yield requestData(res1 + &#39;aaa&#39;)
//     const res3 = yield requestData(res2 + &#39;bbb&#39;)
//     console.log(res3);
// &#125;

// const generator = getData()
// generator.next().value.then(res =&gt; &#123;
//     generator.next(res).value.then(res =&gt; &#123;
//         generator.next(res).value.then(res =&gt; &#123;
//             generator.next(res)
//         &#125;)
//     &#125;)
// &#125;)

// 自动化递归调用getdata
// npm上有一个函数包  co
// function execgenerator(fn) &#123;
//     const generator = fn();

//     function exec(res) &#123;
//         const result = generator.next(res);
//         if (result.done) return result.value

//         result.value.then(res =&gt; &#123;
//             exec(res);
//         &#125;)
//     &#125;
//     exec()
// &#125;
// execgenerator(getData)

// 第四种 方案  async/await
async function getData() &#123;
  const res1 = await requestData(&quot;why&quot;);
  const res2 = await requestData(res1 + &quot;aaa&quot;);
  const res3 = await requestData(res2 + &quot;bbb&quot;);
  console.log(res3);
&#125;
getData();
</code></pre>
<h3 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3. async/await"></a>3. async/await</h3><h4 id="3-1-async-异步函数"><a href="#3-1-async-异步函数" class="headerlink" title="3-1 async 异步函数"></a>3-1 async 异步函数</h4><ul>
<li>声明某个函数是异步的</li>
<li>异步函数的返回值一定是个 Promise</li>
<li>当 async 函数 return 一个具体值得时候 返回的 Promise 会执行 then（）</li>
<li>执行异步函数和普通函数没有区别如果里面没有做 await 操作的话</li>
<li>普通函数中抛出异常代码不会继续执行 异步函数中抛出异常可以用 catch 捕获</li>
</ul>
<h4 id="3-2-await-关键字"><a href="#3-2-await-关键字" class="headerlink" title="3-2 await 关键字"></a>3-2 await 关键字</h4><ul>
<li>只有 async 函数中才可以使用 await 关键字 普通函数不可以</li>
<li>一般情况下 await 后边跟一个表达式 表达式的返回值是 Promise</li>
<li>await 的返回值 是返回的 Promise 中 resolve 的结果</li>
<li>await 后边代码相当于 then（）里</li>
<li>await 跟上普通值会立即返回这个值</li>
<li>当 await 后边的表达式返回的是 reject 时 后边的代码不会执行了 会将 reject 值作为整个异步函数的 reject 值</li>
</ul>
<h3 id="4-事件循环"><a href="#4-事件循环" class="headerlink" title="4. 事件循环"></a>4. 事件循环</h3><h4 id="4-1-进程和线程"><a href="#4-1-进程和线程" class="headerlink" title="4-1 进程和线程"></a>4-1 进程和线程</h4><ul>
<li>进程：启动一个应用程序 就会启动一个进程也可能是多个进程</li>
<li>线程：每一个进程中都会启动至少一个线程来执行程序中的代码，这个线程被称之为主线程。</li>
</ul>
<p><strong>我们也可以说进程是线程的容器</strong></p>
<h4 id="4-2-浏览器中的-js-线程"><a href="#4-2-浏览器中的-js-线程" class="headerlink" title="4-2 浏览器中的 js 线程"></a>4-2 浏览器中的 js 线程</h4><p><img src="/2022/021964822/image-20220206144017746.png"></p>
<h2 id="第二十二节-事件循环-try-catch-throw"><a href="#第二十二节-事件循环-try-catch-throw" class="headerlink" title="第二十二节 事件循环 try/catch throw"></a>第二十二节 事件循环 try/catch throw</h2><h3 id="1-浏览器的事件循环"><a href="#1-浏览器的事件循环" class="headerlink" title="1. 浏览器的事件循环"></a>1. 浏览器的事件循环</h3><p><img src="/2022/021964822/image-20220206172334549.png"></p>
<ul>
<li>事件队列先进先出</li>
</ul>
<p>**事件循环就是 JS 引擎执行代码过程中遇到异步代码时会用浏览器其他线程执行然后推入事件队列 JS 引擎再去事件队列中查找事件执行这个不断重复的过程就就是事件循环 **</p>
<h3 id="2-宏任务和微任务"><a href="#2-宏任务和微任务" class="headerlink" title="2. 宏任务和微任务"></a>2. 宏任务和微任务</h3><p>事件队列划分为：</p>
<ul>
<li><p>宏任务队列 macrotask queue</p>
<p>ajax , setTimeout , setInterval , DOM 监听 ， UI Rendering 等</p>
</li>
<li><p>微任务队列 microtask queque</p>
<p>Promise 的 then 回调 ， Mutation Observer API ， queueMicrotask（）等</p>
</li>
</ul>
<p><strong>规范： 在执行任何宏任务之前都需要先保证微任务队列被清空</strong></p>
<h3 id="3-事件循环的优先级"><a href="#3-事件循环的优先级" class="headerlink" title="3. 事件循环的优先级"></a>3. 事件循环的优先级</h3><ol>
<li>main script 代码</li>
<li>优先微任务队列</li>
<li>微任务队列清空之后执行宏任务队列</li>
</ol>
<h3 id="4-node-的事件循环"><a href="#4-node-的事件循环" class="headerlink" title="4. node 的事件循环"></a>4. node 的事件循环</h3><p><img src="/2022/021964822/image-20220207162836939.png"></p>
<h4 id="4-1-node-事件循环的阶段"><a href="#4-1-node-事件循环的阶段" class="headerlink" title="4-1 node 事件循环的阶段"></a>4-1 node 事件循环的阶段</h4><p><strong>事件循环像一个桥梁 连接着应用程序的 js 和系统调用之间的通道</strong></p>
<p><img src="/2022/021964822/image-20220207163721835.png"></p>
<h4 id="4-2-node-事件循环的微任务-宏任务"><a href="#4-2-node-事件循环的微任务-宏任务" class="headerlink" title="4-2 node 事件循环的微任务/宏任务"></a>4-2 node 事件循环的微任务/宏任务</h4><ul>
<li><p>宏任务</p>
<p>setTimeout ， setInterval ， IO 事件 ， setImmediate ， close 事件</p>
</li>
<li><p>微任务</p>
<p>Promise 的 then 回调 ， process.nextTick ， queueMicrotask</p>
</li>
</ul>
<h2 id="第二十三节-JS-模块化"><a href="#第二十三节-JS-模块化" class="headerlink" title="第二十三节 JS 模块化"></a>第二十三节 JS 模块化</h2><h3 id="1-错误处理方案"><a href="#1-错误处理方案" class="headerlink" title="1. 错误处理方案"></a>1. 错误处理方案</h3><ul>
<li>throw 语句 抛出用户自定义的异常 throw 后边的语句不会执行</li>
</ul>
<h3 id="2-抛出异常的其他补充"><a href="#2-抛出异常的其他补充" class="headerlink" title="2. 抛出异常的其他补充"></a>2. 抛出异常的其他补充</h3><ul>
<li>throw ‘抛出基本数据类型’</li>
<li>throw {比较常见的是抛出一个对象类型}</li>
<li>创建类并且创建这个类应对的对象</li>
<li>js 提供了一个 Error throw new Error（错误信息） 开发中常用的抛出错误信息方法</li>
</ul>
<h3 id="3-对抛出异常进行处理"><a href="#3-对抛出异常进行处理" class="headerlink" title="3. 对抛出异常进行处理"></a>3. 对抛出异常进行处理</h3><ul>
<li>对抛出的异常不做处理 异常会进一步的抛出直到最顶层的调用 如果在最顶层也没有处理那么程序就会终止执行并且报错</li>
<li>使用 try catch 来捕获异常</li>
</ul>
<h3 id="4-什么是模块化"><a href="#4-什么是模块化" class="headerlink" title="4. 什么是模块化"></a>4. 什么是模块化</h3><p><img src="/2022/021964822/image-20220208153705931.png"></p>
<h3 id="5-CommonJS-规范"><a href="#5-CommonJS-规范" class="headerlink" title="5. CommonJS 规范"></a>5. CommonJS 规范</h3><p><img src="/2022/021964822/image-20220208201042091.png"></p>
<h4 id="5-2-导出方案"><a href="#5-2-导出方案" class="headerlink" title="5-2 导出方案"></a>5-2 导出方案</h4><ol>
<li><p>方案一 module.exports</p>
<pre><code class="js">//导出 导出的是一个对象
module.exports&#123;
    name，
    age
&#125;
//导入
requrie（&#39;文件名&#39;）
</code></pre>
</li>
<li><p>方案二 exprots</p>
<pre><code class="js">// exports=moule.exports
exports.name = name;
exprots.age = age;
exports.sum = sum;
</code></pre>
</li>
</ol>
<h2 id="第二十四节-模块化二"><a href="#第二十四节-模块化二" class="headerlink" title="第二十四节 模块化二"></a>第二十四节 模块化二</h2><h3 id="1-require-细节"><a href="#1-require-细节" class="headerlink" title="1. require 细节"></a>1. require 细节</h3><p>require 是一个函数可以帮助我们引入另一个文件中导出的对象</p>
<ul>
<li><p>直接引用模块 require（模块名）</p>
</li>
<li><p>require（‘路径’）</p>
<p><img src="/2022/021964822/image-20220210135547465.png"></p>
</li>
<li><p>require(既不是路径 也不是核心模块)</p>
</li>
</ul>
<p><img src="/2022/021964822/image-20220210140223979.png"></p>
<h3 id="2-模块的加载过程"><a href="#2-模块的加载过程" class="headerlink" title="2. 模块的加载过程"></a>2. 模块的加载过程</h3><p><img src="/2022/021964822/image-20220210140958784.png"></p>
<h3 id="3-CommonJS-规范的缺点"><a href="#3-CommonJS-规范的缺点" class="headerlink" title="3. CommonJS 规范的缺点"></a>3. CommonJS 规范的缺点</h3><ul>
<li>CommonJS 加载模块是同步的：<ul>
<li>同步意味着只有等到对应的模块加载完毕之后，当前模块中的内容才能被运行</li>
<li>这个在服务器中不会有问题，因为服务器加载的 js 文件都是本地文件，加载速度非常快</li>
</ul>
</li>
</ul>
<p><strong>所以在浏览器中通常不适用 CommonJS 规范</strong></p>
<h3 id="4-ES-Module"><a href="#4-ES-Module" class="headerlink" title="4. ES Module"></a>4. ES Module</h3><ul>
<li>export 负责模块的导出</li>
<li>import 负责从其他模块导入内容</li>
</ul>
<h3 id="5-导出的方式"><a href="#5-导出的方式" class="headerlink" title="5. 导出的方式"></a>5. 导出的方式</h3><ul>
<li><p>export 跟上声明语句</p>
<pre><code class="js">export const name = &quot;why&quot;;
export const age = 18;
export function foo() &#123;
  console.log(&quot;foo function&quot;);
&#125;
export class Person &#123;&#125;
</code></pre>
</li>
<li><p>export 导出和声明分开</p>
<pre><code class="js">const name = &quot;why&quot;;
const age = 18;
function foo() &#123;
  console.log(&quot;foo function&quot;);
&#125;

export &#123; name, age, foo &#125;;
</code></pre>
</li>
<li><p>导出时起别名</p>
<pre><code class="js">export &#123; name as FName, age as Fage, foo as Ffoo &#125;;
</code></pre>
</li>
</ul>
<h3 id="6-导入的方式"><a href="#6-导入的方式" class="headerlink" title="6. 导入的方式"></a>6. 导入的方式</h3><ul>
<li><p>普通的导入 improt { } from ‘ ‘</p>
<pre><code class="js">import &#123; name, age, foo &#125; from &quot;./foo.js&quot;;
</code></pre>
</li>
<li><p>起别名</p>
<pre><code class="js">import &#123; name as FName, age as Fage, foo as Ffoo &#125; from &quot;./foo.js&quot;;
</code></pre>
</li>
<li><p>将导出的所有内容放到一个标识符中</p>
<pre><code class="js">import * as foo from &quot;./foo.js&quot;;
</code></pre>
</li>
</ul>
<h3 id="7-ESModule-结合使用"><a href="#7-ESModule-结合使用" class="headerlink" title="7. ESModule 结合使用"></a>7. ESModule 结合使用</h3><ul>
<li><p>导出方式一：通过创建一个 index.js 先来接收所有要导出的模块 最后把 index.js 中的全部导出去</p>
<pre><code class="js">import &#123; add, sub &#125; from &quot;./math.js&quot;;
import &#123; timeFormat, priceFormat &#125; from &quot;./format.js&quot;;
export &#123; add, sub, timeFormat, priceFormat &#125;;
</code></pre>
</li>
<li><p>导出方式二： 直接用 export 导出</p>
<pre><code class="js">export &#123; add, sub &#125; from &quot;./math.js&quot;;
export &#123; timeFormat, priceFormat &#125; from &quot;./format.js&quot;;
</code></pre>
</li>
<li><p>导出方式三： 利用*号</p>
<pre><code class="js">export * from &quot;./math.js&quot;;
export * from &quot;./format.js&quot;;
</code></pre>
</li>
</ul>
<h3 id="8-Default-用法"><a href="#8-Default-用法" class="headerlink" title="8. Default 用法"></a>8. Default 用法</h3><p><strong>默认导出只能有一个</strong></p>
<pre><code class="js">const name=&#39;why&#39;
const age=18
const foo =&quot;foo value&quot;
//第一种写法
export &#123;
    name,
    age,
    foo as default  //写上default的时候就会变成默认导出
&#125;
//第二种写法  用的非常多
export default foo

import sahdj from &#39;./whnh.js&#39;  //随便添写 东西都会默认导入
</code></pre>
<h3 id="9-import-函数"><a href="#9-import-函数" class="headerlink" title="9. import 函数"></a>9. import 函数</h3><p><strong>import { xxx} from ‘./sdasd’ 在执行完这行代码之前 下面的代码不能执行</strong></p>
<p>但是 import 函数可以解决这个问题</p>
<pre><code class="js">//import函数返回的是Promise
import(&quot;./foo.js&quot;).then((res) =&gt; &#123;
  console.log(res.name);
&#125;);
</code></pre>
<h2 id="第二十五节-包管理工具"><a href="#第二十五节-包管理工具" class="headerlink" title="第二十五节 包管理工具"></a>第二十五节 包管理工具</h2><h3 id="1-ESModule-的解析流程"><a href="#1-ESModule-的解析流程" class="headerlink" title="1. ESModule 的解析流程"></a>1. ESModule 的解析流程</h3><p><img src="/2022/021964822/image-20220210202208463.png"></p>
<h3 id="2-ESmodule-和-commonJS-相互引用"><a href="#2-ESmodule-和-commonJS-相互引用" class="headerlink" title="2. ESmodule 和 commonJS 相互引用"></a>2. ESmodule 和 commonJS 相互引用</h3><p><strong>webpack 环境下可以相互引用</strong></p>
<h3 id="3-npm"><a href="#3-npm" class="headerlink" title="3. npm"></a>3. npm</h3><ul>
<li>包管理工具</li>
<li>前端项目中使用来管理依赖的包</li>
</ul>
<h4 id="3-1-查看搜索某个包"><a href="#3-1-查看搜索某个包" class="headerlink" title="3-1 查看搜索某个包"></a>3-1 查看搜索某个包</h4><p><a target="_blank" rel="noopener" href="https://www.npmjs.org/">https://www.npmjs.org</a></p>
<h4 id="3-2-package-json-来记录项目的依赖"><a href="#3-2-package-json-来记录项目的依赖" class="headerlink" title="3-2 package.json 来记录项目的依赖"></a>3-2 package.json 来记录项目的依赖</h4><p>怎么得到配置文件</p>
<ul>
<li>手动 npm init</li>
<li>利用脚手架创建项目就会有 package.json</li>
</ul>
<h4 id="3-3-package-json-的常见属性"><a href="#3-3-package-json-的常见属性" class="headerlink" title="3-3 package.json 的常见属性"></a>3-3 package.json 的常见属性</h4><p>必填属性是：name，version</p>
<ul>
<li>name 是项目名称</li>
<li>version 是当前项目版本号</li>
<li>escription 是描述信息，很多时候作为项目的基本描述；</li>
<li>author 是作者相关信息</li>
<li>license 是开源协议</li>
</ul>
<p><strong>private 属性记录项目是否为私有 当设置为 true 时无法发布到 npm</strong></p>
<ul>
<li>main 属性 设置程序的入口</li>
<li>scrpts 属性<ul>
<li>用于配置一些脚本命令 以键值对的形式存在</li>
<li>陪之后我们可以通过 npm run 命令的 key 来执行这个命令</li>
<li>npm start 和 npm run start 是等价的 对于常用的 start test stop restart 是可以省略 run 直接通过 npm start 等方式运行</li>
</ul>
</li>
<li>dependencies 属性<ul>
<li>是指定无论开发环境还是生产环境都需要依赖的包</li>
<li>通常我们项目实际开发用到的一些库模块 vue vuex vue-router axios 等</li>
<li>与之对应的是 devDependencies</li>
</ul>
</li>
<li>devDependencies 属性<ul>
<li>一些包在生产环境是不需要的 比如 webpack babel 等</li>
<li>这个时候我们会通过 npm install webpack –save-dev 将它安装到 devDependencies 属性中</li>
</ul>
</li>
<li>peerDependencies 属性<ul>
<li>还有一种项目依赖关系是对等依赖，也就是你依赖一个包，它必须是以另外一个宿主包为前提</li>
<li>比如 element-plus 是依赖与 vue3 antdesign 是依赖于 react react-dom</li>
</ul>
</li>
<li>engines 属性<ul>
<li>用于指定 node 和 npm 的版本号</li>
<li>安装过程中先检查对应的引擎版本 不符合就报错</li>
</ul>
</li>
<li>browserslist 属性<ul>
<li>用于配置打包后的 JavaScript 浏览器的兼容情况</li>
<li>否则我们需要手动的添加 polyfills 来让支持某些语法</li>
<li>也就是说它是为 webpack 等打包工具服务的一个属性</li>
</ul>
</li>
</ul>
<h4 id="3-4-依赖管理版本"><a href="#3-4-依赖管理版本" class="headerlink" title="3-4 依赖管理版本"></a>3-4 依赖管理版本</h4><p><img src="/2022/021964822/image-20220210224013147.png"></p>
<h2 id="第二十六节-包管理工具二"><a href="#第二十六节-包管理工具二" class="headerlink" title="第二十六节 包管理工具二"></a>第二十六节 包管理工具二</h2><h3 id="1-npm-install"><a href="#1-npm-install" class="headerlink" title="1. npm install"></a>1. npm install</h3><ul>
<li>全局安装 global install ： npm install webpack -g 只有工具属性才做全局安装</li>
<li>局部安装 local install ： npm install webpack</li>
</ul>
<h3 id="2-项目安装"><a href="#2-项目安装" class="headerlink" title="2. 项目安装"></a>2. 项目安装</h3><p>项目安装时会在当前目录下生产一个 node_modules 文件夹</p>
<p>局部安装分为 生产依赖 和 开发依赖</p>
<ul>
<li>npm install –save 装到 dependsenies 中</li>
<li>npm instal –D 装到 dev Dependsenies 中</li>
<li>根据 package.json 中的依赖包 npm install</li>
</ul>
<h3 id="3-npm-install-原理"><a href="#3-npm-install-原理" class="headerlink" title="3. npm install 原理"></a>3. npm install 原理</h3><p><img src="/2022/021964822/image-20220211152147508.png"></p>
<h3 id="4-package-lock-json-配置解析"><a href="#4-package-lock-json-配置解析" class="headerlink" title="4. package-lock.json 配置解析"></a>4. package-lock.json 配置解析</h3><p><img src="/2022/021964822/image-20220211154130187.png"></p>
<h3 id="5-npm-其他命令"><a href="#5-npm-其他命令" class="headerlink" title="5. npm 其他命令"></a>5. npm 其他命令</h3><ul>
<li>卸载 依赖 npm uninstall</li>
<li>强制重新 build npm rebuild</li>
<li>清除缓存 npm cache clean</li>
</ul>
<h3 id="6-yarn-工具"><a href="#6-yarn-工具" class="headerlink" title="6. yarn 工具"></a>6. yarn 工具</h3><p>另一个包管理工具 yarn</p>
<ul>
<li>也是一个包管理工具</li>
<li>弥补 npm 的一些缺陷出现</li>
<li>早起 npm 缺陷很多 安装依赖很慢 版本依赖混乱</li>
<li>虽然 npm 现在升级了 还是有很多人喜欢 yarn</li>
</ul>
<p><img src="/2022/021964822/image-20220211155852327.png"></p>
<h3 id="7-cnpm-工具"><a href="#7-cnpm-工具" class="headerlink" title="7. cnpm 工具"></a>7. cnpm 工具</h3><p>由于特殊的原因没法下载 npm 工具包 就需要用 cnpm 下载</p>
<h3 id="8-npx-工具"><a href="#8-npx-工具" class="headerlink" title="8. npx 工具"></a>8. npx 工具</h3><p>npx webpack –version 可以使用局部 webpack</p>
<h3 id="9-发布自己的包"><a href="#9-发布自己的包" class="headerlink" title="9. 发布自己的包"></a>9. 发布自己的包</h3><p>npm publish</p>
<h2 id="第二十七节-JSON-数据存储"><a href="#第二十七节-JSON-数据存储" class="headerlink" title="第二十七节 JSON - 数据存储"></a>第二十七节 JSON - 数据存储</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h3><p>JSON 是一种非常重要的数据格式，不是编程语言，是一种可以再服务端和客户端之间传输的数据格式。</p>
<h3 id="1-1-其他的传输格式"><a href="#1-1-其他的传输格式" class="headerlink" title="1-1 其他的传输格式"></a>1-1 其他的传输格式</h3><ul>
<li>XML：很少有人使用</li>
<li>Protobuf ：越来越多被使用目前在前端使用比较少</li>
</ul>
<h4 id="1-2-JSON-基本语法"><a href="#1-2-JSON-基本语法" class="headerlink" title="1-2 JSON 基本语法"></a>1-2 JSON 基本语法</h4><p><strong>JSON 的顶层支持三种类型的值</strong></p>
<ul>
<li>简单值：数字， 字符串 不支持单引号 ， 布尔类型 ， null</li>
<li>对象值：由 key，value 组成，key 是字符串类型，并且必须添加双引号，值可以使简单值，对象值，数组值；</li>
<li>数组值：数组的值可以是简单值，对象值，数组值</li>
</ul>
<h3 id="2-JSON-序列化"><a href="#2-JSON-序列化" class="headerlink" title="2. JSON 序列化"></a>2. JSON 序列化</h3><ul>
<li><p>JSON.stringify（） 将对象转为 JSON 格式的字符串</p>
<p>第一个参数 是对那个参数进行转化</p>
<p>第二个参数 replacer ：</p>
<ul>
<li>​ 传入数组：设定哪些是需要转换</li>
<li>​ 传入回调函数：</li>
</ul>
<p>第三个参数 space</p>
<ul>
<li>传入数字 ：决定加几个空格</li>
<li>传入字符串 ： 以传入的字符作为缩进</li>
</ul>
</li>
<li><p>JSON.parse（） JSON 格式的字符串转回对象</p>
</li>
</ul>
<h3 id="3-利用-JSON-序列化深拷贝"><a href="#3-利用-JSON-序列化深拷贝" class="headerlink" title="3. 利用 JSON 序列化深拷贝"></a>3. 利用 JSON 序列化深拷贝</h3><pre><code class="js">const obj = JSON.stringify(obj1);
const info = JSON.parse(obj);
</code></pre>
<p>缺点：如果对象中有函数 JSON.stringify 是转化不了的 undefined Symbol 也是会被忽略。</p>
<h3 id="4-Storage"><a href="#4-Storage" class="headerlink" title="4. Storage"></a>4. Storage</h3><ul>
<li>localStorage：本地存储 永久性的存储方法 关掉网页重新打开依然存在</li>
<li>sessionStorage：会话存储 ，提供的是本次会话的存储 关掉会话时 存储的内容会被清除</li>
</ul>
<p>区别：</p>
<ul>
<li>关闭网页后重新打开 local 保留 sessionstorage 会被删除</li>
<li>页面内实现跳转 local 保留 sessionStorage 也会保留</li>
<li>页面外实现跳转 打开新网页 local 会保留 sessionStorage 会被删除</li>
</ul>
<h4 id="4-1-Storage-常见属性方法"><a href="#4-1-Storage-常见属性方法" class="headerlink" title="4-1 Storage 常见属性方法"></a>4-1 Storage 常见属性方法</h4><ol>
<li><p>setItem 存储</p>
<pre><code class="js">localStorage.setItem(&quot;key名&quot;, 属性值);
sessionStorage.setItem(&quot;key名&quot;, 属性值);
</code></pre>
</li>
<li><p>length</p>
<pre><code class="js">localStorage.length;
</code></pre>
</li>
<li><p>key 方法</p>
<pre><code class="js">localStorage.key(下标);
</code></pre>
</li>
<li><p>getItem 获取</p>
<pre><code class="js">localStorage.getItem(&quot;key名&quot;);
</code></pre>
</li>
<li><p>removeItem 删除</p>
<pre><code class="js">localStorage.removeItem(&quot;key名&quot;);
</code></pre>
</li>
<li><p>clear 方法 清空</p>
<pre><code class="js">localStorage.clear();
</code></pre>
</li>
</ol>
<h3 id="5-Storage-工具类的封装"><a href="#5-Storage-工具类的封装" class="headerlink" title="5. Storage 工具类的封装"></a>5. Storage 工具类的封装</h3><pre><code class="js">class HYCache &#123;
  constructor(isLocal = true) &#123;
    this.storage = isLocal ? localStorage : sessionStorage;
  &#125;
  setItem(key, value) &#123;
    if (value) &#123;
      this.storage.setItem(key, JSON.stringify(value));
    &#125;
  &#125;
  getItem(key) &#123;
    let value = this.storage.getItem(key);
    if (value) &#123;
      value = JSON.parse(value);
      return value;
    &#125;
  &#125;
  removeItem(key) &#123;
    this.storage.removeItem(key);
  &#125;
  clear() &#123;
    this.storage.clear();
  &#125;
&#125;

const localcache = new HYCache();
const sessioncache = new HYCache(false);

export &#123; localcache, sessioncache &#125;;
</code></pre>
<h3 id="6-indexedDB-了解就行"><a href="#6-indexedDB-了解就行" class="headerlink" title="6. indexedDB 了解就行"></a>6. indexedDB 了解就行</h3><p>是一种底层的 API 用于在客户端储存大量的结构化数据</p>
<ul>
<li>事务型的数据库系统</li>
</ul>
<h2 id="第二十八节-Cookie-BOM-DOM"><a href="#第二十八节-Cookie-BOM-DOM" class="headerlink" title="第二十八节 Cookie BOM DOM"></a>第二十八节 Cookie BOM DOM</h2><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3><ul>
<li>浏览器会在特定的情况下携带上 cookie 来发送请求 我们可以通过 cookie 来获取一些信息</li>
</ul>
<h4 id="1-1cookie-保存在客户端中-根据客户端的储存位置-分为内存-cookie-和硬盘-cookie"><a href="#1-1cookie-保存在客户端中-根据客户端的储存位置-分为内存-cookie-和硬盘-cookie" class="headerlink" title="1-1cookie 保存在客户端中 根据客户端的储存位置 分为内存 cookie 和硬盘 cookie"></a>1-1cookie 保存在客户端中 根据客户端的储存位置 分为内存 cookie 和硬盘 cookie</h4><ul>
<li>内存 cookie 由浏览器维护 保存在内存中 浏览器关闭时 cookie 就会小时 存在时间短暂</li>
<li>硬盘 cookie 保存在硬盘中 有一个过期时间 用户手动清理或者过期时间到时 才会被清理</li>
</ul>
<h4 id="1-2-区分内存-cookie-和硬盘-cookie"><a href="#1-2-区分内存-cookie-和硬盘-cookie" class="headerlink" title="1-2 区分内存 cookie 和硬盘 cookie"></a>1-2 区分内存 cookie 和硬盘 cookie</h4><ul>
<li>有没有设置过期时间 默认情况下 cookie 是内存 cookie 关闭浏览器时自动删除</li>
<li>有设置过期时间 并且过期时间不为 0 或者负数的 cookie 是硬盘 cookie 需要手动删除</li>
</ul>
<h3 id="2-cookie-常见的属性"><a href="#2-cookie-常见的属性" class="headerlink" title="2. cookie 常见的属性"></a>2. cookie 常见的属性</h3><ul>
<li><p>cookie 的生命周期</p>
<ul>
<li>expires： 设置的是 Date.toUTCString（） 具体的时间</li>
<li>max-age：设置过期的秒钟 用得更多</li>
</ul>
</li>
<li><p>cookie 作用域 允许 cookie 发送给那些 URL</p>
<ul>
<li>Domain：指定那些主机可以接受 cookie<ol>
<li>如果不指定默认是 orgin 不包括子域名</li>
<li>如果指定 则包含子域名如果设置 Domain=mmozillia.org 则 Cookie 也包含在子域名中（如 developer.mozilla.org）</li>
</ol>
</li>
<li>Path：指定主机下哪些路径可以接受 cookie<ol>
<li>例如 设置 Path=/docs 则以下地址都会匹配：<ul>
<li>/docs</li>
<li>/docs/web/</li>
<li>/docs/web/tp</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>删除 cookie 设置过期时间 需要在服务端设置 httpOnly 为 false</p>
<pre><code class="js">document.cookie = &quot;name=&#39;&#39;;max-age:0&quot;;
</code></pre>
</li>
</ul>
<h3 id="3-Cookie-的缺点"><a href="#3-Cookie-的缺点" class="headerlink" title="3. Cookie 的缺点"></a>3. Cookie 的缺点</h3><ul>
<li>将每一次 cookie 附加到每一次 http 的请求中</li>
<li>明文传输 headers 存在一定的安全风险</li>
<li>大小限制 4kb</li>
<li>cookie 验证登录复杂</li>
</ul>
<h3 id="4-BOM-浏览器对象模型"><a href="#4-BOM-浏览器对象模型" class="headerlink" title="4. BOM 浏览器对象模型"></a>4. BOM 浏览器对象模型</h3><ul>
<li><p>我们可以将 BOM 看成链接 JS 和浏览器窗口的桥梁</p>
</li>
<li><p>BOM API 太多不需要每个都去学 用到时候去查文档</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></p>
<p><strong>BOM 主要对象模型</strong></p>
</li>
<li><p>window：包括全局属性方法 控制浏览器窗口相关的属性方法</p>
</li>
<li><p>location：浏览器连接到的对象位置（url）</p>
</li>
<li><p>history：操作浏览器的历史</p>
</li>
<li><p>document：当前窗口操作文档的对象</p>
</li>
</ul>
<h5 id="window-对象在浏览器中有两个身份："><a href="#window-对象在浏览器中有两个身份：" class="headerlink" title="window 对象在浏览器中有两个身份："></a>window 对象在浏览器中有两个身份：</h5><ul>
<li>身份一：全局对象<ul>
<li>我们知道 ecmsscript 有一个全局对象 这个全局对象在 node 中是 global</li>
<li>在浏览器中就是 window 对象</li>
</ul>
</li>
<li>身份二 ：浏览器窗口对象<ul>
<li>作为浏览器窗口时，提供了对浏览器操作的相关的 API；</li>
</ul>
</li>
</ul>
<p>window.disapatchEvent（）派发事件</p>
<p><strong>location</strong></p>
<p><img src="/2022/021964822/image-20220214155705707.png"></p>
<p><strong>history</strong></p>
<p>允许我们访问浏览器曾经的记录历史</p>
<p><img src="/2022/021964822/image-20220214160500148.png"></p>
<h2 id="第二十九节-DOM-和-架构"><a href="#第二十九节-DOM-和-架构" class="headerlink" title="第二十九节 DOM 和 架构"></a>第二十九节 DOM 和 架构</h2><h3 id="1-参数的作用域"><a href="#1-参数的作用域" class="headerlink" title="1. 参数的作用域"></a>1. 参数的作用域</h3><p><strong>当函数参数有默认值的情况下会多生成一个新的作用域 这个作用域用于保存参数的值</strong></p>
<h3 id="2-DOM-document-object-model"><a href="#2-DOM-document-object-model" class="headerlink" title="2. DOM document object model"></a>2. DOM document object model</h3><p><img src="/2022/021964822/image-20220214164306779.png"></p>
<p>node：节点</p>
<p>document ：整个网页是 document</p>
<p>element：标签元素</p>
<p>characterData:字符数据</p>
<p>attrbiute：属性</p>
<h4 id="2-1-事件流"><a href="#2-1-事件流" class="headerlink" title="2-1 事件流"></a>2-1 事件流</h4><ul>
<li><p>事件冒泡</p>
<p>一层一层往外层冒</p>
</li>
<li><p>事件捕获</p>
<p>那个外层往里叫做捕获</p>
<p>window.addEventListner（第三个参数 true，false 决定了是冒泡还是捕获 默认是 false 冒泡）</p>
<p>阻止事件传递：event.stopPropagation（）</p>
</li>
</ul>
<h2 id="第三十节-手写防抖，节流函数"><a href="#第三十节-手写防抖，节流函数" class="headerlink" title="第三十节 手写防抖，节流函数"></a>第三十节 手写防抖，节流函数</h2><h3 id="1-防抖-debounce-函数"><a href="#1-防抖-debounce-函数" class="headerlink" title="1. 防抖 debounce 函数"></a>1. 防抖 debounce 函数</h3><p>事件触发时 响应函数不会立即触发 而会等待一定时间</p>
<p>当事件密集触发时 函数的触发会被频繁的推迟</p>
<p>只有等待了一段事件没有事件触发 才会真正的执行响应函数</p>
<p>应用场景：</p>
<ul>
<li>输入框频繁输入内容 搜索或提交信息</li>
<li>频繁的点击按钮 触发某个事件</li>
<li>监听浏览器滚动事件 完成某些特定操作</li>
<li>用户缩放浏览器的 resize 事件</li>
</ul>
<h3 id="2-节流函数-throttle"><a href="#2-节流函数-throttle" class="headerlink" title="2. 节流函数 throttle"></a>2. 节流函数 throttle</h3><p>事件触发时 会执行这个事件的响应函数</p>
<p>这个事件如果被频繁触发 那么节流函数会按照一定的频率来执行函数</p>
<p>不管中间有多少次触发这个事件 执行函数的频率是固定的</p>
<p>应用场景:</p>
<ul>
<li>监听页面的滚动事件</li>
<li>鼠标移动事件</li>
<li>用户频繁点击按钮操作</li>
<li>游戏中的一些设计</li>
</ul>
<h3 id="3-第三方库工具库"><a href="#3-第三方库工具库" class="headerlink" title="3. 第三方库工具库"></a>3. 第三方库工具库</h3><ul>
<li>lodash</li>
<li>undescore</li>
</ul>
<h3 id="4-手写防抖函数基本实现-立即执行-取消功能"><a href="#4-手写防抖函数基本实现-立即执行-取消功能" class="headerlink" title="4. 手写防抖函数基本实现 立即执行 取消功能"></a>4. 手写防抖函数基本实现 立即执行 取消功能</h3><pre><code class="js">function _debounce(fn，deplay,immediate=false)&#123;
    //定义一个定时器  保存上一次的定时器
   let timer=null;
    let isInvoke=false;
   //真正执行的函数
  const debounce=function(...args)&#123;
  //取消上一次的定时器
   if(timer) clearTimeout(timer)
   //判断是否立即执行
    if(isInvoke&amp;&amp; !immediate)&#123;
         fn.apply(this,args)
        isInvoke=true
    &#125;else&#123;
          //延迟执行
       timer= setTimeout(()=&gt;&#123;
       //外部传入真正要执行的函数
       fn.apply(this,args)
        isInvoke=false
        &#125;,deplay)
    &#125;
  &#125;
  //封装一个取消功能
  debounce.cancel=function()&#123;
      if(timer)clearTimeout(timer);
      timer=null;
      isInvoke=false;
  &#125;
  return debounce;
&#125;
</code></pre>
<h4 id="5-手写节流函数-throttle"><a href="#5-手写节流函数-throttle" class="headerlink" title="5. 手写节流函数 throttle"></a>5. 手写节流函数 throttle</h4><pre><code class="js">function throttle(fn, interval) &#123;
  //记录上一次的开始时间
  let lastTime = 0;
  //事件触发时  真正执行的函数
  const _throttle = function () &#123;
    //2.1 获取当前事件触发时的时间
    const nowTime = new Date().getTime();
    //2.2 使用当前触发的时间和之前的时间间隔以及上一次开始的时间 计算出还剩余多长时间需要去触发事件
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime &lt;= 0) &#123;
      //2.3 真正触发函数
      fn();
      //2.4 保留上次触发的时间
      lastTime = nowTime;
    &#125;
  &#125;;
  return _throttle;
&#125;
</code></pre>
<h2 id="第三十一节-深拷贝-事件总线"><a href="#第三十一节-深拷贝-事件总线" class="headerlink" title="第三十一节 深拷贝 事件总线"></a>第三十一节 深拷贝 事件总线</h2><h3 id="1-深拷贝"><a href="#1-深拷贝" class="headerlink" title="1. 深拷贝"></a>1. 深拷贝</h3><pre><code class="js">
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">N</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://nhnjs.github.io/2022/021964822.html">http://nhnjs.github.io/2022/021964822.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">N</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #ff9999;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        /* max-width: 100%; */
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
    .v[data-class=v] .vinput {
     padding: 0px 0px;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        enableQQ: true,
        boolean: true,
        appId: 'IqF6vToVgh8EOgWKOdfVrPxm-gzGzoHsz',
        appKey: 'pN0qJqhJEriU6njLMiwim6bX',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '来啊 造作啊',
        requiredFields: ['nick','mail'], //设置必填项
        // 设置Bilibili表情包地址
        emojiCDN: '//i0.hdslb.com/bfs/emote/', 
        // 表情title和图片映射
        emojiMaps: {
        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
        "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
        "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
        "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
        "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
        "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
        "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
        "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
        "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
        "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
        "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
        "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
        "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
        "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
        "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
        "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
        "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
        "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
        "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
        "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
        "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
        "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
        "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
        "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
        "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
        "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
        "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
        "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
        "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
        "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
            // ... 更多表情
        }
    });
</script>


    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/021964822.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="深入JS学习">
                        
                        <span class="card-title">深入JS学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-02-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            N
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/120712750.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="前端学习">
                        
                        <span class="card-title">前端学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            N
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="6753501244"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">N</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "5";
                        var startDate = "9";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/nhnjs" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:723352828@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=723352828" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 723352828" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
   

</body>

</html>
