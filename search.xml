<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入JS学习</title>
      <link href="2022/021964822.html"/>
      <url>2022/021964822.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一节-浏览器工作原理和-V8-引擎"><a href="#第一节-浏览器工作原理和-V8-引擎" class="headerlink" title="第一节 浏览器工作原理和 V8 引擎"></a>第一节 浏览器工作原理和 V8 引擎</h2><h3 id="1-浏览器的工作原理"><a href="#1-浏览器的工作原理" class="headerlink" title="1. 浏览器的工作原理"></a>1. 浏览器的工作原理</h3><p><img src="/2022/021964822/image-20220105184125114.png"></p><p><strong>服务器返回给我们一个网页 当浏览器解析到 link 标签下载 css 文件解析到 script 标签就下载 js 文件</strong></p><h3 id="2-浏览器的渲染过程"><a href="#2-浏览器的渲染过程" class="headerlink" title="2. 浏览器的渲染过程"></a>2. 浏览器的渲染过程</h3><p><img src="/2022/021964822/image-20220107083615216.png"></p><h3 id="3-JavaScript-引擎"><a href="#3-JavaScript-引擎" class="headerlink" title="3. JavaScript 引擎"></a>3. JavaScript 引擎</h3><p>JavaScript 引擎就是把 js 代码转换为机器代码，由 cpu 执行。</p><h3 id="4-v8-引擎"><a href="#4-v8-引擎" class="headerlink" title="4. v8 引擎"></a>4. v8 引擎</h3><p><strong>js 代码的执行过程</strong></p><p><img src="/2022/021964822/image-20220107084700472.png"></p><p><strong>JS 代码被解析成—》 抽象语法树 —–》然后又被转化为字节码 ——》 执行</strong></p><p><img src="/2022/021964822/image-20220107103233302.png"></p><h3 id="5-全局代码在内存中执行"><a href="#5-全局代码在内存中执行" class="headerlink" title="5. 全局代码在内存中执行"></a>5. 全局代码在内存中执行</h3><ol><li><p>js 引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）<br>该对象所有的作用域（scope）都可以访问；<br>里面会包含 Date、Array、String、Number、setTimeout、setInterval 等等；<br>其中还有一个 window 属性指向自己；<br>初始化全局对象</p><p><img src="/2022/021964822/image-20220107113037238.png"></p></li><li><p>js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ECS），它是用于执行代码的调用栈。</p><p><img src="/2022/021964822/image-20220107145209389.png"></p></li><li><p>执行全局代码时，会构建一个 GEC 放入调用栈中执行</p><p>GEC 被放入到 ECS 中里面包含两部分内容：<br>第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，<br>但是并不会赋值；<br>ü 这个过程也称之为变量的作用域提升（hoisting）<br>p 第二部分：在代码执行中，对变量赋值，或者执行其他的函数；</p><p><img src="/2022/021964822/image-20220107142254901.png"></p></li></ol><h2 id="第二节-内存管理和内存泄漏"><a href="#第二节-内存管理和内存泄漏" class="headerlink" title="第二节 内存管理和内存泄漏"></a>第二节 内存管理和内存泄漏</h2><p>当我们查找一个变量是，真实的查找路径是沿着作用域链查找。</p><h3 id="1-全局作用域下遇到函数的执行顺序"><a href="#1-全局作用域下遇到函数的执行顺序" class="headerlink" title="1. 全局作用域下遇到函数的执行顺序"></a>1. 全局作用域下遇到函数的执行顺序</h3><ol><li><p>创建 GO 对象 由于是在编译过程 属性值是 undefined 但是函数的属性值是地址</p><p>由于是函数另外单独开辟一块空间存储 作用域在我们编译的时候就已经确认</p><p><img src="/2022/021964822/image-20220107151802976.png"></p></li><li><p>想要执行代码就要放入 ECStack 调用栈</p><p><img src="/2022/021964822/image-20220107152059292.png"></p></li><li><p>创建 GEC 全局执行上下文添加到调用栈</p><p>GEC 中包含了 ：</p><ul><li>VO ：就是 GO</li><li>执行代码</li></ul><p><img src="/2022/021964822/image-20220107152227611.png"></p></li><li><p>开始执行代码 当执行到函数时 创建 AO 对象</p><p><img src="/2022/021964822/image-20220107152522891.png"></p></li><li><p>创建一个 FEC 函数执行上下文 添加到调用栈中</p><p><img src="/2022/021964822/image-20220107152604616.png"></p></li><li><p>FEC 中 VO 指向 AO</p><p>scope chain （作用域链）: AO+parent Scope</p></li></ol><h3 id="2-全局代码执行过程函数嵌套在内存中的过程"><a href="#2-全局代码执行过程函数嵌套在内存中的过程" class="headerlink" title="2. 全局代码执行过程函数嵌套在内存中的过程"></a>2. 全局代码执行过程函数嵌套在内存中的过程</h3><pre><code class="js">var name = &quot;why&quot;;foo(123);function foo(num) &#123;  console.log(m);  var m = 10;  var n = 20;  function bar() &#123;    console.log(name);  &#125;  bar();&#125;</code></pre><ol><li><p>创建 GO globalobject 对象 还未执行代码所以 name 值为 undefined foo 是一个函数 所以另外开一个空间储存 函数体以及作用域</p><p><img src="/2022/021964822/image-20220107153607587.png"></p><p><strong>在函数编译时候作用域就已经确定了</strong></p><p><img src="/2022/021964822/image-20220107153705578.png"></p></li><li><p>在调用栈中 创建全局执行上下文</p><p><img src="/2022/021964822/image-20220107153854595.png"></p></li><li><p>执行到 foo（）时 创建 AO 对象</p><p><img src="/2022/021964822/image-20220107153949057.png"></p></li><li><p>创建 FEC 函数执行上下文 VO 指向 AO 原型链 ：AO +父级作用域</p><p><img src="/2022/021964822/image-20220107154048087.png"></p></li><li><p>开始执行代码 执行到 bar（）时 创建一个 AO 为空</p><p><img src="/2022/021964822/image-20220107154241154.png"></p></li><li><p>在调用栈中在创建一个 FEC 函数执行上下文</p><p><img src="/2022/021964822/image-20220107154313948.png"></p></li><li><p>执行代码输出 name 由于 bar 函数中没有 name 变量定义 我们根据作用域链查找 上一级 foo 函数中也没有 name 变量在根据作用域链查找上一级 GO 中有 name 值 所以输出打印 why</p></li></ol><p><strong>这就是作用域链的原理</strong></p><h3 id="3-变量环境和记录"><a href="#3-变量环境和记录" class="headerlink" title="3. 变量环境和记录"></a>3. 变量环境和记录</h3><p>新的 es 规范中 vo 概念被更换为 ve 环境变量</p><h3 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h3><p>代码执行过程中都需要给它分配内存</p><p><img src="/2022/021964822/image-20220107163453421.png"></p><p><strong>JS 中在我们定义变量时就分配内存了</strong></p><ul><li>JS 对于基本数据类型内存分配会在执行时，直接在栈空间进行分配</li><li>JS 对于复杂数据类型内存分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用</li></ul><p><img src="/2022/021964822/image-20220107164118116.png"></p><h3 id="5-JS-的垃圾回收"><a href="#5-JS-的垃圾回收" class="headerlink" title="5. JS 的垃圾回收"></a>5. JS 的垃圾回收</h3><p>垃圾回收也叫 GC，JS 自带垃圾回收。</p><h2 id="第三节-深入-JS-闭包"><a href="#第三节-深入-JS-闭包" class="headerlink" title="第三节 深入 JS 闭包"></a>第三节 深入 JS 闭包</h2><h3 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1. 高阶函数"></a>1. 高阶函数</h3><p><strong>把一个函数接收另外一个函数作为参数或者把另外一个函数作为返回值 就被称为高阶函数。</strong></p><h3 id="2-数组中的常见高阶函数"><a href="#2-数组中的常见高阶函数" class="headerlink" title="2. 数组中的常见高阶函数"></a>2. 数组中的常见高阶函数</h3><ul><li><p>filter（）：返回符合 function 条件的新数组</p><pre><code class="js">arr.filter(function(数组的元素，索引，数组)&#123;&#125;)</code></pre></li><li><p>find() 返回符合条件的第一个元素</p><pre><code class="js">let re = arr.find(function (value, index, arr) &#123;  return value &gt; 3;&#125;);console.log(re);</code></pre></li><li><p>reduce reduce(第一个参数是一个回调函数（第一个参数上一个循环的返回值，本次循环的元素，索引，数组），第二个参数初始值)</p><pre><code class="js">// reduce实现数组累加let re = arr.reduce(function (pre, value, index, arr) &#123;  return pre + value;&#125;, 0);console.log(re);</code></pre></li><li><p>findIndex() 返回符合条件的第一个元素下标</p><pre><code class="js">let re = arr.findIndex(function (value, index, arr) &#123;  return value &gt; 3;&#125;);console.log(re);</code></pre></li><li><p>forEach() forEach 中没有 continue break 关键字 无法终止遍历</p><pre><code class="js">arr.forEach(function (value, index, arr) &#123;  console.log(value, index);&#125;);</code></pre></li><li><p>map() 会返回一个新的数组 映射</p><pre><code class="js">let re = arr.map(function (value, index, arr) &#123;  return value * 2;&#125;);console.log(re, arr);</code></pre></li></ul><h3 id="3-闭包的定义"><a href="#3-闭包的定义" class="headerlink" title="3.闭包的定义"></a>3.闭包的定义</h3><p><strong>个人理解总结</strong></p><ul><li>一个普通的函数 function，如果他可以访问外层作用域的自由变量，那么这个函数就是一个闭包；</li><li>从广义的角度来说：Javascript 中的函数都是闭包。</li><li>从狭义的角度来说：<strong>Javascript 中一个函数，如果访问了上层作用域的变量，那么它是一个闭包</strong></li></ul><h3 id="4-闭包的内存泄漏"><a href="#4-闭包的内存泄漏" class="headerlink" title="4. 闭包的内存泄漏"></a>4. 闭包的内存泄漏</h3><p>内存泄不泄露取决于我们后边用不用这个变量</p><p><strong>解决闭包的内存泄漏：</strong></p><p>只需要把指向改为 null 就可以销毁</p><h2 id="第四节-闭包内存-this-指向"><a href="#第四节-闭包内存-this-指向" class="headerlink" title="第四节 闭包内存 this 指向"></a>第四节 闭包内存 this 指向</h2><h3 id="1-AO-中不用的自由变量销毁"><a href="#1-AO-中不用的自由变量销毁" class="headerlink" title="1. AO 中不用的自由变量销毁"></a>1. AO 中不用的自由变量销毁</h3><p>AO 的自由变量如果没有用到的变量，那么 v8 引擎自己会把没有用到的变量销毁掉。</p><h3 id="2-JS-中-this-的作用"><a href="#2-JS-中-this-的作用" class="headerlink" title="2. JS 中 this 的作用"></a>2. JS 中 this 的作用</h3><p>可以没有 this，但是有 this 可以提高编码的效率很方便。</p><p>大多数情况下 this 出现在函数中</p><h3 id="3-this-在全局作用域下的指向"><a href="#3-this-在全局作用域下的指向" class="headerlink" title="3. this 在全局作用域下的指向"></a>3. this 在全局作用域下的指向</h3><ul><li>浏览器中：this 指向 window (global Object)</li><li>node 环境中：this 指向{}</li></ul><h3 id="4-this-的绑定规则"><a href="#4-this-的绑定规则" class="headerlink" title="4. this 的绑定规则"></a>4. this 的绑定规则</h3><p><strong>this 与函数定义位置无关，与函数的调用方式有关</strong></p><ul><li><p>默认绑定</p><p>独立函数调用，this 指向 window</p><pre><code class="js">foo(); //独立函数调用</code></pre></li><li><p>隐式绑定</p><p>隐式绑定的前提条件：必须在调用的对象内部有一个对函数的引用（比如一个属性）</p><p>通过某个对象调用，通过某个对象发起的函数调用</p><pre><code class="js">obj.foo()(  //通过obj对象调用foo函数  obj.foo)(); //和第一种是一样的</code></pre></li><li><p>显示绑定</p><p>call 和 apply 在执行函数时，是可以明确地绑定 this，这个规则叫做显示绑定</p><p>call 和 apply 的区别在于传参，apply 以数组的形式传参 ，call 是以，分隔参数</p><pre><code>foo.call(指定this的指向);</code></pre><pre><code class="js">foo.apply(指定this的指向);</code></pre><p>bind 绑定</p><p>bind 绑定会返回一个函数</p><pre><code class="js">var newfoo = foo.bind(指定this的指向);</code></pre><p><strong>显示绑定与默认绑定冲突：显示绑定优先</strong></p></li><li><p>new 绑定</p><p>我们通过一个 new 关键字调用一个函数时（构造器），这个时候 this 是在调用这个构造器时创建出来的对象</p><p>this=创建出来的对象</p><p>这个过程就是 new 绑定</p><pre><code class="js">function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;var p1 = new Person(&quot;why&quot;, 18);</code></pre></li></ul><h2 id="第五节-this-绑定的优先级"><a href="#第五节-this-绑定的优先级" class="headerlink" title="第五节 this 绑定的优先级"></a>第五节 this 绑定的优先级</h2><h3 id="1-绑定规则的优先级"><a href="#1-绑定规则的优先级" class="headerlink" title="1. 绑定规则的优先级"></a>1. 绑定规则的优先级</h3><ul><li>默认规则的优先级最低</li><li>显示绑定优先级高于隐式绑定</li><li>new 绑定优先级高于隐式绑定 new 的优先级高于显示绑定 不能和 call/apply 关键字一起使用</li><li>new 绑定》显示绑定》隐式绑定》默认绑定</li></ul><h3 id="2-特殊绑定-忽略显示绑定"><a href="#2-特殊绑定-忽略显示绑定" class="headerlink" title="2. 特殊绑定 -忽略显示绑定"></a>2. 特殊绑定 -忽略显示绑定</h3><p>apply/call/bind 当传入的参数是 null 或者 undefined 时 this 的指向为 window</p><h3 id="3-箭头函数-（参数）-gt-执行体"><a href="#3-箭头函数-（参数）-gt-执行体" class="headerlink" title="3. 箭头函数 （参数）=&gt;{执行体}"></a>3. 箭头函数 （参数）=&gt;{执行体}</h3><ul><li>箭头函数不会绑定 this ， arguments 属性</li><li>箭头函数不能 作为构造函数来使用 不能和 new 一起来使用</li></ul><p><strong>箭头函数常见的简写：</strong></p><ol><li><p>当我们只有一个参数时：（）可以省略 num=&gt;{};</p></li><li><p>如果函数执行体只有一行代码大括号{}也可以省略并且他会默认将这行代码的执行结果作为返回值 参数=&gt;执行代码</p></li><li><p>如果一个箭头函数，只有一行代码并且返回值是一个对象 在对象外加一个（）让它当做一个整个返回</p><p>var bar=（）=&gt;({name：‘why’，age：18})</p></li></ol><h3 id="4-箭头函数的-this-获取"><a href="#4-箭头函数的-this-获取" class="headerlink" title="4. 箭头函数的 this 获取"></a>4. 箭头函数的 this 获取</h3><p>箭头函数中不适用 4 种 this 绑定规则，而是往上层作用域查找上层作用域的 this</p><p>函数只要执行就会放到执行上下文栈中 箭头函数也会</p><p>如果箭头函数上层作用域没有找到就去在上一层</p><h2 id="第六节-手写-call-apply-bind-arguments-函数"><a href="#第六节-手写-call-apply-bind-arguments-函数" class="headerlink" title="第六节 手写 call-apply-bind arguments 函数"></a>第六节 手写 call-apply-bind arguments 函数</h2><h3 id="1-实现-call-apply-bind"><a href="#1-实现-call-apply-bind" class="headerlink" title="1. 实现 call apply bind"></a>1. 实现 call apply bind</h3><h4 id="1-1-JS-实现-call"><a href="#1-1-JS-实现-call" class="headerlink" title="1-1 JS 实现 call"></a>1-1 JS 实现 call</h4><pre><code class="js">// 手写callFunction.prototype.hycall = function (thisArg, ...nums) &#123;  // 1. 需要获取被执行的函数  var that = this;  // 2.对thisArg转成对象类型（防止传入非对象类型）  // 判断要绑定的this指向 是不是为空  thisArg =    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;  // 3.调用被执行的函数  thisArg.that = that;  var result = thisArg.that(...nums);  delete thisArg.that;  // 4. 将最终的结果返回  return result;&#125;;</code></pre><ol><li><p>获取需要被执行的函数</p><p>根据 this 指向就可以获取被执行的函数</p><pre><code class="js">Function.prototype._call = function (thisArg, ...nums) &#123;  var fn = this;&#125;;</code></pre></li><li><p>对 thisArg 转成对象类型（防止传入非对象类型）</p><pre><code class="js">// 2.对thisArg转成对象类型（防止传入非对象类型）// 判断要绑定的this指向 是不是为空thisArg = thisArg ? Object(thisArg) : window;</code></pre></li><li><p>调用需要被执行的函数</p><pre><code class="js">// 3.调用被执行的函数thisArg.fn = fn;var result = thisArg.fn(...nums);delete thisArg.fn;</code></pre></li><li><p>将最终的结果返回</p><pre><code class="js">// 4. 将最终的结果返回return result;</code></pre></li></ol><p><strong>当我们不知道函数中要传入多少个参数时 可以使用扩展运算符 …后边跟上参数名</strong></p><p><strong>展开运算符 …参数名</strong></p><h4 id="1-2-实现-apply"><a href="#1-2-实现-apply" class="headerlink" title="1-2 实现 apply"></a>1-2 实现 apply</h4><pre><code class="js">// 手写applyFunction.prototype.hyapply = function (thisArg, argArray) &#123;  var that = this;  thisArg =    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;  thisArg.that = that;  var result;  argArray = argArray || [];  result = thisArg.that(...argArray);  delete thisArg.that;  return result;&#125;;</code></pre><ol><li><p>获取需要被执行的函数</p><pre><code class="js">Function.prototype._call = function (thisArg, arrayArg) &#123;  var fn = this;&#125;;</code></pre></li><li><p>对 thisArg 转成对象类型（防止传入非对象类型）</p><pre><code class="js">//对thisArg转成对象类型（防止传入非对象类型）thisArg =  thisArg !== null &amp;&amp; thisArg !== undefined ? Obejct(thisArg) : window;</code></pre></li><li><p>调用需要被执行的函数</p><pre><code class="js">thisArg.fn = fn;var result;arrayArg = arrayArg || [];result = thisArg.fn(...arrayArg);delete thisArg.fn;</code></pre></li><li><p>将最终的结果返回</p><pre><code class="js">return result;</code></pre></li></ol><h4 id="1-3-bind-方法实现"><a href="#1-3-bind-方法实现" class="headerlink" title="1-3 bind 方法实现"></a>1-3 bind 方法实现</h4><pre><code class="js">// 手写bindFunction.prototype.hybind = function (thisArg, ...argArray) &#123;  var that = this;  thisArg =    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;  return function (...arr) &#123;    thisArg.that = that;    var arg = [...argArray, ...arr];    var result = thisArg.that(...arg);    delete thisArg.that;    return result;  &#125;;&#125;;</code></pre><ol><li><p>获取调用函数</p><pre><code class="js">Function.prototype.hybind = function (thisArg, ...argArray) &#123;  var fn = this;&#125;;</code></pre></li><li><p>绑定 this</p><pre><code class="js">thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? thisArg : window;</code></pre></li><li><p>调用函数</p><pre><code class="js">function proxyfn(...args) &#123;  thisArg.fn = fn;  var arr = [...argArray, ...args];  var result = thisArg.fn(...arr);  delete thisArg.fn;  return result;&#125;</code></pre></li><li><p>返回结果</p><pre><code class="js">return proxfn;</code></pre></li></ol><h3 id="2-认识-arguments"><a href="#2-认识-arguments" class="headerlink" title="2. 认识 arguments"></a>2. 认识 arguments</h3><p>arguments 是一个类数组对象，长得像是一个数组，本质是一个对象</p><p>不能调用数组的方法</p><p><strong>常见的对 arguments 的三个操作</strong></p><ol><li>获取参数的长度</li><li>根据索引值获取某一个参数</li><li>callee 获取当前 arguments 所在的函数</li></ol><h3 id="3-arguments-转为数组"><a href="#3-arguments-转为数组" class="headerlink" title="3. arguments 转为数组"></a>3. arguments 转为数组</h3><p>1.第一种方法</p><p>var newarr=Array.prototype.slice.call(arguments)</p><p>2.第二种 遍历 arguments 把每一项加到新数组中</p><p>3.第三种方法 es6 语法 var newarr= Array.from（arguments）</p><p>4.第四种方法 扩展运算符 var newArr=[…arguments]</p><h3 id="4-箭头函数中没有-arguments"><a href="#4-箭头函数中没有-arguments" class="headerlink" title="4. 箭头函数中没有 arguments"></a>4. 箭头函数中没有 arguments</h3><p>在箭头函数中么没有 arguments 他就会去上层作用域查找。</p><p>在全局环境下：</p><p>浏览器中没有 arguments</p><p>node 环境下：有</p><h2 id="第七节-函数式编程-（回头再仔细观看目前先了解）"><a href="#第七节-函数式编程-（回头再仔细观看目前先了解）" class="headerlink" title="第七节 函数式编程 （回头再仔细观看目前先了解）"></a>第七节 函数式编程 （回头再仔细观看目前先了解）</h2><h3 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1. 函数式编程"></a>1. 函数式编程</h3><p>一种编程的方式</p><h3 id="2-纯函数"><a href="#2-纯函数" class="headerlink" title="2. 纯函数"></a>2. 纯函数</h3><p>概念:</p><ul><li>确定的输入，一定会产生确定的输出</li><li>在函数执行过程中，不能产生副作用</li></ul><p><strong>副作用：在执行函数时，除了返回函数值之外，还对调用函数产生了附加影响，比如修改了全局变量，修改参数或者改变外部的存储</strong></p><h3 id="3-函数柯里化"><a href="#3-函数柯里化" class="headerlink" title="3. 函数柯里化"></a>3. 函数柯里化</h3><p>概念：值传递给函数一部分参数来调用它，让他返回一个函数去处理剩余参数 这个过程就叫做柯里化</p><p><img src="/2022/021964822/image-20220110221137680.png"></p><h3 id="4-柯里化的实现"><a href="#4-柯里化的实现" class="headerlink" title="4. 柯里化的实现"></a>4. 柯里化的实现</h3><p><img src="/2022/021964822/image-20220111124307191.png"></p><h3 id="5-理解组合函数"><a href="#5-理解组合函数" class="headerlink" title="5. 理解组合函数"></a>5. 理解组合函数</h3><p><img src="/2022/021964822/image-20220111124728862.png"></p><h2 id="第八节-面向对象"><a href="#第八节-面向对象" class="headerlink" title="第八节 面向对象"></a>第八节 面向对象</h2><h3 id="1-with-语句"><a href="#1-with-语句" class="headerlink" title="1. with 语句"></a>1. with 语句</h3><p>with 语句：可以形成自己的作用域</p><p>with（参数是一个对象）{ }</p><p>查找变量先去对象中查找再去上层作用域中查找</p><p><strong>不推荐使用</strong></p><h3 id="2-eval-函数"><a href="#2-eval-函数" class="headerlink" title="2. eval 函数"></a>2. eval 函数</h3><p>eval 是一个特殊的函数，全局函数，将传入的字符当做 js 代码执行</p><p><strong>不推荐使用 可读性差 不能被 js 引擎优化</strong></p><h3 id="3-认识严格模式"><a href="#3-认识严格模式" class="headerlink" title="3. 认识严格模式"></a>3. 认识严格模式</h3><p>具有限制性的 js 模式，从而使代码隐式的脱离了 懒散模式</p><p>“use strict”;</p><p><img src="/2022/021964822/image-20220111135259635.png"></p><h3 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4. 面向对象"></a>4. 面向对象</h3><h4 id="4-1-创建对象的方式一"><a href="#4-1-创建对象的方式一" class="headerlink" title="4-1 创建对象的方式一"></a>4-1 创建对象的方式一</h4><p>var obj=new Object（）</p><p>obj.name=’123’</p><h4 id="4-2-创建对象方式二"><a href="#4-2-创建对象方式二" class="headerlink" title="4-2 创建对象方式二"></a>4-2 创建对象方式二</h4><p>var obj={</p><p>​ name：‘456’</p><p>}</p><h3 id="5-对对象属性的操作"><a href="#5-对对象属性的操作" class="headerlink" title="5. 对对象属性的操作"></a>5. 对对象属性的操作</h3><p>想要对对象进行比较精准的操作控制时需要使用 Object.defineProperty(第一个参数对那个对象进行操作，第二个传参数对那个属性进行操作，第三个参数要定义或修改的属性描述符 是个对象{})</p><pre><code class="js">//定义单个属性符Object.definedProperty（）</code></pre><p><img src="/2022/021964822/image-20220111144926574.png"></p><h3 id="6-Object-defineProperty（obj，name，-）的数据属性描述符"><a href="#6-Object-defineProperty（obj，name，-）的数据属性描述符" class="headerlink" title="6. Object.defineProperty（obj，name，{}）的数据属性描述符"></a>6. Object.defineProperty（obj，name，{}）的数据属性描述符</h3><p><img src="/2022/021964822/image-20220111145110625.png"></p><h3 id="7-Object-defineProperty（obj，name，-）-存取属性描述符"><a href="#7-Object-defineProperty（obj，name，-）-存取属性描述符" class="headerlink" title="7.Object.defineProperty（obj，name，{}） 存取属性描述符"></a>7.Object.defineProperty（obj，name，{}） 存取属性描述符</h3><p><img src="/2022/021964822/image-20220111150939972.png"></p><p>存取属性描述符的应用场景：</p><ol><li><strong>当我们需要私有属性不希望被外界使用赋值</strong></li><li><strong>我们希望能截获某一个属性他访问和设置值得过程时，也会使用存储属性描述符</strong></li></ol><p>存储属性描述符存在时，writable 和 value 就不会存在这两组只能存在一个</p><p>JS 严格意义上没有私有属性，但是社区规范_开头的是私有属性</p><h2 id="第九节-原型-继承"><a href="#第九节-原型-继承" class="headerlink" title="第九节 原型 继承"></a>第九节 原型 继承</h2><h3 id="1-定义多个属性描述符"><a href="#1-定义多个属性描述符" class="headerlink" title="1. 定义多个属性描述符"></a>1. 定义多个属性描述符</h3><p>Object.definedProperties（） 定义多个属性</p><pre><code class="js">Object.definedProperties(obj,&#123;    name:&#123;        configurable:true,        enumerable:true,        writable:true,        value:&quot;why&quot;    &#125;,    age:&#123;        configurable:false,        enumerable:false,     get：function（）&#123;       return this._age;    &#125;,    set:function(value)&#123;        this._age=value    &#125;&#125;)</code></pre><h3 id="2-对象方法的补充"><a href="#2-对象方法的补充" class="headerlink" title="2. 对象方法的补充"></a>2. 对象方法的补充</h3><ul><li><p>获取某一个特定属性的描述符</p><p>Object.getOwnPropertyDescriptor（obj，”属性名”）</p></li><li><p>获取对象所有属性的描述符</p><p>Object.getOwnPropertyDescriptors（obj）</p></li></ul><h3 id="3-Object-的方法对对象的限制"><a href="#3-Object-的方法对对象的限制" class="headerlink" title="3. Object 的方法对对象的限制"></a>3. Object 的方法对对象的限制</h3><ul><li><p>禁止对象继续添加新的属性</p><p>Object.preventExtensions（obj）</p></li><li><p>禁止对象配置/删除里面的属性</p><p>Object.seal（obj）</p></li><li><p>让属性不可以修改</p><p>Object.freeze（obj）</p></li></ul><h3 id="4-创建对象方案"><a href="#4-创建对象方案" class="headerlink" title="4. 创建对象方案"></a>4. 创建对象方案</h3><ol><li><p>工厂模式创建对象</p><p>利用函数批量创建对象</p><p><img src="/2022/021964822/image-20220111173836223.png"></p></li><li><p>利用构造函数创建对象</p><p>一个函数通过 new 关键字调用，那么这个函数就是构造函数了</p></li></ol><h3 id="5-new-关键字的运行过程"><a href="#5-new-关键字的运行过程" class="headerlink" title="5. new 关键字的运行过程"></a><strong>5. new 关键字的运行过程</strong></h3><ol><li><strong>在内存中开辟一个新的对象</strong></li><li><strong>这个对象内部的[[prototype]]属性会赋值为该构造函数的 prototype 属性</strong></li><li><strong>this 指向这个对象</strong></li><li><strong>执行函数的内部代码</strong></li><li><strong>返回这个对象</strong></li></ol><h3 id="6-对象的原型"><a href="#6-对象的原型" class="headerlink" title="6. 对象的原型"></a>6. 对象的原型</h3><p>获取对象的原型 每个对象都有一个[[prototype]] 这个属性称之为对象的原型 （隐式原型）</p><p>Object.getPrototypeOf（obj）</p><p>obj. ** proto ** 是浏览器给的方法不符合规范但是可以调试用 存在浏览器兼容问题</p><h3 id="7-函数的原型"><a href="#7-函数的原型" class="headerlink" title="7. 函数的原型"></a>7. 函数的原型</h3><p>函数作为对象来说，它也是有[[prototype]] 隐式原型</p><p>函数还会多出来一个显示原型属性：prototype</p><p>函数的原型中有一个属性 constructor 它指向构造函数本身 但是它是不可枚举状态</p><p>批量往原型中添加属性方法：</p><pre><code class="js">foo.prototype=&#123; name：&#39;haonan&#39;, age:18, sex:&#39;男&#39;&#125;//不要忘记添加constructor   因为本来原型中constructor属性就是不可枚举  所以要通过objectdefinedproperty这个方法才能完整添加Object.definedProperty(foo.prototype,&#39;constructor&#39;,&#123;    enmurible:false,    writable:true,    value:foo,    configrable:true&#125;)</code></pre><h2 id="第十节-原型链-继承"><a href="#第十节-原型链-继承" class="headerlink" title="第十节 原型链 继承"></a>第十节 原型链 继承</h2><h3 id="1-可枚举属性的补充"><a href="#1-可枚举属性的补充" class="headerlink" title="1. 可枚举属性的补充"></a>1. 可枚举属性的补充</h3><p>我们设置对象属性不可枚举但是在浏览器中可以显示，但是它依然不可枚举，浏览器为了方便我们调试显示出来。</p><h3 id="2-面向对象的三大特性"><a href="#2-面向对象的三大特性" class="headerlink" title="2. 面向对象的三大特性"></a>2. 面向对象的三大特性</h3><p>封装 继承 多态</p><p>封装：将我们的属性和方法封装到一个类中，可以称之为封装的过程。</p><p>继承：是多态的前提（纯面向对象中），重复利用一些代码</p><p>多态：不同的对象在执行时表现出不同的形态。</p><h3 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3. 原型链"></a>3. 原型链</h3><h4 id="3-1原型链（-proto-）的概念："><a href="#3-1原型链（-proto-）的概念：" class="headerlink" title="3-1原型链（ proto ）的概念："></a>3-1<strong>原型链（</strong> proto <strong>）的概念：</strong></h4><p><strong>当我们查找对象中的一个属性时，先查找这个对象有没有，如果没有时会去原型对象上查找，如果原型对象上没有时会去原型对象里的原型对象上查找，一直查找到顶层原型对象 Object，这个查找过程形成了一个链式查找这就叫做原型链。</strong></p><h4 id="3-2-原型链的顶层对象"><a href="#3-2-原型链的顶层对象" class="headerlink" title="3-2 原型链的顶层对象"></a>3-2 原型链的顶层对象</h4><p>Object 原型对象的 ** proto ** 指向 null</p><p>原型链查找到 Object 原型对象时就会停止查找，也就是 Object 原型对象就是顶层的原型。</p><h4 id="3-3-顶层原型来自哪里"><a href="#3-3-顶层原型来自哪里" class="headerlink" title="3-3 顶层原型来自哪里"></a>3-3 顶层原型来自哪里</h4><p>Object 的 prototype 就是我们的顶层原型</p><p>var obj={ }创建对象 是 var obj2=new Object（） 的语法糖写法</p><p>本质上 Object 就是一个函数</p><p><strong>Object 是所有类的父类</strong></p><p>由此可以得出结论 ： 原型链最顶层的原型对象就是 Object 的原型对象。</p><h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h3><p>继承就是把一些公共的属性方法封装到父类中，特有的方法属性放到子类中，但是子类可以调用父类的属性和方法。</p><h4 id="4-1-原型链原理继承"><a href="#4-1-原型链原理继承" class="headerlink" title="4-1 原型链原理继承"></a>4-1 原型链原理继承</h4><p>把子类的原型设置为父类的实例化</p><p><strong>但是要注意书写位置 要写在紧跟着子类构造函数下边</strong></p><p>Student.prototype=new Person();</p><pre><code class="js">function Person（）&#123;    this.name=&#39;why&#39;    this.friends=[]&#125;Person.prototype.eating=function()&#123;    console.log(this.name&#39;eating&#39;)&#125;function Student ()&#123;    this.sno=111&#125;var p=new Person() // &#123;name=&#39;why&#39;,friends:[]&#125;Student.prototype=p;Student.prototype.studying=function()&#123;    console.log(this.name+&#39;studing&#39;)&#125;var stu1=new Student()var stu2=new Student()//获取引用 ，修改引用中的值 会互相影响stud2.friends.push(&#39;kobe&#39;)console.log(stu1.friends) // 都是kobe  相互影响console.log(stu2.friends) // kobe</code></pre><p><strong><font color="red">原型链实现继承弊端:</font></strong></p><ol><li><strong><font color="red">打印 stu 对象继承的属性是看不到的</font></strong></li><li><strong><font color="red">创建出两个 stu 对象</font></strong></li><li><strong><font color="red">在前面实现类的过程中是没有传递参数的</font></strong></li></ol><h4 id="4-2-借用构造函数继承"><a href="#4-2-借用构造函数继承" class="headerlink" title="4-2 借用构造函数继承"></a>4-2 借用构造函数继承</h4><p>在子类中 调用一下父类方法 把子类的 this 传入父类 传入子类参数</p><p><strong>解决了原型继承的弊端</strong></p><p><strong>Person.call(this，name，age，friends)</strong></p><pre><code class="js">function Person(name,age,friends)&#123;    this.name=name    this.age=age    this.friends=[]&#125;Person.prototype.eating=function()&#123;    console.log(this.name&#39;eating&#39;)&#125;function Student (name,age,friends,sno)&#123;    // 解决了可以传递参数  并且不是在Student类中  通过调用 Person  把Student的this传入    Person.call(this,name,age,friends)    this.sno=sno&#125;var p=new Person() // &#123;name=&#39;why&#39;,friends:[]&#125;Student.prototype=p;Student.prototype.studying=function()&#123;    console.log(this.name+&#39;studing&#39;)&#125;var stu1=new Student(&quot;why&quot;,18,[&#39;lilei&#39;])var stu2=new Student(&quot;kobe&quot;,30,[&quot;james&quot;])</code></pre><p><strong><font color="red">借用构造函数继承弊端:</font></strong></p><ol><li><strong><font color="red">Person 函数至少被调用了两次</font></strong></li><li><strong><font color="red">stu 的原型对象上会多出一些属性，但是这些属性没有存在的必要</font></strong></li></ol><h4 id="4-3-原型式继承函数-对象上的继承"><a href="#4-3-原型式继承函数-对象上的继承" class="headerlink" title="4-3 原型式继承函数(对象上的继承)"></a>4-3 原型式继承函数(对象上的继承)</h4><p>创建一个函数传入一个对象参数，把一个对象的原型设置为传入的对象参数</p><p>老式原型式继承函数</p><pre><code class="js">function createObject1(obj) &#123;  function Fn() &#123;&#125;  Fn.prototype = obj;  var newObj = new Fn();  return newObj;&#125;</code></pre><p>新式原型式继承函数</p><pre><code class="js">function createObject2(o) &#123;  var newObj = &#123;&#125;;  Object.setPrototypeOf(newObj, o);  return newObj;&#125;</code></pre><p>最新版 esma 规范原型式继承函数</p><pre><code class="js">var newObj = Object.create(obj);</code></pre><h4 id="4-4-寄生式继承函数（理解即可）"><a href="#4-4-寄生式继承函数（理解即可）" class="headerlink" title="4-4 寄生式继承函数（理解即可）"></a>4-4 寄生式继承函数（理解即可）</h4><p>结合工厂函数 以及原型式继承函数的方法</p><h4 id="4-5-寄生组合式继承-（最终版继承）"><a href="#4-5-寄生组合式继承-（最终版继承）" class="headerlink" title="4-5 寄生组合式继承 （最终版继承）"></a>4-5 寄生组合式继承 （最终版继承）</h4><p>利用寄生函数 与借用构造函数 组合的形式实现最终版继承</p><pre><code class="js">function Person (name,age,friends)&#123;    this.name=name    this.age=age    this.friends=friends&#125;Person.prototype.eating=function()&#123;    console.log(&#39;eatting&#39;)&#125;Person.prototype.running=function()&#123;    console.log(&#39;running&#39;)&#125;function Students(name,age,friends,sno)&#123;    Person.call(this,name,age,friends);    this.sno=sno&#125;//寄生组合式函数function creatObject(o)&#123;   function Fn()&#123;&#125;   Fn.prototype=o   return new Fn()&#125;function inheritPrototype(SubType(子类),SuperType(父类))&#123;    SubType.prototype=creatObject(SuperType.prototype);    Object.defineProperty(SubType.prototype,&#39;constructor&#39;,&#123;        enumerable:false,        configurable:true,        writable:true,        value:SubType    &#125;)&#125;inheritPrototype(Student,Person);</code></pre><h3 id="5-原型判断的方法补充"><a href="#5-原型判断的方法补充" class="headerlink" title="5. 原型判断的方法补充"></a>5. 原型判断的方法补充</h3><h4 id="5-1-hasOwnProperty（）"><a href="#5-1-hasOwnProperty（）" class="headerlink" title="5-1 hasOwnProperty（）"></a>5-1 hasOwnProperty（）</h4><p>对象名.hasOwnProperty(属性名)</p><p><strong>‘属性名’ in 对象名 in 操作符不管在对象中还是原型中都返回 true</strong></p><h4 id="5-2-instanceof"><a href="#5-2-instanceof" class="headerlink" title="5-2 instanceof"></a>5-2 instanceof</h4><p>检测构造函数的 prototype 是否出现在某个实例对象的原型链上</p><p>只能判断函数</p><h4 id="5-3-isPrototypeOf"><a href="#5-3-isPrototypeOf" class="headerlink" title="5-3 isPrototypeOf"></a>5-3 isPrototypeOf</h4><p>用于检测某个对象是否出现在某个实例对象的原型链上</p><p>区别：只能判断对象</p><h3 id="6-对象-函数-原型的关系"><a href="#6-对象-函数-原型的关系" class="headerlink" title="6. 对象-函数-原型的关系"></a>6. 对象-函数-原型的关系</h3><p>函数其实也可以看成一个对象 也可以看成函数 所以它拥有 prototype 属性 以及对象拥有的** proto **</p><p><strong>从函数的角度看</strong>：</p><p>Function 的原型对象继承于 Object 的原型对象</p><p>Function.prototype.** proto **===Object.prototype</p><p><strong>从对象的角度看</strong>：</p><p>但是因为 Object 其实也是一个函数 所以 Object 的 ** proto ** 又指向了 Function 的 prototype</p><p>Object.** proto ** ===Function.prototype</p><p><img src="/2022/021964822/image-20220115113159991.png"></p><h2 id="第十一节-Es6-中的-class"><a href="#第十一节-Es6-中的-class" class="headerlink" title="第十一节 Es6 中的 class"></a>第十一节 Es6 中的 class</h2><h4 id="1-class-定义类的方式"><a href="#1-class-定义类的方式" class="headerlink" title="1. class 定义类的方式"></a>1. class 定义类的方式</h4><pre><code class="js">//类的声明  普遍用法class Person&#123;&#125;typeof（person） //function// 类的表达式  用的比较少var anni=class &#123;&#125;</code></pre><h4 id="2-类的构造方法"><a href="#2-类的构造方法" class="headerlink" title="2. 类的构造方法"></a>2. 类的构造方法</h4><p><strong>注意：一个类只能有一个构造函数，如果没写构造函数 默认生成一个空的构造函数</strong></p><pre><code class="js">class Person &#123;  // 类的 构造方法  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;&#125;var str = new Person(&quot;why&quot;, 18);</code></pre><p><strong>当我们通过 new 关键字操作类的时候，会调用 constructor 这个函数，并执行以下操作：</strong></p><ol><li>在内存中创建一个新的对象（空对象）</li><li>这个对象内部的[[prototype]]属性会被赋值为该类的 prototype 属性；</li><li>构造函数内部的 this，会指向创建出来的新对象</li><li>执行构造函数的内部代码（函数体代码）</li><li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li></ol><h3 id="3-class-中的方法定义"><a href="#3-class-中的方法定义" class="headerlink" title="3. class 中的方法定义"></a>3. class 中的方法定义</h3><pre><code class="js">class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;    this._address = &quot;青岛&quot;;  &#125;  //直接写在下面  eating() &#123;    console.log(this.name + &quot;eating&quot;);  &#125;  //类的访问器方法定义  get address() &#123;    console.log(&quot;拦截访问操作&quot;);    return this._address;  &#125;  set address(newAddress) &#123;    console.log(&quot;拦截设置操作&quot;);    this._address = newAddress;  &#125;  //类的静态方法  static关键字创建 也叫作类方法  //通过类调用的方法  Person.creatPerson()  static creatPerson() &#123;&#125;&#125;</code></pre><h3 id="4-es6-实现继承"><a href="#4-es6-实现继承" class="headerlink" title="4. es6 实现继承"></a>4. es6 实现继承</h3><p>extends 关键字</p><p>super 关键字调用父类的构造函数 使用位置有三个：构造方法中 类的访问器方法 类的静态方法中</p><p>super 第一个用法 super（） 调用父类的构造方法</p><p>super 第二个用法 super.父类中的方法() 复用父类方法的逻辑</p><pre><code class="js">class Person&#123;    constructor(name.age)&#123;        this.name=name        this.age=age    &#125;    running()&#123;        console.log(&#39;running&#39;)    &#125;&#125;class Student extends Person&#123;    constructor(name，age，sno)&#123;        //访问this之前或者使用return之前必须通过super调用父类构造函数        super(name,age)        this.sno=sno    &#125;    //对父类方法重写 在running方法的基础之上    running()&#123;        super.running()        console.log(&#39;456&#39;)    &#125;&#125;</code></pre><h3 id="5-Es6-代码转-Es5-代码"><a href="#5-Es6-代码转-Es5-代码" class="headerlink" title="5. Es6 代码转 Es5 代码"></a>5. Es6 代码转 Es5 代码</h3><p>由于有的浏览器不支持 es6 代码，所以我们还是要将代码转成 es5 代码</p><h3 id="6-怎么阅读源码"><a href="#6-怎么阅读源码" class="headerlink" title="6. 怎么阅读源码"></a>6. 怎么阅读源码</h3><ol><li><strong>一定不要浮躁</strong></li><li><strong>看源码忘记前面使用 Bookmarks vscode 插件阅读源码插件 ctrl+alt+k</strong></li><li>**读完一个函数还是不知道干什么的，只能不断地提高自己积累 **</li><li><strong>debugger 通过 debugger 调试代码</strong></li></ol><h2 id="第十二节-ES6-ES12（一）"><a href="#第十二节-ES6-ES12（一）" class="headerlink" title="第十二节 ES6 -ES12（一）"></a>第十二节 ES6 -ES12（一）</h2><h3 id="1-继承内置类"><a href="#1-继承内置类" class="headerlink" title="1. 继承内置类"></a>1. 继承内置类</h3><p>不写继承 默认继承 Object</p><p>想继承其他内置类</p><pre><code class="js">class Person extends Array &#123;&#125;</code></pre><h3 id="2-类的混入-minxin"><a href="#2-类的混入-minxin" class="headerlink" title="2. 类的混入 minxin"></a>2. 类的混入 minxin</h3><p><strong>Js 只能有一个父类：单继承</strong></p><h3 id="3-Javascript-中的多态"><a href="#3-Javascript-中的多态" class="headerlink" title="3. Javascript 中的多态"></a>3. Javascript 中的多态</h3><p>多态：不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现。</p><h3 id="4-Es6-对象字面量增强写法"><a href="#4-Es6-对象字面量增强写法" class="headerlink" title="4. Es6 对象字面量增强写法"></a>4. Es6 对象字面量增强写法</h3><pre><code class="js">var name = &quot;why&quot;;var age = 18;var obj = &#123;  //1.可以省略掉value值  如果key值和value值一致 属性的简写  name,  age,  foo: function () &#123;&#125;,  // 2. foo可以简写成这样 方法的简写  foo() &#123;&#125;,  // 3. 计算属性名 computed property name  [name + 123]: &quot;hehehe&quot;,&#125;;</code></pre><h3 id="5-解构"><a href="#5-解构" class="headerlink" title="5. 解构"></a>5. 解构</h3><ol><li><p><strong>数组的解构</strong></p><pre><code class="js">var names =[&quot;abc&quot;,&quot;cba&quot;,&quot;nba&quot;]var [item1,item2,item3]=names//只解构后边两个元素var [,item2，item3] =names//解构出一个元素后边的元素放入某个数组中var [itema,...newNames]=names//解构的默认值 当itemd没有结构出值得时候默认值是avar [itema,itemb,itemc,itemd=&quot;aaa&quot;]=names</code></pre></li><li><p><strong>对象的解构</strong></p><pre><code class="js">var obj = &#123;  name: &quot;why&quot;,  age: 18,  height: 1.88,&#125;;//对象的解构用 &#123;&#125;var &#123; name, age, height &#125; = obj;//更改解构出来的名字var &#123; name: newName &#125; = obj;//默认值var &#123; address: newAddress = &quot;广州市&quot; &#125; = obj;</code></pre></li></ol><h3 id="6-let-const"><a href="#6-let-const" class="headerlink" title="6. let/const"></a>6. let/const</h3><h4 id="6-1-let-const-基本使用"><a href="#6-1-let-const-基本使用" class="headerlink" title="6-1 let/const 基本使用"></a>6-1 let/const 基本使用</h4><ul><li><p><strong>let 声明变量</strong></p><pre><code class="js">let var =123</code></pre></li><li><p><strong>const 声明常量</strong></p><pre><code class="js">const obj&#123;    name:&#39;haonan&#39;,    age:18&#125;obj.name=&#39;why&#39;</code></pre></li></ul><p>注意事项：</p><p><strong>1.但是声明引用类型时，可以通过引用找到对应的对象 修改对象内部的属性</strong></p><p><strong>2.通过 let/const 定义的变量名不能重复定义</strong></p><h4 id="6-2-let-const-作用域提升"><a href="#6-2-let-const-作用域提升" class="headerlink" title="6-2 let/const 作用域提升"></a>6-2 let/const 作用域提升</h4><p><strong>let/const 是没有进行作用域提升，但是在执行上下文创建阶段被创建出来</strong></p><h4 id="6-3-let-const-和-window-的关系"><a href="#6-3-let-const-和-window-的关系" class="headerlink" title="6-3 let/const 和 window 的关系"></a>6-3 let/const 和 window 的关系</h4><p>用 var 声明变量在全局，会在 window 上添加一个属性 let/const 不会再 window 上添加属性</p><p>let/const 声明的变量 在最新规范中，存放到 ve 中 varibles_：VaribleMap 里面</p><p>window 单独由浏览器提供 所以 window 访问不了 let/const 声明的变量</p><h4 id="6-4-块级作用域"><a href="#6-4-块级作用域" class="headerlink" title="6-4 块级作用域"></a>6-4 块级作用域</h4><p><strong>块级作用域：{}中声明的变量只能在{}中使用，es5 中没有块级作用域。</strong></p><p><strong>ES5 中只有两个作用域：全局作用域 函数作用域</strong>。</p><p><strong>es6 中的块级作用域：let/const/function/class 声明的类型有效</strong></p><p><strong>if 语句 switch 语句 for 块级代码的代码块就是块级作用域</strong></p><h2 id="第十三节-ES6-ES12（二）"><a href="#第十三节-ES6-ES12（二）" class="headerlink" title="第十三节 ES6 -ES12（二）"></a>第十三节 ES6 -ES12（二）</h2><h3 id="1-暂时性死区"><a href="#1-暂时性死区" class="headerlink" title="1. 暂时性死区"></a>1. 暂时性死区</h3><p><strong>使用 let/const 声明的变量，在声明之前不可以访问</strong></p><h3 id="2-var-let-const-的选择"><a href="#2-var-let-const-的选择" class="headerlink" title="2. var let const 的选择"></a>2. var let const 的选择</h3><p><strong>实际工作中不用 var 声明变量，推荐使用 let/const，优先使用 const</strong></p><p>能用 const 就用 const</p><h3 id="3-字符串模板"><a href="#3-字符串模板" class="headerlink" title="3. 字符串模板"></a>3. 字符串模板</h3><p><strong>`` 可以优雅的拼接字符串变量</strong></p><pre><code class="js">const name = &quot;why&quot;;const str = `hello$&#123;name&#125;`;console.log(str); // hello why</code></pre><p>也可以在模板字符串中写表达式</p><pre><code class="js">function doubleAge() &#123;  return age * 2;&#125;const str = `hello$&#123;doubleAge()&#125;`;</code></pre><h3 id="4-标签模板字符串"><a href="#4-标签模板字符串" class="headerlink" title="4. 标签模板字符串"></a>4. 标签模板字符串</h3><p>另外一种调用函数的方法</p><pre><code class="js">function foo(m, n) &#123;  console.log(m, n);&#125;foo();//利用标签模板字符串调用函数 基本上很少这样使用// 第一个参数依然是模板字符串中的整个字符串被切成多块 放入一个数组中// 第二个参数是模板字符串中 第一个$&#123;&#125;foo`hello$&#123;name&#125;wro$&#123;age&#125;ld`;</code></pre><h3 id="5-函数参数的默认值"><a href="#5-函数参数的默认值" class="headerlink" title="5. 函数参数的默认值"></a>5. 函数参数的默认值</h3><h4 id="5-1-ES5-中函数参数的默认值："><a href="#5-1-ES5-中函数参数的默认值：" class="headerlink" title="5-1 ES5 中函数参数的默认值："></a>5-1 ES5 中函数参数的默认值：</h4><p>缺点：可读性差写起来麻烦 有 bug</p><pre><code class="js">function foo(m, n) &#123;  m = m || &quot;123&quot;;  n = n || &quot;456&quot;;&#125;</code></pre><h4 id="5-2-ES6-中的函数默认参数"><a href="#5-2-ES6-中的函数默认参数" class="headerlink" title="5-2 ES6 中的函数默认参数"></a>5-2 ES6 中的函数默认参数</h4><pre><code class="js">function foo(m = &quot;123&quot;, n = &quot;456&quot;) &#123;&#125;foo();</code></pre><h4 id="5-3-对象参数和默认值以及解构："><a href="#5-3-对象参数和默认值以及解构：" class="headerlink" title="5-3 对象参数和默认值以及解构："></a>5-3 对象参数和默认值以及解构：</h4><pre><code class="js">function printInfo(&#123; name, age &#125; = &#123; name: &quot;why&quot;, age: 18 &#125;) &#123;  console.log(name, age);&#125;//另一种写法function printInfo(&#123; name = &quot;why&quot;, age = 18 &#125;) &#123;  console.log(name, age);&#125;</code></pre><p><strong>有默认值的形参放到最后</strong></p><h4 id="5-4-有默认值的函数的-length-属性"><a href="#5-4-有默认值的函数的-length-属性" class="headerlink" title="5-4 有默认值的函数的 length 属性"></a>5-4 有默认值的函数的 length 属性</h4><p>有默认值的参数不算在 length 里面包括，这个参数以后的也都不会算在 length 里面</p><h3 id="6-函数的剩余参数"><a href="#6-函数的剩余参数" class="headerlink" title="6. 函数的剩余参数"></a>6. 函数的剩余参数</h3><p>如果最后一个参数是…前缀的，那么它将会将剩余的参数放到数组中</p><pre><code class="js">function foo(m, n, ...args) &#123;  console.log(m, n);  console.log(args);&#125;foo(20, 30, 40, 50, 60);</code></pre><p><strong>剩余参数拿到的是一个真正的数组，可以使用数组的方法</strong></p><h3 id="7-箭头函数"><a href="#7-箭头函数" class="headerlink" title="7. 箭头函数"></a>7. 箭头函数</h3><p>（）=&gt;{ }</p><p>箭头函数没有 prototype 没有显式原型</p><p>没有 arguments 要去上层作用域查找</p><p>没有 this 要去上层作用域查找</p><h3 id="8-展开语法"><a href="#8-展开语法" class="headerlink" title="8. 展开语法"></a>8. 展开语法</h3><p>不仅可以展开数组 也可以展开字符串</p><pre><code class="js">const names = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];const name = &quot;why&quot;;const info = &#123; name: &quot;why&quot;, age: 18 &#125;;//1.函数调用时function foo(x, y, z) &#123;  console.log(x, y, z);&#125;//展开运算符foo(...names);//2. 构造数组时const newNames = [...names, ...name];//3. ES2018 构建对象字面量时使用展开运算符const obj = &#123; ...info, address: &quot;广州市&quot; &#125;;console.log(obj);</code></pre><p><strong>展开运算符其实是进行浅拷贝</strong></p><h3 id="9-数值的表示"><a href="#9-数值的表示" class="headerlink" title="9. 数值的表示"></a>9. 数值的表示</h3><p>ES6 中规范了二进制八进制的方式</p><p>二进制：0b 开头</p><p>八进制：0o 开头</p><p>十六进制：0x 开头</p><p>大的数值连接符 ：10<em>000_000</em></p><h3 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10. Symbol"></a>10. Symbol</h3><h4 id="10-1-Symbol-是什么"><a href="#10-1-Symbol-是什么" class="headerlink" title="10-1 Symbol 是什么"></a>10-1 Symbol 是什么</h4><p><strong>Symbol 是一种基本数据类型，可以生成一个独一无二的值。</strong></p><h4 id="10-2-Es5-中没有-Symbol-类型的弊端"><a href="#10-2-Es5-中没有-Symbol-类型的弊端" class="headerlink" title="10-2 Es5 中没有 Symbol 类型的弊端"></a>10-2 Es5 中没有 Symbol 类型的弊端</h4><p>ES6 之前对象的属性名其实都是字符串类型，容易造成属性名冲突</p><p>ES6 之后对象的属性名可以使用字符串也可以使用 Symbol 值</p><h4 id="10-3-Symbol-的用法"><a href="#10-3-Symbol-的用法" class="headerlink" title="10-3 Symbol 的用法"></a>10-3 Symbol 的用法</h4><pre><code class="js">//第一种写法const s1 = Symbol();const s2 = Symbol();const obj = &#123;  [s1]: &quot;abc&quot;,&#125;;//第二种写法obj[s1] = &quot;nba&quot;;//第三种写法Object.definedProperty(obj, s4, &#123;  enmuerable: true,  configurable: true,  writable: true,  value: &quot;mba&quot;,&#125;);//获取console.log(obj[s1], obj[s2]);</code></pre><h4 id="10-4-怎么获取-Symbol"><a href="#10-4-怎么获取-Symbol" class="headerlink" title="10-4 怎么获取 Symbol"></a>10-4 怎么获取 Symbol</h4><ul><li><p><strong>获取的时候不能通过.语法获取</strong></p></li><li><p>**使用 Symbol 作为 key 的属性名，在遍历/Object.keys 等中是获取不到的 **</p></li><li><p><strong>通过 Object.getownPropertySymbols(obj)获取所有的 Symbol 的 key</strong></p></li><li><p><strong>获取普通属性 Object.getOwnPropertyNames(obj)或者 Object.keys（）</strong></p></li></ul><h4 id="10-5-遍历-Symbol"><a href="#10-5-遍历-Symbol" class="headerlink" title="10-5 遍历 Symbol"></a>10-5 遍历 Symbol</h4><ul><li><p><strong>遍历方式</strong>：</p></li><li><ol><li><p>const sKeys=Object.getownPropertySymbols(obj)</p></li><li><p>for（const skey of sKeys）{</p><p>console.log(obj[sKey]）</p><p>}</p></li></ol></li></ul><h4 id="10-6-Symbol-for（）-Symbol-keyfor"><a href="#10-6-Symbol-for（）-Symbol-keyfor" class="headerlink" title="10-6 Symbol.for（）/Symbol.keyfor"></a>10-6 Symbol.for（）/Symbol.keyfor</h4><p>在某些情况下创建一样的 Symbol 值</p><ul><li>Symbol.for（key）</li></ul><p>const sa=Symbol.for(‘aaa’);</p><p>const sb=Symbol.for(‘aaa’)</p><p>获取 Symbol</p><ul><li>Symbol.keyFor(symbol 值)</li></ul><p>const key= Symbol.keyFor(sa)</p><p>console.log(key)</p><p>const sc=Symbol.for(key)</p><p>console.log(sa===sc)</p><h2 id="第十四节-ES6-ES12（三）"><a href="#第十四节-ES6-ES12（三）" class="headerlink" title="第十四节 ES6 -ES12（三）"></a>第十四节 ES6 -ES12（三）</h2><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><h4 id="在-ES6-之前我们想存储数据只有-数组或者对象两种结构"><a href="#在-ES6-之前我们想存储数据只有-数组或者对象两种结构" class="headerlink" title="在 ES6 之前我们想存储数据只有 数组或者对象两种结构"></a><strong>在 ES6 之前我们想存储数据只有 数组或者对象两种结构</strong></h4><h4 id="ES6-给我们增加了-Set-Map-两种数据结构以及它们的另外形式-WeakSet-WeakMap"><a href="#ES6-给我们增加了-Set-Map-两种数据结构以及它们的另外形式-WeakSet-WeakMap" class="headerlink" title="ES6 给我们增加了 Set Map 两种数据结构以及它们的另外形式 WeakSet WeakMap"></a><strong>ES6 给我们增加了 Set Map 两种数据结构以及它们的另外形式 WeakSet WeakMap</strong></h4><h4 id="数据结构：存放数据的方式"><a href="#数据结构：存放数据的方式" class="headerlink" title="数据结构：存放数据的方式"></a><strong>数据结构：存放数据的方式</strong></h4><h4 id="1-1-Set-是什么"><a href="#1-1-Set-是什么" class="headerlink" title="1-1 Set 是什么"></a>1-1 Set 是什么</h4><ul><li>Set 是一个新增的数据结构，可以用来保存数据类似于数组但是和数组的区别是**<font color="red">元素不能重复</font>**</li></ul><h4 id="1-2-创建-Set-结构"><a href="#1-2-创建-Set-结构" class="headerlink" title="1-2 创建 Set 结构"></a>1-2 创建 Set 结构</h4><pre><code class="js">const set = new Set();set.add(10);set.add(20);set.add(30);set.add(40);console.log(set);</code></pre><h4 id="1-3-添加对象是特别注意"><a href="#1-3-添加对象是特别注意" class="headerlink" title="1-3 添加对象是特别注意"></a>1-3 添加对象是特别注意</h4><p><img src="/2022/021964822/image-20220117174405341.png"></p><ul><li>第一个添加会输出打印两个 {} 因为创建了两个不同的对象在内存中</li><li>第二个只会输出一个{} 因为添加的是同一个对象</li></ul><h4 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1-4 应用场景"></a>1-4 应用场景</h4><ul><li><p>对数组去重（去除重复元素）</p><pre><code class="js">const arr=[33,10,26,30,33,26]const arrSet=new Set(arr)//再将Set结构转为数组结构const newArr=Array.from(arrSet) 或者 newArr=[...arrSet]</code></pre></li></ul><h4 id="1-5-Set-常见属性方法"><a href="#1-5-Set-常见属性方法" class="headerlink" title="1-5 Set 常见属性方法"></a>1-5 Set 常见属性方法</h4><ul><li><p>size 属性返回对应 Set 结构的数量</p><p>.size</p></li><li><p>add（）方法 添加</p></li><li><p>delete（元素）删除某个元素</p></li><li><p>has（元素）判断有没有这个元素 返回布尔值</p></li><li><p>clear（）清空 set 结构</p></li></ul><h4 id="1-6-遍历-Set"><a href="#1-6-遍历-Set" class="headerlink" title="1-6 遍历 Set"></a>1-6 遍历 Set</h4><ul><li>通过 forEach 遍历 arrSet.forEach（）</li><li>通过 for of 遍历 set</li></ul><h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><p><strong>内部的元素也是不能重复</strong></p><h4 id="2-1-与-Set-区别"><a href="#2-1-与-Set-区别" class="headerlink" title="2-1 与 Set 区别"></a>2-1 与 Set 区别</h4><ul><li><strong>WeakSet 只能存放对象类型不能存放基本数据类型</strong></li><li><strong>WeakSet 对对象是弱引用</strong></li></ul><h4 id="2-2-WeakSet-的方法"><a href="#2-2-WeakSet-的方法" class="headerlink" title="2-2 WeakSet 的方法"></a>2-2 WeakSet 的方法</h4><ul><li>add(value):添加某个元素，返回 WeakSet 对象本身</li><li>delete（value）：从 WeakSet 中删除和这个值相等的元素，返回布尔值</li><li>has（value）：判断 WeakSet 中是否存在某个元素，返回布尔值</li></ul><h4 id="注意：-WeakSet-不能遍历！！！"><a href="#注意：-WeakSet-不能遍历！！！" class="headerlink" title="注意： WeakSet 不能遍历！！！"></a>注意： WeakSet 不能遍历！！！</h4><h4 id="2-3-WeakSet-应用场景"><a href="#2-3-WeakSet-应用场景" class="headerlink" title="2-3 WeakSet 应用场景"></a>2-3 WeakSet 应用场景</h4><p><img src="/2022/021964822/image-20220117181856580.png"></p><h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h3><p>用于存储映射关系可以以对象作为 key 也可以使用基本数据类型作为 key</p><h4 id="3-1-和对象储存映射关系的区别"><a href="#3-1-和对象储存映射关系的区别" class="headerlink" title="3-1 和对象储存映射关系的区别"></a>3-1 和对象储存映射关系的区别</h4><ul><li>JS 中对象不能使用对象作为 key 的</li><li>Map 中可以用对象作为 key</li></ul><h4 id="3-2-Map-的创建"><a href="#3-2-Map-的创建" class="headerlink" title="3-2 Map 的创建"></a>3-2 Map 的创建</h4><pre><code class="js">//第一种创建方法const map = new Map();map.set(obj1, &quot;aaa&quot;);map.set(obj2, &quot;bbb&quot;);map.set(obj3, &quot;ccc&quot;);//第二种创建方法const map2 = new Map([  [obj1, &quot;aaaa&quot;],  [obj2, &quot;bbb&quot;],  [obj3, &quot;ccc&quot;],]);</code></pre><h4 id="3-3-Map-常见属性和方法"><a href="#3-3-Map-常见属性和方法" class="headerlink" title="3-3 Map 常见属性和方法"></a>3-3 Map 常见属性和方法</h4><p>属性:</p><ul><li>size 属性 Map 结构有多少元素</li></ul><p>方法:</p><ul><li>set()方法 用于给 Map 结构添加元素</li><li>get()方法 get(key) 传入 key 值获取属性值</li><li>has() 判断某一个 key 是否存在</li><li>delete() 删除某一个元素 返回布尔值</li><li>clear() 清除 Map 结构</li></ul><p>遍历 Map：</p><ul><li><p>foreach 来遍历</p><p>map.forEach()</p></li><li><p>for of 遍历</p><p>for（const item of map2){</p><p>​ 这里边 item 是个数组</p><p>}</p><p>可以使用解构</p><p>for（const[key, valeu] of map2）{</p><p>​</p><p>}</p></li></ul><h3 id="4-Weakmap"><a href="#4-Weakmap" class="headerlink" title="4. Weakmap"></a>4. Weakmap</h3><p><strong>WeakMap 不能进行遍历</strong></p><h4 id="4-1-WeakMap-是什么"><a href="#4-1-WeakMap-是什么" class="headerlink" title="4-1 WeakMap 是什么"></a>4-1 WeakMap 是什么</h4><ul><li>和 Map 类型相似的另一哥数据结构称之为 WeakMap，也是以键值对的形式存在</li></ul><h4 id="4-2-和-Map-的区别"><a href="#4-2-和-Map-的区别" class="headerlink" title="4-2 和 Map 的区别"></a>4-2 和 Map 的区别</h4><ul><li>key 只能是对象不能设置基本数据类型</li><li>WeakMap 里的对象的引用是弱引用</li></ul><h4 id="4-3-WeakMap-常见方法"><a href="#4-3-WeakMap-常见方法" class="headerlink" title="4-3 WeakMap 常见方法"></a>4-3 WeakMap 常见方法</h4><ul><li>get()方法 get(key) 传入 key 值获取属性值</li><li>has() 判断某一个 key 是否存在</li><li>delete() 删除某一个元素 返回布尔值</li></ul><h4 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4-4 应用场景"></a>4-4 应用场景</h4><p>Vue3 中的响应式原理</p><h3 id="5-ES7-Array-Includes"><a href="#5-ES7-Array-Includes" class="headerlink" title="5. ES7 -Array Includes"></a>5. ES7 -Array Includes</h3><p>判断数组中是否包含某个元素 返回值是布尔值</p><p>可以判断数组是否存在 NaN 元素</p><p>arr.includes(元素，元素所在的位置)</p><pre><code class="js">const arr = [12, 45, 6];arr.includes(12);</code></pre><h3 id="6-ES7-指数运算符"><a href="#6-ES7-指数运算符" class="headerlink" title="6. ES7 - 指数运算符"></a>6. ES7 - 指数运算符</h3><p>const result=3 ** 3 等于 3 的平方</p><p>** 指数运算符</p><h2 id="第十五节-ES6-ES12（四）"><a href="#第十五节-ES6-ES12（四）" class="headerlink" title="第十五节 ES6-ES12（四）"></a>第十五节 ES6-ES12（四）</h2><p>node 版本低会导致不支持某些语法运行</p><h3 id="1-ES8-Object-values"><a href="#1-ES8-Object-values" class="headerlink" title="1. ES8- Object.values()"></a>1. ES8- Object.values()</h3><p>获取所有的 value 值</p><p>Object.keys()获取所有的 key 值</p><h3 id="2-ES8-Object-entries"><a href="#2-ES8-Object-entries" class="headerlink" title="2. ES8 - Object.entries"></a>2. ES8 - Object.entries</h3><p>通过 Object.entries()可以获取到一个数组，数组中会存放可枚举属性的键值对数组。</p><h3 id="3-ES8-String-Padding-字符串填充"><a href="#3-ES8-String-Padding-字符串填充" class="headerlink" title="3. ES8 - String Padding 字符串填充"></a>3. ES8 - String Padding 字符串填充</h3><ul><li><p>从字符串前边填充 padStart（第一个参数代表填充完字符串的长度，第二个参数填充的内容）</p><pre><code class="js">const mess = &quot;hello world&quot;;mess.padStart();</code></pre></li><li><p>从字符串末尾填充 padEnd（第一个参数代表填充完字符串的长度，第二个参数填充的内容）</p><pre><code class="js">const mess = &quot;hello world&quot;;mess.padEnd();</code></pre></li></ul><h3 id="4-ES8-Object-Descriptors"><a href="#4-ES8-Object-Descriptors" class="headerlink" title="4. ES8 - Object Descriptors"></a>4. ES8 - Object Descriptors</h3><ul><li>Object.getOwnPropertyDescriptors 获取对象所有的属性描述符</li></ul><h3 id="5-ES10-flat-flatMap"><a href="#5-ES10-flat-flatMap" class="headerlink" title="5. ES10 - flat flatMap"></a>5. ES10 - flat flatMap</h3><ul><li><p>flat（） 将数组进行降维 比如数组里有二维数组会降成一维 参数是降为的次数</p><pre><code class="js">const arr = [10, 2, [5, 5], [[3, 5], [68]], 99];const nar = arr.flat(1); //降维一次const nsarr = arr.flat(2); //降维两次</code></pre></li><li><p>flatMap（）方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组</p><p>注意：1.flatMap 先进行 map 操作，在做 flat 操作</p><p>​ 2.flatMap 中的 flat 相当于深度为 1</p><pre><code class="js">const num = [10, 20, 30];num.flatMap((item) =&gt; &#123;  return item * 2;&#125;);</code></pre></li></ul><h3 id="6-ES10-Object-fromEntries"><a href="#6-ES10-Object-fromEntries" class="headerlink" title="6. ES10 - Object.fromEntries"></a>6. ES10 - Object.fromEntries</h3><p>将 entries 格式的转为对象</p><pre><code class="js">const entries = &#123;name：&#39;why&#39;&#125;const n=Object.entries(entries);const z=Object.fromEntries(n)</code></pre><h3 id="7-ES10-trimStart-trimEnd"><a href="#7-ES10-trimStart-trimEnd" class="headerlink" title="7. ES10 - trimStart trimEnd"></a>7. ES10 - trimStart trimEnd</h3><ul><li>trimStart（） 去除首部空格</li><li>trimEnd（）去除尾部空格</li></ul><h3 id="8-ES11-BigInt"><a href="#8-ES11-BigInt" class="headerlink" title="8. ES11 - BigInt"></a>8. ES11 - BigInt</h3><p>BigInt 基本数据类型 大的整数</p><p>ES11 之前 JS 中不能正确的表示过大的数字</p><pre><code class="js">BigInt(要转成大整数的数字);const bigInt = 90071992547099100n; //加上这个n就是BigInt类型//BigInt类型相加必须是同类型</code></pre><h3 id="9-ES11-Nullish-Coalescing-operator"><a href="#9-ES11-Nullish-Coalescing-operator" class="headerlink" title="9. ES11 - Nullish-Coalescing-operator"></a>9. ES11 - Nullish-Coalescing-operator</h3><p>空值合并运算符： ？？</p><pre><code class="js">const foo=undefined；const bar=foo？？&quot;defualt value&quot;当foo的值为null或undefined才有效 bar为default value</code></pre><h3 id="10-ES11-Optional-Chaining"><a href="#10-ES11-Optional-Chaining" class="headerlink" title="10. ES11 - Optional Chaining"></a>10. ES11 - Optional Chaining</h3><p>可选链：让我们代码在进行 null 和 undefined 进行判断的时候更简洁</p><p>语法：？. 如果调用的值为 undefined 就直接返回 undefined</p><h3 id="11-ES11-globalThis"><a href="#11-ES11-globalThis" class="headerlink" title="11. ES11- globalThis"></a>11. ES11- globalThis</h3><p>获取某一个环境下的全局对象：globalThis</p><h3 id="12-ES12-FinalizationRegistry-类"><a href="#12-ES12-FinalizationRegistry-类" class="headerlink" title="12. ES12 - FinalizationRegistry 类"></a>12. ES12 - FinalizationRegistry 类</h3><p>当被销毁掉是触发某些函数</p><p><img src="/2022/021964822/image-20220118181304720.png"></p><h3 id="13-ES12-WeakRef-类"><a href="#13-ES12-WeakRef-类" class="headerlink" title="13. ES12 - WeakRef 类"></a>13. ES12 - WeakRef 类</h3><p>如果我们想让对象是弱引用就可以使用 WeakRef 类</p><p>new WeakRef(绑定的对象)</p><p>通过 deref（）获取原来对象的属性</p><p><img src="/2022/021964822/image-20220118183020139.png"></p><p><img src="/2022/021964822/image-20220118182831974.png"></p><h3 id="14-ES12-logical-assgin-operator-逻辑赋值运算符"><a href="#14-ES12-logical-assgin-operator-逻辑赋值运算符" class="headerlink" title="14. ES12 - logical-assgin-operator 逻辑赋值运算符"></a>14. ES12 - logical-assgin-operator 逻辑赋值运算符</h3><ul><li><p>||= 逻辑或赋值运算</p><pre><code class="js">let message = undefined;message ||= &quot;default value&quot;;</code></pre></li><li><p>&amp;&amp;=逻辑与赋值运算</p><pre><code class="js">let info = &#123;  name: &quot;why&quot;,&#125;;info &amp;&amp;= info.name;</code></pre></li><li><p>??= 逻辑空赋值运算</p><pre><code class="js">let message = &quot;&quot;;//如果message为空 就赋值为default valuemessage ??= &quot;default value&quot;;</code></pre></li></ul><h3 id="15-String-replaceAll-字符串替换"><a href="#15-String-replaceAll-字符串替换" class="headerlink" title="15. String.replaceAll 字符串替换"></a>15. String.replaceAll 字符串替换</h3><h2 id="第十六节-Proxy-Reflect-Vue2-vue3-的响应式原理"><a href="#第十六节-Proxy-Reflect-Vue2-vue3-的响应式原理" class="headerlink" title="第十六节 Proxy Reflect Vue2-vue3 的响应式原理"></a>第十六节 Proxy Reflect Vue2-vue3 的响应式原理</h2><h3 id="1-Proxy-代理"><a href="#1-Proxy-代理" class="headerlink" title="1. Proxy 代理"></a>1. Proxy 代理</h3><h4 id="1-1-proxy-的使用"><a href="#1-1-proxy-的使用" class="headerlink" title="1-1 proxy 的使用"></a>1-1 proxy 的使用</h4><p>Proxy 是一个类</p><p>new Proxy(侦听的对象，捕获器{})</p><pre><code class="js">const obj=&#123;    name：&#39;why&#39;,    age:18&#125;const a= new Proxy(obj,&#123;    get:function(target,key,receiver)&#123;    &#125;, set:function(target,key,newvalue,reciver)&#123;    &#125;&#125;)</code></pre><p><img src="/2022/021964822/image-20220120112811046.png"></p><h4 id="1-2-Proxy-的捕获器"><a href="#1-2-Proxy-的捕获器" class="headerlink" title="1-2 Proxy 的捕获器"></a>1-2 Proxy 的捕获器</h4><ul><li><p>get 函数：获取值时的捕获器</p><ol><li>target：目标对象（侦听的对象）</li><li>property：被获取的属性 key</li><li>reciver：调用的代理对象</li></ol></li><li><p>set 函数：设置值时的捕获器</p><ol><li>target：目标对象（侦听的对象）</li><li>property：被获取的属性 key</li><li>value：新属性值</li><li>reciver：调用的代理对象</li></ol></li><li><p>has 函数：监听 in 的捕获器</p><ol><li><p>target：目标对象（侦听的对象）</p></li><li><p>property：被获取的属性 key</p></li></ol></li><li><p>deleteProperty 函数：监听 delete 的捕获器</p><ol><li><p>target：目标对象（侦听的对象）</p></li><li><p>property：被获取的属性 key</p></li></ol></li></ul><h4 id="1-3-Proxy-所有的捕获器"><a href="#1-3-Proxy-所有的捕获器" class="headerlink" title="1-3 Proxy 所有的捕获器"></a>1-3 Proxy 所有的捕获器</h4><p><img src="/2022/021964822/image-20220120114558665.png"></p><h4 id="1-4-reciver-参数的作用"><a href="#1-4-reciver-参数的作用" class="headerlink" title="1-4 reciver 参数的作用"></a>1-4 reciver 参数的作用</h4><h3 id="2-Reflect"><a href="#2-Reflect" class="headerlink" title="2. Reflect"></a>2. Reflect</h3><p><strong>注意：使用 Reflect 的方法会返回布尔值</strong></p><h4 id="2-1-Reflect-的作用"><a href="#2-1-Reflect-的作用" class="headerlink" title="2-1 Reflect 的作用"></a>2-1 Reflect 的作用</h4><p><strong>它是一个对象，字面意思是反射</strong></p><ul><li>提供了很多操作 JS 对象的方法，有点像 Object 中操作对象的方法</li><li>比如 Reflect.getPrototypeOf（target）类似于 Object.getPrototypeOf（）</li></ul><h4 id="2-2-为什么要有-Reflect"><a href="#2-2-为什么要有-Reflect" class="headerlink" title="2-2 为什么要有 Reflect"></a>2-2 为什么要有 Reflect</h4><ul><li>早起 ESMA 规范没有考虑到对对象本身的操作如何设计会更加规范，所以将这些 API 放到 Object 上</li><li>但是 Object 作为一个构造函数这些操作放在上边不合适</li><li>所以新增 Reflect ，让我们把这些操作集中到 Reflect 对象上</li></ul><h4 id="2-3-Reflect-常见方法"><a href="#2-3-Reflect-常见方法" class="headerlink" title="2-3 Reflect 常见方法"></a>2-3 Reflect 常见方法</h4><p><img src="/2022/021964822/image-20220120120124697.png"></p><h4 id="2-4-Reflect-结合-Proxy-的使用"><a href="#2-4-Reflect-结合-Proxy-的使用" class="headerlink" title="2-4 Reflect 结合 Proxy 的使用"></a>2-4 Reflect 结合 Proxy 的使用</h4><pre><code class="js">const obj = &#123;  name: &quot;why&quot;,  age: 18,&#125;;const objProxy = new Proxy(obj, &#123;  get: function (target, key, recevier) &#123;    return Reflect.get(target, key);  &#125;,  set: function (target, key, newValue, receiver) &#123;    Reflect.set(target, key, newValue);  &#125;,&#125;);</code></pre><h3 id="3-响应式原理（学完-vue-自己在重新过来看视频-17-节-）"><a href="#3-响应式原理（学完-vue-自己在重新过来看视频-17-节-）" class="headerlink" title="3. 响应式原理（学完 vue 自己在重新过来看视频 17 节 ）"></a>3. 响应式原理（学完 vue 自己在重新过来看视频 17 节 ）</h3><p>当我们的变量发生改变时自动重新执行代码。</p><h2 id="第十七节-Promise"><a href="#第十七节-Promise" class="headerlink" title="第十七节 Promise"></a>第十七节 Promise</h2><h3 id="1-Promise-是什么"><a href="#1-Promise-是什么" class="headerlink" title="1. Promise 是什么"></a>1. Promise 是什么</h3><ul><li>是一个类。</li><li>需要给调用者一个承诺：待会给你回调数据时，就可以创建一个 Promise 的对象</li><li>通过 new 创建 Promise 对象</li></ul><h3 id="2-Promise-的使用"><a href="#2-Promise-的使用" class="headerlink" title="2. Promise 的使用"></a>2. Promise 的使用</h3><pre><code class="js">//Promise（（）=》&#123;&#125;）里的这个函数会在调用时自动执行//resolve ：成功时调用//reject：失败时调用const npromise = new Promise((resolve, reject) =&gt; &#123;  resolve();  reject();&#125;);//成功时的回调npromise.then(() =&gt; &#123;&#125;);//失败时的回调npromise.catch(() =&gt; &#123;&#125;);</code></pre><p><img src="/2022/021964822/image-20220125171001785.png"></p><h3 id="3-Promise-中的状态"><a href="#3-Promise-中的状态" class="headerlink" title="3. Promise 中的状态"></a>3. Promise 中的状态</h3><p><img src="/2022/021964822/image-20220125173338143.png"></p><p><strong>状态一旦确定就不可更改！！！</strong></p><h3 id="4-Promise-的-resolve-参数"><a href="#4-Promise-的-resolve-参数" class="headerlink" title="4. Promise 的 resolve 参数"></a>4. Promise 的 resolve 参数</h3><h4 id="4-1-reslove-参数传入普通值或对象"><a href="#4-1-reslove-参数传入普通值或对象" class="headerlink" title="4-1 reslove 参数传入普通值或对象"></a>4-1 reslove 参数传入普通值或对象</h4><p>Pending 状态–》fuifilled</p><h4 id="4-2-reslove-参数传入一个-Promise"><a href="#4-2-reslove-参数传入一个-Promise" class="headerlink" title="4-2 reslove 参数传入一个 Promise"></a>4-2 reslove 参数传入一个 Promise</h4><p>那么当前的 Promise 状态会由传入的 Promise 来决定，相当于状态进行了移交</p><pre><code class="js">new Promise((reslove, reject) =&gt; &#123;  //由这里的promise参数里的状态决定外面  reslove(新的Promise);&#125;)  .then((res) =&gt; &#123;&#125;)  .catch((err) =&gt; &#123;&#125;);</code></pre><h4 id="4-3-reslove-参数传入一个对象这个对象本身具有-then-方法"><a href="#4-3-reslove-参数传入一个对象这个对象本身具有-then-方法" class="headerlink" title="4-3 reslove 参数传入一个对象这个对象本身具有 then 方法"></a>4-3 reslove 参数传入一个对象这个对象本身具有 then 方法</h4><p>那么也会执行该 then 方法</p><h2 id="第十八节-Promise-中-then-以及实现-Promise"><a href="#第十八节-Promise-中-then-以及实现-Promise" class="headerlink" title="第十八节 Promise 中 then 以及实现 Promise"></a>第十八节 Promise 中 then 以及实现 Promise</h2><h3 id="1-Promise-有哪些对象方法"><a href="#1-Promise-有哪些对象方法" class="headerlink" title="1. Promise 有哪些对象方法"></a>1. Promise 有哪些对象方法</h3><ul><li>then（）</li><li>catch（）</li><li>finally（）</li></ul><h3 id="2-then（）方法"><a href="#2-then（）方法" class="headerlink" title="2. then（）方法"></a>2. then（）方法</h3><ul><li><strong>同一个 Promise 可以被多次调用 then 方法</strong></li></ul><pre><code class="js">promise.then(() =&gt; &#123;&#125;);promise.then(() =&gt; &#123;&#125;);promise.then(() =&gt; &#123;&#125;);</code></pre><ul><li><p>then 方法传入的回调函数可以有返回值 <strong>它的返回值是 Promise</strong></p><ol><li><p>如果我们返回的是一个普通值（数字/字符串/对象/undefined），那么这个普通的值被作为一个新的 Promise 的 resolve 值</p></li><li><p>如果返回的是一个 Promise</p><p><img src="/2022/021964822/image-20220125214908799.png"></p></li><li><p>如果返回的是一个对象 并且该对象实现了 thenable</p><p><img src="/2022/021964822/image-20220125215055280.png"></p></li></ol></li></ul><h3 id="3-catch-方法"><a href="#3-catch-方法" class="headerlink" title="3. catch()方法"></a>3. catch()方法</h3><ul><li>当 exxecutor 抛出异常时，也是会调用错误捕获的回调函数的</li><li>then 方法有两个参数第二个参数就是错误回调函数</li><li>通过 catch 方法传入错误捕获的回调函数</li></ul><h3 id="4-finally（）方法"><a href="#4-finally（）方法" class="headerlink" title="4. finally（）方法"></a>4. finally（）方法</h3><p>ES9 中增加的</p><p><strong>无论 Promise 对象变成 fulfilled 状态 还是 rejected 状态都会执行的代码</strong></p><ul><li>回调函数没有参数</li></ul><h3 id="5-Promise-类方法"><a href="#5-Promise-类方法" class="headerlink" title="5. Promise 类方法"></a>5. Promise 类方法</h3><ul><li><p>Promise.resolve（） 相当于 const promise2=new Promise（（resolve，reject）=&gt;{resolve({name:”why”})}）</p></li><li><p>Promise.reject() 方法 直接让 Promise 对象 rejected 状态 <strong>这里无论传入什么值都是一样的</strong></p></li><li><p>Promise.all([]) 创建多个 Promise 当所有的 Promise 都是 fulfilled 的话执行 reslove 但是有一个为 rreject 的话就都为 rejected</p></li><li><p>Promise.allSettled([]) 无论是 fulfilled 还是 rejected 时都会有一个结果</p></li><li><p>Promise.race([]) 只要有一个 promise 编程 fulfilled 状态就结束</p></li><li><p>Promise.any([]) 至少等到一个状态变成 fulfilled 状态</p></li></ul><h2 id="第十九节-Promise-手写"><a href="#第十九节-Promise-手写" class="headerlink" title="第十九节 Promise 手写"></a>第十九节 Promise 手写</h2><h3 id="简单总结手写-Promise"><a href="#简单总结手写-Promise" class="headerlink" title="简单总结手写 Promise"></a>简单总结手写 Promise</h3><h4 id="一-Promise-规范"><a href="#一-Promise-规范" class="headerlink" title="一. Promise 规范"></a>一. Promise 规范</h4><ul><li><a href="https://promisesaplus.com/">https://promisesaplus.com/</a></li></ul><h4 id="二-Promise-类设计"><a href="#二-Promise-类设计" class="headerlink" title="二. Promise 类设计"></a>二. Promise 类设计</h4><pre><code class="js">class HYPromise &#123;&#125;</code></pre><pre><code class="js">function HYPromise() &#123;&#125;</code></pre><h4 id="三-构造函数的规划"><a href="#三-构造函数的规划" class="headerlink" title="三. 构造函数的规划"></a>三. 构造函数的规划</h4><pre><code class="js">class HYPromise &#123; constructor(*executor*) &#123;  *// 定义状态*  *// 定义resolve、reject回调*  *// resolve执行微任务队列：改变状态、获取value、then传入执行成功回调*  *// reject执行微任务队列：改变状态、获取reason、then传入执行失败回调*  *// try catch*  executor(resolve, reject) &#125;&#125;</code></pre><h4 id="四-then-方法的实现"><a href="#四-then-方法的实现" class="headerlink" title="四. then 方法的实现"></a>四. then 方法的实现</h4><pre><code class="js">class HYPromise &#123; then(*onFulfilled*, *onRejected*) &#123;  *// this.onFulfilled = onFulfilled*  *// this.onRejected = onRejected*  *// 1.判断onFulfilled、onRejected，会给默认值*  *// 2.返回Promise resolve/reject*  *// 3.判断之前的promise状态是否确定*  *// onFulfilled/onRejected直接执行（捕获异常）*  *// 4.添加到数组中push(() =&gt; &#123; 执行 onFulfilled/onRejected 直接执行代码&#125;)* &#125;&#125;</code></pre><h4 id="五-catch-方法"><a href="#五-catch-方法" class="headerlink" title="五. catch 方法"></a>五. catch 方法</h4><pre><code class="js">class HYPromise &#123; catch(*onRejected*) &#123;  return this.then(undefined, onRejected) &#125;&#125;</code></pre><h4 id="六-finally"><a href="#六-finally" class="headerlink" title="六. finally"></a>六. finally</h4><pre><code class="js">class HYPromise &#123; finally(*onFinally*) &#123;  return this.then(() =&gt; &#123;onFinally()&#125;, () =&gt; &#123;onFinally()&#125;) &#125;&#125;</code></pre><h4 id="七-resolve-reject"><a href="#七-resolve-reject" class="headerlink" title="七. resolve/reject"></a>七. resolve/reject</h4><h4 id="八-all-allSettled"><a href="#八-all-allSettled" class="headerlink" title="八. all/allSettled"></a>八. all/allSettled</h4><p>核心：要知道 new Promise 的 resolve、reject 在什么情况下执行</p><p>all：</p><ul><li><p>情况一：所有的都有结果</p></li><li><p>情况二：有一个 reject</p></li></ul><p>allSettled：</p><ul><li>情况：所有都有结果，并且一定执行 resolve</li></ul><h4 id="九-race-any"><a href="#九-race-any" class="headerlink" title="九.race/any"></a>九.race/any</h4><p>race:</p><ul><li>情况：只要有结果</li></ul><p>any:</p><ul><li><p>情况一：必须等到一个 resolve 结果</p></li><li><p>情况二：都没有 resolve，所有的都是 reject</p></li></ul><h2 id="第二十节-iterator-迭代器-generator-生成器"><a href="#第二十节-iterator-迭代器-generator-生成器" class="headerlink" title="第二十节 iterator 迭代器 generator 生成器"></a>第二十节 iterator 迭代器 generator 生成器</h2><h3 id="1-迭代器-iterator"><a href="#1-迭代器-iterator" class="headerlink" title="1.迭代器 iterator"></a>1.迭代器 iterator</h3><p><strong>JS 中迭代器是一个具体的对象，这个对象需要符合迭代器协议</strong></p><p><strong>迭代器是帮助我们对某个数据结构进行遍历的对象</strong></p><h4 id="1-1-迭代器协议-（iterator-protocaol）"><a href="#1-1-迭代器协议-（iterator-protocaol）" class="headerlink" title="1-1 迭代器协议 （iterator protocaol）"></a>1-1 迭代器协议 （iterator protocaol）</h4><ul><li><p>要有一个 next 方法无参数函数或者一个参数 返回一个对象</p></li><li><p>返回的对象 中具有 done：boolean 属性和 value</p></li></ul><h4 id="1-2-可迭代对象"><a href="#1-2-可迭代对象" class="headerlink" title="1-2 可迭代对象"></a>1-2 可迭代对象</h4><ul><li>当一个对象实现了 iterable protocol 协议时它就是可迭代对象</li></ul><h4 id="1-3-内置可迭代对象"><a href="#1-3-内置可迭代对象" class="headerlink" title="1-3 内置可迭代对象"></a>1-3 内置可迭代对象</h4><ul><li>数组</li><li>函数中的 arguments</li><li>set/map</li><li>String</li><li>NodeList 集合 拿到的 dom 元素</li></ul><h4 id="1-4-可迭代对象的应用场景"><a href="#1-4-可迭代对象的应用场景" class="headerlink" title="1-4 可迭代对象的应用场景"></a>1-4 可迭代对象的应用场景</h4><p><img src="/2022/021964822/image-20220203200507257.png"></p><h4 id="1-5-迭代器的中断"><a href="#1-5-迭代器的中断" class="headerlink" title="1-5 迭代器的中断"></a>1-5 迭代器的中断</h4><p><img src="/2022/021964822/image-20220203212906534.png"></p><h3 id="2-生成器-generator"><a href="#2-生成器-generator" class="headerlink" title="2. 生成器 generator"></a>2. 生成器 generator</h3><h4 id="2-1-什么是生成器"><a href="#2-1-什么是生成器" class="headerlink" title="2-1 什么是生成器"></a>2-1 什么是生成器</h4><ul><li>生成器是 ES6 中新增的一种<strong>函数控制、使用</strong>的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。</li></ul><h4 id="2-2-生成器函数"><a href="#2-2-生成器函数" class="headerlink" title="2-2 生成器函数"></a>2-2 生成器函数</h4><ul><li>生成器函数也是一个函数</li><li>需要在 function 后面加个*</li><li>生成器函数可以通过 yield 关键字来控制函数的执行流程在哪里要停掉就加 yield</li><li>生成器函数返回值是一个生成器 Generator 对象</li><li>要返回的值在 yield 后面跟上值就可以返回</li></ul><h4 id="2-3-生成器的其他方法使用"><a href="#2-3-生成器的其他方法使用" class="headerlink" title="2-3 生成器的其他方法使用"></a>2-3 生成器的其他方法使用</h4><ul><li><p>生成器上的 next（）可以传递参数 但是要在前一段的 yield 接收参数</p><p><img src="/2022/021964822/image-20220203215905754.png"></p></li><li><p>生成器的 return 方法 return（） 终止方法</p><p><img src="/2022/021964822/image-20220203220421536.png"></p></li><li><p>生成器抛出异常 throw（）方法抛出异常</p><p><img src="/2022/021964822/image-20220205102053916.png"></p></li></ul><h2 id="第二十一节-asnyc-await"><a href="#第二十一节-asnyc-await" class="headerlink" title="第二十一节 asnyc await"></a>第二十一节 asnyc await</h2><h3 id="1-生成器代替迭代器"><a href="#1-生成器代替迭代器" class="headerlink" title="1. 生成器代替迭代器"></a>1. 生成器代替迭代器</h3><h4 id="1-1-第一种写法"><a href="#1-1-第一种写法" class="headerlink" title="1-1 第一种写法"></a>1-1 第一种写法</h4><p><img src="/2022/021964822/image-20220205102544952.png"></p><h4 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1-2 第二种写法"></a>1-2 第二种写法</h4><p>yield* 可迭代对象</p><p><img src="/2022/021964822/image-20220205102829211.png"></p><h3 id="2-异步代码处理方案"><a href="#2-异步代码处理方案" class="headerlink" title="2. 异步代码处理方案"></a>2. 异步代码处理方案</h3><pre><code class="js">function requestData(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(url);    &#125;, 2000);  &#125;);&#125;// 第一种方案  回调地域  多次回调// requestData(&#39;nhn&#39;).then((res) =&gt; &#123;//     console.log(res);//     requestData(res + &#39;aaa&#39;).then((res) =&gt; &#123;//         console.log(res);//         requestData(res + &#39;bbb&#39;).then((res) =&gt; &#123;//             console.log(res);//         &#125;)//     &#125;)// &#125;)// 第二种方案   Promise的then 的返回值解决// requestData(&#39;nhn&#39;).then((res) =&gt; &#123;//     return requestData(res + &#39;aaa&#39;)// &#125;).then((res) =&gt; &#123;//     return requestData(res + &#39;bbb&#39;)// &#125;).then((res) =&gt; &#123;//     console.log(res);// &#125;)// 第三种方案  Promise 和generator 解决// function* getData() &#123;//     const res1 = yield requestData(&#39;why&#39;)//     const res2 = yield requestData(res1 + &#39;aaa&#39;)//     const res3 = yield requestData(res2 + &#39;bbb&#39;)//     console.log(res3);// &#125;// const generator = getData()// generator.next().value.then(res =&gt; &#123;//     generator.next(res).value.then(res =&gt; &#123;//         generator.next(res).value.then(res =&gt; &#123;//             generator.next(res)//         &#125;)//     &#125;)// &#125;)// 自动化递归调用getdata// npm上有一个函数包  co// function execgenerator(fn) &#123;//     const generator = fn();//     function exec(res) &#123;//         const result = generator.next(res);//         if (result.done) return result.value//         result.value.then(res =&gt; &#123;//             exec(res);//         &#125;)//     &#125;//     exec()// &#125;// execgenerator(getData)// 第四种 方案  async/awaitasync function getData() &#123;  const res1 = await requestData(&quot;why&quot;);  const res2 = await requestData(res1 + &quot;aaa&quot;);  const res3 = await requestData(res2 + &quot;bbb&quot;);  console.log(res3);&#125;getData();</code></pre><h3 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3. async/await"></a>3. async/await</h3><h4 id="3-1-async-异步函数"><a href="#3-1-async-异步函数" class="headerlink" title="3-1 async 异步函数"></a>3-1 async 异步函数</h4><ul><li>声明某个函数是异步的</li><li>异步函数的返回值一定是个 Promise</li><li>当 async 函数 return 一个具体值得时候 返回的 Promise 会执行 then（）</li><li>执行异步函数和普通函数没有区别如果里面没有做 await 操作的话</li><li>普通函数中抛出异常代码不会继续执行 异步函数中抛出异常可以用 catch 捕获</li></ul><h4 id="3-2-await-关键字"><a href="#3-2-await-关键字" class="headerlink" title="3-2 await 关键字"></a>3-2 await 关键字</h4><ul><li>只有 async 函数中才可以使用 await 关键字 普通函数不可以</li><li>一般情况下 await 后边跟一个表达式 表达式的返回值是 Promise</li><li>await 的返回值 是返回的 Promise 中 resolve 的结果</li><li>await 后边代码相当于 then（）里</li><li>await 跟上普通值会立即返回这个值</li><li>当 await 后边的表达式返回的是 reject 时 后边的代码不会执行了 会将 reject 值作为整个异步函数的 reject 值</li></ul><h3 id="4-事件循环"><a href="#4-事件循环" class="headerlink" title="4. 事件循环"></a>4. 事件循环</h3><h4 id="4-1-进程和线程"><a href="#4-1-进程和线程" class="headerlink" title="4-1 进程和线程"></a>4-1 进程和线程</h4><ul><li>进程：启动一个应用程序 就会启动一个进程也可能是多个进程</li><li>线程：每一个进程中都会启动至少一个线程来执行程序中的代码，这个线程被称之为主线程。</li></ul><p><strong>我们也可以说进程是线程的容器</strong></p><h4 id="4-2-浏览器中的-js-线程"><a href="#4-2-浏览器中的-js-线程" class="headerlink" title="4-2 浏览器中的 js 线程"></a>4-2 浏览器中的 js 线程</h4><p><img src="/2022/021964822/image-20220206144017746.png"></p><h2 id="第二十二节-事件循环-try-catch-throw"><a href="#第二十二节-事件循环-try-catch-throw" class="headerlink" title="第二十二节 事件循环 try/catch throw"></a>第二十二节 事件循环 try/catch throw</h2><h3 id="1-浏览器的事件循环"><a href="#1-浏览器的事件循环" class="headerlink" title="1. 浏览器的事件循环"></a>1. 浏览器的事件循环</h3><p><img src="/2022/021964822/image-20220206172334549.png"></p><ul><li>事件队列先进先出</li></ul><p>**事件循环就是 JS 引擎执行代码过程中遇到异步代码时会用浏览器其他线程执行然后推入事件队列 JS 引擎再去事件队列中查找事件执行这个不断重复的过程就就是事件循环 **</p><h3 id="2-宏任务和微任务"><a href="#2-宏任务和微任务" class="headerlink" title="2. 宏任务和微任务"></a>2. 宏任务和微任务</h3><p>事件队列划分为：</p><ul><li><p>宏任务队列 macrotask queue</p><p>ajax , setTimeout , setInterval , DOM 监听 ， UI Rendering 等</p></li><li><p>微任务队列 microtask queque</p><p>Promise 的 then 回调 ， Mutation Observer API ， queueMicrotask（）等</p></li></ul><p><strong>规范： 在执行任何宏任务之前都需要先保证微任务队列被清空</strong></p><h3 id="3-事件循环的优先级"><a href="#3-事件循环的优先级" class="headerlink" title="3. 事件循环的优先级"></a>3. 事件循环的优先级</h3><ol><li>main script 代码</li><li>优先微任务队列</li><li>微任务队列清空之后执行宏任务队列</li></ol><h3 id="4-node-的事件循环"><a href="#4-node-的事件循环" class="headerlink" title="4. node 的事件循环"></a>4. node 的事件循环</h3><p><img src="/2022/021964822/image-20220207162836939.png"></p><h4 id="4-1-node-事件循环的阶段"><a href="#4-1-node-事件循环的阶段" class="headerlink" title="4-1 node 事件循环的阶段"></a>4-1 node 事件循环的阶段</h4><p><strong>事件循环像一个桥梁 连接着应用程序的 js 和系统调用之间的通道</strong></p><p><img src="/2022/021964822/image-20220207163721835.png"></p><h4 id="4-2-node-事件循环的微任务-宏任务"><a href="#4-2-node-事件循环的微任务-宏任务" class="headerlink" title="4-2 node 事件循环的微任务/宏任务"></a>4-2 node 事件循环的微任务/宏任务</h4><ul><li><p>宏任务</p><p>setTimeout ， setInterval ， IO 事件 ， setImmediate ， close 事件</p></li><li><p>微任务</p><p>Promise 的 then 回调 ， process.nextTick ， queueMicrotask</p></li></ul><h2 id="第二十三节-JS-模块化"><a href="#第二十三节-JS-模块化" class="headerlink" title="第二十三节 JS 模块化"></a>第二十三节 JS 模块化</h2><h3 id="1-错误处理方案"><a href="#1-错误处理方案" class="headerlink" title="1. 错误处理方案"></a>1. 错误处理方案</h3><ul><li>throw 语句 抛出用户自定义的异常 throw 后边的语句不会执行</li></ul><h3 id="2-抛出异常的其他补充"><a href="#2-抛出异常的其他补充" class="headerlink" title="2. 抛出异常的其他补充"></a>2. 抛出异常的其他补充</h3><ul><li>throw ‘抛出基本数据类型’</li><li>throw {比较常见的是抛出一个对象类型}</li><li>创建类并且创建这个类应对的对象</li><li>js 提供了一个 Error throw new Error（错误信息） 开发中常用的抛出错误信息方法</li></ul><h3 id="3-对抛出异常进行处理"><a href="#3-对抛出异常进行处理" class="headerlink" title="3. 对抛出异常进行处理"></a>3. 对抛出异常进行处理</h3><ul><li>对抛出的异常不做处理 异常会进一步的抛出直到最顶层的调用 如果在最顶层也没有处理那么程序就会终止执行并且报错</li><li>使用 try catch 来捕获异常</li></ul><h3 id="4-什么是模块化"><a href="#4-什么是模块化" class="headerlink" title="4. 什么是模块化"></a>4. 什么是模块化</h3><p><img src="/2022/021964822/image-20220208153705931.png"></p><h3 id="5-CommonJS-规范"><a href="#5-CommonJS-规范" class="headerlink" title="5. CommonJS 规范"></a>5. CommonJS 规范</h3><p><img src="/2022/021964822/image-20220208201042091.png"></p><h4 id="5-2-导出方案"><a href="#5-2-导出方案" class="headerlink" title="5-2 导出方案"></a>5-2 导出方案</h4><ol><li><p>方案一 module.exports</p><pre><code class="js">//导出 导出的是一个对象module.exports&#123;    name，    age&#125;//导入requrie（&#39;文件名&#39;）</code></pre></li><li><p>方案二 exprots</p><pre><code class="js">// exports=moule.exportsexports.name = name;exprots.age = age;exports.sum = sum;</code></pre></li></ol><h2 id="第二十四节-模块化二"><a href="#第二十四节-模块化二" class="headerlink" title="第二十四节 模块化二"></a>第二十四节 模块化二</h2><h3 id="1-require-细节"><a href="#1-require-细节" class="headerlink" title="1. require 细节"></a>1. require 细节</h3><p>require 是一个函数可以帮助我们引入另一个文件中导出的对象</p><ul><li><p>直接引用模块 require（模块名）</p></li><li><p>require（‘路径’）</p><p><img src="/2022/021964822/image-20220210135547465.png"></p></li><li><p>require(既不是路径 也不是核心模块)</p></li></ul><p><img src="/2022/021964822/image-20220210140223979.png"></p><h3 id="2-模块的加载过程"><a href="#2-模块的加载过程" class="headerlink" title="2. 模块的加载过程"></a>2. 模块的加载过程</h3><p><img src="/2022/021964822/image-20220210140958784.png"></p><h3 id="3-CommonJS-规范的缺点"><a href="#3-CommonJS-规范的缺点" class="headerlink" title="3. CommonJS 规范的缺点"></a>3. CommonJS 规范的缺点</h3><ul><li>CommonJS 加载模块是同步的：<ul><li>同步意味着只有等到对应的模块加载完毕之后，当前模块中的内容才能被运行</li><li>这个在服务器中不会有问题，因为服务器加载的 js 文件都是本地文件，加载速度非常快</li></ul></li></ul><p><strong>所以在浏览器中通常不适用 CommonJS 规范</strong></p><h3 id="4-ES-Module"><a href="#4-ES-Module" class="headerlink" title="4. ES Module"></a>4. ES Module</h3><ul><li>export 负责模块的导出</li><li>import 负责从其他模块导入内容</li></ul><h3 id="5-导出的方式"><a href="#5-导出的方式" class="headerlink" title="5. 导出的方式"></a>5. 导出的方式</h3><ul><li><p>export 跟上声明语句</p><pre><code class="js">export const name = &quot;why&quot;;export const age = 18;export function foo() &#123;  console.log(&quot;foo function&quot;);&#125;export class Person &#123;&#125;</code></pre></li><li><p>export 导出和声明分开</p><pre><code class="js">const name = &quot;why&quot;;const age = 18;function foo() &#123;  console.log(&quot;foo function&quot;);&#125;export &#123; name, age, foo &#125;;</code></pre></li><li><p>导出时起别名</p><pre><code class="js">export &#123; name as FName, age as Fage, foo as Ffoo &#125;;</code></pre></li></ul><h3 id="6-导入的方式"><a href="#6-导入的方式" class="headerlink" title="6. 导入的方式"></a>6. 导入的方式</h3><ul><li><p>普通的导入 improt { } from ‘ ‘</p><pre><code class="js">import &#123; name, age, foo &#125; from &quot;./foo.js&quot;;</code></pre></li><li><p>起别名</p><pre><code class="js">import &#123; name as FName, age as Fage, foo as Ffoo &#125; from &quot;./foo.js&quot;;</code></pre></li><li><p>将导出的所有内容放到一个标识符中</p><pre><code class="js">import * as foo from &quot;./foo.js&quot;;</code></pre></li></ul><h3 id="7-ESModule-结合使用"><a href="#7-ESModule-结合使用" class="headerlink" title="7. ESModule 结合使用"></a>7. ESModule 结合使用</h3><ul><li><p>导出方式一：通过创建一个 index.js 先来接收所有要导出的模块 最后把 index.js 中的全部导出去</p><pre><code class="js">import &#123; add, sub &#125; from &quot;./math.js&quot;;import &#123; timeFormat, priceFormat &#125; from &quot;./format.js&quot;;export &#123; add, sub, timeFormat, priceFormat &#125;;</code></pre></li><li><p>导出方式二： 直接用 export 导出</p><pre><code class="js">export &#123; add, sub &#125; from &quot;./math.js&quot;;export &#123; timeFormat, priceFormat &#125; from &quot;./format.js&quot;;</code></pre></li><li><p>导出方式三： 利用*号</p><pre><code class="js">export * from &quot;./math.js&quot;;export * from &quot;./format.js&quot;;</code></pre></li></ul><h3 id="8-Default-用法"><a href="#8-Default-用法" class="headerlink" title="8. Default 用法"></a>8. Default 用法</h3><p><strong>默认导出只能有一个</strong></p><pre><code class="js">const name=&#39;why&#39;const age=18const foo =&quot;foo value&quot;//第一种写法export &#123;    name,    age,    foo as default  //写上default的时候就会变成默认导出&#125;//第二种写法  用的非常多export default fooimport sahdj from &#39;./whnh.js&#39;  //随便添写 东西都会默认导入</code></pre><h3 id="9-import-函数"><a href="#9-import-函数" class="headerlink" title="9. import 函数"></a>9. import 函数</h3><p><strong>import { xxx} from ‘./sdasd’ 在执行完这行代码之前 下面的代码不能执行</strong></p><p>但是 import 函数可以解决这个问题</p><pre><code class="js">//import函数返回的是Promiseimport(&quot;./foo.js&quot;).then((res) =&gt; &#123;  console.log(res.name);&#125;);</code></pre><h2 id="第二十五节-包管理工具"><a href="#第二十五节-包管理工具" class="headerlink" title="第二十五节 包管理工具"></a>第二十五节 包管理工具</h2><h3 id="1-ESModule-的解析流程"><a href="#1-ESModule-的解析流程" class="headerlink" title="1. ESModule 的解析流程"></a>1. ESModule 的解析流程</h3><p><img src="/2022/021964822/image-20220210202208463.png"></p><h3 id="2-ESmodule-和-commonJS-相互引用"><a href="#2-ESmodule-和-commonJS-相互引用" class="headerlink" title="2. ESmodule 和 commonJS 相互引用"></a>2. ESmodule 和 commonJS 相互引用</h3><p><strong>webpack 环境下可以相互引用</strong></p><h3 id="3-npm"><a href="#3-npm" class="headerlink" title="3. npm"></a>3. npm</h3><ul><li>包管理工具</li><li>前端项目中使用来管理依赖的包</li></ul><h4 id="3-1-查看搜索某个包"><a href="#3-1-查看搜索某个包" class="headerlink" title="3-1 查看搜索某个包"></a>3-1 查看搜索某个包</h4><p><a href="https://www.npmjs.org/">https://www.npmjs.org</a></p><h4 id="3-2-package-json-来记录项目的依赖"><a href="#3-2-package-json-来记录项目的依赖" class="headerlink" title="3-2 package.json 来记录项目的依赖"></a>3-2 package.json 来记录项目的依赖</h4><p>怎么得到配置文件</p><ul><li>手动 npm init</li><li>利用脚手架创建项目就会有 package.json</li></ul><h4 id="3-3-package-json-的常见属性"><a href="#3-3-package-json-的常见属性" class="headerlink" title="3-3 package.json 的常见属性"></a>3-3 package.json 的常见属性</h4><p>必填属性是：name，version</p><ul><li>name 是项目名称</li><li>version 是当前项目版本号</li><li>escription 是描述信息，很多时候作为项目的基本描述；</li><li>author 是作者相关信息</li><li>license 是开源协议</li></ul><p><strong>private 属性记录项目是否为私有 当设置为 true 时无法发布到 npm</strong></p><ul><li>main 属性 设置程序的入口</li><li>scrpts 属性<ul><li>用于配置一些脚本命令 以键值对的形式存在</li><li>陪之后我们可以通过 npm run 命令的 key 来执行这个命令</li><li>npm start 和 npm run start 是等价的 对于常用的 start test stop restart 是可以省略 run 直接通过 npm start 等方式运行</li></ul></li><li>dependencies 属性<ul><li>是指定无论开发环境还是生产环境都需要依赖的包</li><li>通常我们项目实际开发用到的一些库模块 vue vuex vue-router axios 等</li><li>与之对应的是 devDependencies</li></ul></li><li>devDependencies 属性<ul><li>一些包在生产环境是不需要的 比如 webpack babel 等</li><li>这个时候我们会通过 npm install webpack –save-dev 将它安装到 devDependencies 属性中</li></ul></li><li>peerDependencies 属性<ul><li>还有一种项目依赖关系是对等依赖，也就是你依赖一个包，它必须是以另外一个宿主包为前提</li><li>比如 element-plus 是依赖与 vue3 antdesign 是依赖于 react react-dom</li></ul></li><li>engines 属性<ul><li>用于指定 node 和 npm 的版本号</li><li>安装过程中先检查对应的引擎版本 不符合就报错</li></ul></li><li>browserslist 属性<ul><li>用于配置打包后的 JavaScript 浏览器的兼容情况</li><li>否则我们需要手动的添加 polyfills 来让支持某些语法</li><li>也就是说它是为 webpack 等打包工具服务的一个属性</li></ul></li></ul><h4 id="3-4-依赖管理版本"><a href="#3-4-依赖管理版本" class="headerlink" title="3-4 依赖管理版本"></a>3-4 依赖管理版本</h4><p><img src="/2022/021964822/image-20220210224013147.png"></p><h2 id="第二十六节-包管理工具二"><a href="#第二十六节-包管理工具二" class="headerlink" title="第二十六节 包管理工具二"></a>第二十六节 包管理工具二</h2><h3 id="1-npm-install"><a href="#1-npm-install" class="headerlink" title="1. npm install"></a>1. npm install</h3><ul><li>全局安装 global install ： npm install webpack -g 只有工具属性才做全局安装</li><li>局部安装 local install ： npm install webpack</li></ul><h3 id="2-项目安装"><a href="#2-项目安装" class="headerlink" title="2. 项目安装"></a>2. 项目安装</h3><p>项目安装时会在当前目录下生产一个 node_modules 文件夹</p><p>局部安装分为 生产依赖 和 开发依赖</p><ul><li>npm install –save 装到 dependsenies 中</li><li>npm instal –D 装到 dev Dependsenies 中</li><li>根据 package.json 中的依赖包 npm install</li></ul><h3 id="3-npm-install-原理"><a href="#3-npm-install-原理" class="headerlink" title="3. npm install 原理"></a>3. npm install 原理</h3><p><img src="/2022/021964822/image-20220211152147508.png"></p><h3 id="4-package-lock-json-配置解析"><a href="#4-package-lock-json-配置解析" class="headerlink" title="4. package-lock.json 配置解析"></a>4. package-lock.json 配置解析</h3><p><img src="/2022/021964822/image-20220211154130187.png"></p><h3 id="5-npm-其他命令"><a href="#5-npm-其他命令" class="headerlink" title="5. npm 其他命令"></a>5. npm 其他命令</h3><ul><li>卸载 依赖 npm uninstall</li><li>强制重新 build npm rebuild</li><li>清除缓存 npm cache clean</li></ul><h3 id="6-yarn-工具"><a href="#6-yarn-工具" class="headerlink" title="6. yarn 工具"></a>6. yarn 工具</h3><p>另一个包管理工具 yarn</p><ul><li>也是一个包管理工具</li><li>弥补 npm 的一些缺陷出现</li><li>早起 npm 缺陷很多 安装依赖很慢 版本依赖混乱</li><li>虽然 npm 现在升级了 还是有很多人喜欢 yarn</li></ul><p><img src="/2022/021964822/image-20220211155852327.png"></p><h3 id="7-cnpm-工具"><a href="#7-cnpm-工具" class="headerlink" title="7. cnpm 工具"></a>7. cnpm 工具</h3><p>由于特殊的原因没法下载 npm 工具包 就需要用 cnpm 下载</p><h3 id="8-npx-工具"><a href="#8-npx-工具" class="headerlink" title="8. npx 工具"></a>8. npx 工具</h3><p>npx webpack –version 可以使用局部 webpack</p><h3 id="9-发布自己的包"><a href="#9-发布自己的包" class="headerlink" title="9. 发布自己的包"></a>9. 发布自己的包</h3><p>npm publish</p><h2 id="第二十七节-JSON-数据存储"><a href="#第二十七节-JSON-数据存储" class="headerlink" title="第二十七节 JSON - 数据存储"></a>第二十七节 JSON - 数据存储</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h3><p>JSON 是一种非常重要的数据格式，不是编程语言，是一种可以再服务端和客户端之间传输的数据格式。</p><h3 id="1-1-其他的传输格式"><a href="#1-1-其他的传输格式" class="headerlink" title="1-1 其他的传输格式"></a>1-1 其他的传输格式</h3><ul><li>XML：很少有人使用</li><li>Protobuf ：越来越多被使用目前在前端使用比较少</li></ul><h4 id="1-2-JSON-基本语法"><a href="#1-2-JSON-基本语法" class="headerlink" title="1-2 JSON 基本语法"></a>1-2 JSON 基本语法</h4><p><strong>JSON 的顶层支持三种类型的值</strong></p><ul><li>简单值：数字， 字符串 不支持单引号 ， 布尔类型 ， null</li><li>对象值：由 key，value 组成，key 是字符串类型，并且必须添加双引号，值可以使简单值，对象值，数组值；</li><li>数组值：数组的值可以是简单值，对象值，数组值</li></ul><h3 id="2-JSON-序列化"><a href="#2-JSON-序列化" class="headerlink" title="2. JSON 序列化"></a>2. JSON 序列化</h3><ul><li><p>JSON.stringify（） 将对象转为 JSON 格式的字符串</p><p>第一个参数 是对那个参数进行转化</p><p>第二个参数 replacer ：</p><ul><li>​ 传入数组：设定哪些是需要转换</li><li>​ 传入回调函数：</li></ul><p>第三个参数 space</p><ul><li>传入数字 ：决定加几个空格</li><li>传入字符串 ： 以传入的字符作为缩进</li></ul></li><li><p>JSON.parse（） JSON 格式的字符串转回对象</p></li></ul><h3 id="3-利用-JSON-序列化深拷贝"><a href="#3-利用-JSON-序列化深拷贝" class="headerlink" title="3. 利用 JSON 序列化深拷贝"></a>3. 利用 JSON 序列化深拷贝</h3><pre><code class="js">const obj = JSON.stringify(obj1);const info = JSON.parse(obj);</code></pre><p>缺点：如果对象中有函数 JSON.stringify 是转化不了的 undefined Symbol 也是会被忽略。</p><h3 id="4-Storage"><a href="#4-Storage" class="headerlink" title="4. Storage"></a>4. Storage</h3><ul><li>localStorage：本地存储 永久性的存储方法 关掉网页重新打开依然存在</li><li>sessionStorage：会话存储 ，提供的是本次会话的存储 关掉会话时 存储的内容会被清除</li></ul><p>区别：</p><ul><li>关闭网页后重新打开 local 保留 sessionstorage 会被删除</li><li>页面内实现跳转 local 保留 sessionStorage 也会保留</li><li>页面外实现跳转 打开新网页 local 会保留 sessionStorage 会被删除</li></ul><h4 id="4-1-Storage-常见属性方法"><a href="#4-1-Storage-常见属性方法" class="headerlink" title="4-1 Storage 常见属性方法"></a>4-1 Storage 常见属性方法</h4><ol><li><p>setItem 存储</p><pre><code class="js">localStorage.setItem(&quot;key名&quot;, 属性值);sessionStorage.setItem(&quot;key名&quot;, 属性值);</code></pre></li><li><p>length</p><pre><code class="js">localStorage.length;</code></pre></li><li><p>key 方法</p><pre><code class="js">localStorage.key(下标);</code></pre></li><li><p>getItem 获取</p><pre><code class="js">localStorage.getItem(&quot;key名&quot;);</code></pre></li><li><p>removeItem 删除</p><pre><code class="js">localStorage.removeItem(&quot;key名&quot;);</code></pre></li><li><p>clear 方法 清空</p><pre><code class="js">localStorage.clear();</code></pre></li></ol><h3 id="5-Storage-工具类的封装"><a href="#5-Storage-工具类的封装" class="headerlink" title="5. Storage 工具类的封装"></a>5. Storage 工具类的封装</h3><pre><code class="js">class HYCache &#123;  constructor(isLocal = true) &#123;    this.storage = isLocal ? localStorage : sessionStorage;  &#125;  setItem(key, value) &#123;    if (value) &#123;      this.storage.setItem(key, JSON.stringify(value));    &#125;  &#125;  getItem(key) &#123;    let value = this.storage.getItem(key);    if (value) &#123;      value = JSON.parse(value);      return value;    &#125;  &#125;  removeItem(key) &#123;    this.storage.removeItem(key);  &#125;  clear() &#123;    this.storage.clear();  &#125;&#125;const localcache = new HYCache();const sessioncache = new HYCache(false);export &#123; localcache, sessioncache &#125;;</code></pre><h3 id="6-indexedDB-了解就行"><a href="#6-indexedDB-了解就行" class="headerlink" title="6. indexedDB 了解就行"></a>6. indexedDB 了解就行</h3><p>是一种底层的 API 用于在客户端储存大量的结构化数据</p><ul><li>事务型的数据库系统</li></ul><h2 id="第二十八节-Cookie-BOM-DOM"><a href="#第二十八节-Cookie-BOM-DOM" class="headerlink" title="第二十八节 Cookie BOM DOM"></a>第二十八节 Cookie BOM DOM</h2><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3><ul><li>浏览器会在特定的情况下携带上 cookie 来发送请求 我们可以通过 cookie 来获取一些信息</li></ul><h4 id="1-1cookie-保存在客户端中-根据客户端的储存位置-分为内存-cookie-和硬盘-cookie"><a href="#1-1cookie-保存在客户端中-根据客户端的储存位置-分为内存-cookie-和硬盘-cookie" class="headerlink" title="1-1cookie 保存在客户端中 根据客户端的储存位置 分为内存 cookie 和硬盘 cookie"></a>1-1cookie 保存在客户端中 根据客户端的储存位置 分为内存 cookie 和硬盘 cookie</h4><ul><li>内存 cookie 由浏览器维护 保存在内存中 浏览器关闭时 cookie 就会小时 存在时间短暂</li><li>硬盘 cookie 保存在硬盘中 有一个过期时间 用户手动清理或者过期时间到时 才会被清理</li></ul><h4 id="1-2-区分内存-cookie-和硬盘-cookie"><a href="#1-2-区分内存-cookie-和硬盘-cookie" class="headerlink" title="1-2 区分内存 cookie 和硬盘 cookie"></a>1-2 区分内存 cookie 和硬盘 cookie</h4><ul><li>有没有设置过期时间 默认情况下 cookie 是内存 cookie 关闭浏览器时自动删除</li><li>有设置过期时间 并且过期时间不为 0 或者负数的 cookie 是硬盘 cookie 需要手动删除</li></ul><h3 id="2-cookie-常见的属性"><a href="#2-cookie-常见的属性" class="headerlink" title="2. cookie 常见的属性"></a>2. cookie 常见的属性</h3><ul><li><p>cookie 的生命周期</p><ul><li>expires： 设置的是 Date.toUTCString（） 具体的时间</li><li>max-age：设置过期的秒钟 用得更多</li></ul></li><li><p>cookie 作用域 允许 cookie 发送给那些 URL</p><ul><li>Domain：指定那些主机可以接受 cookie<ol><li>如果不指定默认是 orgin 不包括子域名</li><li>如果指定 则包含子域名如果设置 Domain=mmozillia.org 则 Cookie 也包含在子域名中（如 developer.mozilla.org）</li></ol></li><li>Path：指定主机下哪些路径可以接受 cookie<ol><li>例如 设置 Path=/docs 则以下地址都会匹配：<ul><li>/docs</li><li>/docs/web/</li><li>/docs/web/tp</li></ul></li></ol></li></ul></li><li><p>删除 cookie 设置过期时间 需要在服务端设置 httpOnly 为 false</p><pre><code class="js">document.cookie = &quot;name=&#39;&#39;;max-age:0&quot;;</code></pre></li></ul><h3 id="3-Cookie-的缺点"><a href="#3-Cookie-的缺点" class="headerlink" title="3. Cookie 的缺点"></a>3. Cookie 的缺点</h3><ul><li>将每一次 cookie 附加到每一次 http 的请求中</li><li>明文传输 headers 存在一定的安全风险</li><li>大小限制 4kb</li><li>cookie 验证登录复杂</li></ul><h3 id="4-BOM-浏览器对象模型"><a href="#4-BOM-浏览器对象模型" class="headerlink" title="4. BOM 浏览器对象模型"></a>4. BOM 浏览器对象模型</h3><ul><li><p>我们可以将 BOM 看成链接 JS 和浏览器窗口的桥梁</p></li><li><p>BOM API 太多不需要每个都去学 用到时候去查文档</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></p><p><strong>BOM 主要对象模型</strong></p></li><li><p>window：包括全局属性方法 控制浏览器窗口相关的属性方法</p></li><li><p>location：浏览器连接到的对象位置（url）</p></li><li><p>history：操作浏览器的历史</p></li><li><p>document：当前窗口操作文档的对象</p></li></ul><h5 id="window-对象在浏览器中有两个身份："><a href="#window-对象在浏览器中有两个身份：" class="headerlink" title="window 对象在浏览器中有两个身份："></a>window 对象在浏览器中有两个身份：</h5><ul><li>身份一：全局对象<ul><li>我们知道 ecmsscript 有一个全局对象 这个全局对象在 node 中是 global</li><li>在浏览器中就是 window 对象</li></ul></li><li>身份二 ：浏览器窗口对象<ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的 API；</li></ul></li></ul><p>window.disapatchEvent（）派发事件</p><p><strong>location</strong></p><p><img src="/2022/021964822/image-20220214155705707.png"></p><p><strong>history</strong></p><p>允许我们访问浏览器曾经的记录历史</p><p><img src="/2022/021964822/image-20220214160500148.png"></p><h2 id="第二十九节-DOM-和-架构"><a href="#第二十九节-DOM-和-架构" class="headerlink" title="第二十九节 DOM 和 架构"></a>第二十九节 DOM 和 架构</h2><h3 id="1-参数的作用域"><a href="#1-参数的作用域" class="headerlink" title="1. 参数的作用域"></a>1. 参数的作用域</h3><p><strong>当函数参数有默认值的情况下会多生成一个新的作用域 这个作用域用于保存参数的值</strong></p><h3 id="2-DOM-document-object-model"><a href="#2-DOM-document-object-model" class="headerlink" title="2. DOM document object model"></a>2. DOM document object model</h3><p><img src="/2022/021964822/image-20220214164306779.png"></p><p>node：节点</p><p>document ：整个网页是 document</p><p>element：标签元素</p><p>characterData:字符数据</p><p>attrbiute：属性</p><h4 id="2-1-事件流"><a href="#2-1-事件流" class="headerlink" title="2-1 事件流"></a>2-1 事件流</h4><ul><li><p>事件冒泡</p><p>一层一层往外层冒</p></li><li><p>事件捕获</p><p>那个外层往里叫做捕获</p><p>window.addEventListner（第三个参数 true，false 决定了是冒泡还是捕获 默认是 false 冒泡）</p><p>阻止事件传递：event.stopPropagation（）</p></li></ul><h2 id="第三十节-手写防抖，节流函数"><a href="#第三十节-手写防抖，节流函数" class="headerlink" title="第三十节 手写防抖，节流函数"></a>第三十节 手写防抖，节流函数</h2><h3 id="1-防抖-debounce-函数"><a href="#1-防抖-debounce-函数" class="headerlink" title="1. 防抖 debounce 函数"></a>1. 防抖 debounce 函数</h3><p>事件触发时 响应函数不会立即触发 而会等待一定时间</p><p>当事件密集触发时 函数的触发会被频繁的推迟</p><p>只有等待了一段事件没有事件触发 才会真正的执行响应函数</p><p>应用场景：</p><ul><li>输入框频繁输入内容 搜索或提交信息</li><li>频繁的点击按钮 触发某个事件</li><li>监听浏览器滚动事件 完成某些特定操作</li><li>用户缩放浏览器的 resize 事件</li></ul><h3 id="2-节流函数-throttle"><a href="#2-节流函数-throttle" class="headerlink" title="2. 节流函数 throttle"></a>2. 节流函数 throttle</h3><p>事件触发时 会执行这个事件的响应函数</p><p>这个事件如果被频繁触发 那么节流函数会按照一定的频率来执行函数</p><p>不管中间有多少次触发这个事件 执行函数的频率是固定的</p><p>应用场景:</p><ul><li>监听页面的滚动事件</li><li>鼠标移动事件</li><li>用户频繁点击按钮操作</li><li>游戏中的一些设计</li></ul><h3 id="3-第三方库工具库"><a href="#3-第三方库工具库" class="headerlink" title="3. 第三方库工具库"></a>3. 第三方库工具库</h3><ul><li>lodash</li><li>undescore</li></ul><h3 id="4-手写防抖函数基本实现-立即执行-取消功能"><a href="#4-手写防抖函数基本实现-立即执行-取消功能" class="headerlink" title="4. 手写防抖函数基本实现 立即执行 取消功能"></a>4. 手写防抖函数基本实现 立即执行 取消功能</h3><pre><code class="js">function _debounce(fn，deplay,immediate=false)&#123;    //定义一个定时器  保存上一次的定时器   let timer=null;    let isInvoke=false;   //真正执行的函数  const debounce=function(...args)&#123;  //取消上一次的定时器   if(timer) clearTimeout(timer)   //判断是否立即执行    if(isInvoke&amp;&amp; !immediate)&#123;         fn.apply(this,args)        isInvoke=true    &#125;else&#123;          //延迟执行       timer= setTimeout(()=&gt;&#123;       //外部传入真正要执行的函数       fn.apply(this,args)        isInvoke=false        &#125;,deplay)    &#125;  &#125;  //封装一个取消功能  debounce.cancel=function()&#123;      if(timer)clearTimeout(timer);      timer=null;      isInvoke=false;  &#125;  return debounce;&#125;</code></pre><h4 id="5-手写节流函数-throttle"><a href="#5-手写节流函数-throttle" class="headerlink" title="5. 手写节流函数 throttle"></a>5. 手写节流函数 throttle</h4><pre><code class="js">function throttle(fn, interval) &#123;  //记录上一次的开始时间  let lastTime = 0;  //事件触发时  真正执行的函数  const _throttle = function () &#123;    //2.1 获取当前事件触发时的时间    const nowTime = new Date().getTime();    //2.2 使用当前触发的时间和之前的时间间隔以及上一次开始的时间 计算出还剩余多长时间需要去触发事件    const remainTime = interval - (nowTime - lastTime);    if (remainTime &lt;= 0) &#123;      //2.3 真正触发函数      fn();      //2.4 保留上次触发的时间      lastTime = nowTime;    &#125;  &#125;;  return _throttle;&#125;</code></pre><h2 id="第三十一节-深拷贝-事件总线"><a href="#第三十一节-深拷贝-事件总线" class="headerlink" title="第三十一节 深拷贝 事件总线"></a>第三十一节 深拷贝 事件总线</h2><h3 id="1-深拷贝"><a href="#1-深拷贝" class="headerlink" title="1. 深拷贝"></a>1. 深拷贝</h3><pre><code class="js"></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端学习</title>
      <link href="2021/120712750.html"/>
      <url>2021/120712750.html</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript-基础"><a href="#Javascript-基础" class="headerlink" title="Javascript 基础"></a>Javascript 基础</h1><h3 id="day-01"><a href="#day-01" class="headerlink" title="day-01"></a>day-01</h3><h3 id="1-初识-JavaScript"><a href="#1-初识-JavaScript" class="headerlink" title="1. 初识 JavaScript"></a>1. 初识 JavaScript</h3><h4 id="1-1-浏览器执行-JS"><a href="#1-1-浏览器执行-JS" class="headerlink" title="1.1 浏览器执行 JS"></a>1.1 浏览器执行 JS</h4><p><strong>JS 属于高级程序语言</strong></p><p>浏览器分成两部分 渲染引擎和 js 引擎</p><ul><li>渲染引擎：用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的 blink，老版本的 webkit</li><li>Js 引擎：也称为 JS 解释器。用来读取网页中的 JavaScript 代码，对其处理后运行，比如 chrome 浏览器的 V8</li></ul><p><font color="red">浏览器本身并不会执行 JS 代码，而是通过内置 Javscript 引擎（解释器）来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后计算机去执行，所以 Javscript 语言被归为脚本语言，会逐行解释执行</font></p><h4 id="1-2-JS-的组成"><a href="#1-2-JS-的组成" class="headerlink" title="1.2 JS 的组成"></a>1.2 JS 的组成</h4><ul><li>ECMAScript js 语法规范</li><li>Dom 文档对象模型</li><li>Bom 浏览器模型</li></ul><h4 id="1-3-JS-的三中书写位置"><a href="#1-3-JS-的三中书写位置" class="headerlink" title="1.3 JS 的三中书写位置"></a>1.3 JS 的三中书写位置</h4><ul><li>行内写法直接写在 html 中</li><li>内联写法 写在 script 标签里</li><li>外部引入通过 script src 引入外部 js 文件</li></ul><h4 id="1-4-JS-注释"><a href="#1-4-JS-注释" class="headerlink" title="1.4 JS 注释"></a>1.4 JS 注释</h4><ul><li>单行注释 / /</li><li>多行注释 /* */</li></ul><h4 id="1-5-JS-的输出输入语句"><a href="#1-5-JS-的输出输入语句" class="headerlink" title="1.5 JS 的输出输入语句"></a>1.5 JS 的输出输入语句</h4><ul><li>输入语句 prompt（’’）；</li><li>输出语句 alert（’’） ；</li><li>浏览器控制台输出语句 console.log(‘’)；</li></ul><p><strong>总结：第一天简单回顾了一下 JS 的基础小知识 JS 的执行过程 JS 的组成 JS 的书写位置 JS 的注释写法 以及 JS 的输入输出语句 ，明天开始第二天的学习。</strong></p><h3 id="day-02"><a href="#day-02" class="headerlink" title="day-02"></a>day-02</h3><h4 id="1-6-什么是变量"><a href="#1-6-什么是变量" class="headerlink" title="1.6 什么是变量"></a>1.6 什么是变量</h4><p>变量就是在内存中开辟了一块空间来存储数据，通过变量名来找到变量</p><h4 id="1-7-变量的使用"><a href="#1-7-变量的使用" class="headerlink" title="1.7 变量的使用"></a>1.7 变量的使用</h4><ul><li>先声明变量 var 变量名</li><li>变量赋值</li><li>调用变量名</li></ul><p>var age=18； 声明变量并赋值叫做变量的初始化。</p><h4 id="1-8-变量语法扩展"><a href="#1-8-变量语法扩展" class="headerlink" title="1.8 变量语法扩展"></a>1.8 变量语法扩展</h4><ul><li>更新变量值 以最后变量值为准 因为 js 的执行机制</li><li>多个变量同时声明一个 var var name=18,age=36;</li><li>声明变量不赋值 直接调用 输出 undefined</li><li>不声明变量直接调用 控台报错</li><li>不声明变量 赋值 不报错但是作用域是全局作用域容易引起问题 不建议使用</li></ul><h4 id="1-9-变量名命名规范"><a href="#1-9-变量名命名规范" class="headerlink" title="1.9 变量名命名规范"></a>1.9 变量名命名规范</h4><ul><li>字母（A-Zz-a），数字（0-9），下划线（_）,美元符号（$）组成</li><li>严格区分大小写</li><li>不能以数字开头</li><li>不能是关键字 保留字</li><li>遵守驼峰命名 首字母小写 后面单词首字母需要大写</li><li>变量名要有意义</li></ul><h3 id="2-简单数据类型"><a href="#2-简单数据类型" class="headerlink" title="2. 简单数据类型"></a>2. 简单数据类型</h3><h4 id="2-1-为什么需要数据类型"><a href="#2-1-为什么需要数据类型" class="headerlink" title="2.1 为什么需要数据类型"></a>2.1 为什么需要数据类型</h4><p>因为数据的大小不同，所以我们根据变量的大小划分数据类型。</p><p>JS 的变量数据类型只有在程序运行过程中，根据等号右边的值来确定的。</p><p>JS 是动态语言，所以变量的数据类型是可以改变的。</p><p>数据类型分为：简单数据类型 引用数据类型。</p><p>简单数据类型： Number、String 、Undefined、null、Boolean、Symbol</p><p><em>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</em></p><p>引用数据类型：Object、Array、Function</p><h4 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h4><p>8 进制的数字 0-7 我们在数字前加 0 表示八进制</p><p>var num1=010 等于十进制的 8</p><p>16 进制的数字 0-9 a-f 数字前面加 0x 表示十六进制</p><p>var num2=0x9 等于十进制的 9</p><p>1.Number.max_value（）最大值</p><p>2.Number.min_value（）最小值</p><p>3.infinity 无穷大</p><p>4.-infinity 无穷小</p><p>5.NaN 非数字</p><p>consoloe.log（’woshiwenzi’-100）;//输出打印 NaN</p><p>6.isNaN（） 判断是不是一个非数</p><p>如果是一个数字类型将返回 false 如果不是数字类型将返回 true</p><h4 id="2-3-字符串类型-String"><a href="#2-3-字符串类型-String" class="headerlink" title="2.3 字符串类型 String"></a>2.3 字符串类型 String</h4><p>1.什么是字符串：只要带有单引号 或者双引号的不管是文字还是数字都是字符串类型。</p><p>2.字符串的嵌套：外面用单引号里面用双引号或者外面双引号里面单引号</p><p>3.字符串中还有转义字符:例如换行 \n 缩进\t 等等</p><p><img src="/2021/120712750/image-20211205163949909.png"></p><p>4.字符串的长度 用 length 这个属性 如：a 字符串的长度 = a.length</p><p>5.字符串的拼接需要用 +号来进行拼接</p><h4 id="任何类型和字符串相加都会变成字符串！！！"><a href="#任何类型和字符串相加都会变成字符串！！！" class="headerlink" title="任何类型和字符串相加都会变成字符串！！！"></a>任何类型和字符串相加都会变成字符串！！！</h4><h4 id="2-4-Boolean-布尔型"><a href="#2-4-Boolean-布尔型" class="headerlink" title="2.4 Boolean 布尔型"></a>2.4 Boolean 布尔型</h4><p>布尔型有两个值：true（真） 和 false（假）；</p><p>当参与数学运算时：true 可以当做 1 来运算， false 则可以当做 0 来运算。</p><h4 id="2-5-Undefined-和-null"><a href="#2-5-Undefined-和-null" class="headerlink" title="2.5 Undefined 和 null"></a>2.5 Undefined 和 null</h4><p>undefined：只声明了变量，但是并不赋值。如果进行相加时要注意结果。</p><p>null：一个变量给 null 值，里面存的值为空。</p><p>undefined+字符串=字符串类型</p><p>undefined+数字型=NaN</p><p>undefined+false/true=NaN</p><h3 id="3-获取数据类型"><a href="#3-获取数据类型" class="headerlink" title="3. 获取数据类型"></a>3. 获取数据类型</h3><h4 id="3-1-typeof-检验数据类型"><a href="#3-1-typeof-检验数据类型" class="headerlink" title="3.1 typeof 检验数据类型"></a>3.1 typeof 检验数据类型</h4><p>typeof 可以检验数据类型是那一种</p><p>var age=18；</p><p>console.log（typeof age）；</p><h4 id="3-2-字面量"><a href="#3-2-字面量" class="headerlink" title="3.2 字面量"></a>3.2 字面量</h4><p>字面量就是代码中固定值得表示法，就是你一看上去就知道这是个什么类型的值</p><ul><li>数字字面量：8,6,12</li><li>字符串字面量：’我好’,’你好’</li><li>布尔字面量：true ， false</li></ul><h4 id="3-3-转换字符串类型"><a href="#3-3-转换字符串类型" class="headerlink" title="3.3 转换字符串类型"></a>3.3 转换字符串类型</h4><ol><li><p>toString（）方法 变量.toString（）</p></li><li><p>String（） 方法 String（变量）</p></li><li><p>与字符串相加 转为字符串类型 隐式转换</p></li></ol><ul><li>通常最常用的就是与字符串相加的这种方法</li></ul><h4 id="3-4-转换数字型（重点-）"><a href="#3-4-转换数字型（重点-）" class="headerlink" title="3.4 转换数字型（重点*）"></a>3.4 转换数字型（重点*）</h4><ol><li>parseInt（变量） 取整数</li><li>parseFloat（变量）有小数点就保留小数</li><li>Number（变量）</li><li>隐式转换 运用 - / * 运算符 进行隐式转换</li></ol><h4 id="3-5-转换布尔型"><a href="#3-5-转换布尔型" class="headerlink" title="3.5 转换布尔型"></a>3.5 转换布尔型</h4><p>Boolean（变量）只有这一种方法</p><ul><li>当变量值为 ‘ ‘,0,NaN,undefined,null 这五种时会转为 false</li><li>其余值全转为 true</li></ul><h2 id="day-03"><a href="#day-03" class="headerlink" title="day-03"></a>day-03</h2><h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h3><h4 id="运算符都很多种分为"><a href="#运算符都很多种分为" class="headerlink" title="运算符都很多种分为"></a>运算符都很多种分为</h4><ul><li>算数运算符</li><li>逻辑运算符</li><li>递增递减运算符</li><li>比较运算符</li><li>赋值运算符</li></ul><h4 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h4><p>加减乘除 取余%</p><h4 id="4-2-递增递减运算符"><a href="#4-2-递增递减运算符" class="headerlink" title="4.2 递增递减运算符"></a>4.2 递增递减运算符</h4><ul><li>++在前先自增加一后返回值</li><li>++在后先返回值在自增加一</li></ul><p><strong>必须和变量搭配使用不能和数字使用</strong></p><p><strong>开发中经常使用后置++</strong></p><h4 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a>4.3 比较运算符</h4><p>就是用来两个值相比较的运算符会返回布尔值 一个=号是赋值 ！= 不等号 ===全等 要求数据类型 值全部一致 ==两个等号是等于的意思会转换数据类型</p><p>其余都是基本的运算符 &gt; &lt; = &gt;= &lt;=</p><p><img src="/2021/120712750/image-20211206093643887.png"></p><h4 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h4><p>&amp;&amp; 逻辑与 当在表达式中有一侧值为 false 结果就返回 false</p><p>||逻辑或 当表达式中有一侧为真 结果就为真</p><p>！非 取反</p><p><strong>逻辑中断（短路运算）</strong></p><ul><li>逻辑与的短路运算 当第一个值为 false 时 直接返回第一个值 当两个值都为 true 时返回第二个值</li><li>逻辑或的短路运算 当第一个值为 true 时 返回第一个值 当两个值都为 false 时返回第二个值</li></ul><h4 id="4-5-赋值运算符"><a href="#4-5-赋值运算符" class="headerlink" title="4.5 赋值运算符"></a>4.5 赋值运算符</h4><p>= += -= *= /= %=</p><ul><li>=号 赋值</li><li>+= 每次加完之后的结果赋值</li><li>-=和+=同理</li></ul><h4 id="4-6-运算符的优先级"><a href="#4-6-运算符的优先级" class="headerlink" title="4.6 运算符的优先级"></a>4.6 运算符的优先级</h4><p><img src="/2021/120712750/image-20211206100109347.png"></p><ul><li>一元运算符里面的逻辑非优先级很高</li><li>逻辑与比逻辑或优先级高</li></ul><h3 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a>5. 流程控制</h3><h4 id="5-1-什么是流程控制"><a href="#5-1-什么是流程控制" class="headerlink" title="5.1 什么是流程控制"></a>5.1 什么是流程控制</h4><p>流程控制分为：顺序流程控制 循环流程控制 分支流程控制 来控制你代码的执行</p><h4 id="5-2-顺序流程控制"><a href="#5-2-顺序流程控制" class="headerlink" title="5.2 顺序流程控制"></a>5.2 顺序流程控制</h4><p>按照你书写的顺序，从上往下执行。</p><h4 id="5-3-分支流程控制-if-else-语句"><a href="#5-3-分支流程控制-if-else-语句" class="headerlink" title="5.3 分支流程控制 if else 语句"></a>5.3 分支流程控制 if else 语句</h4><p>当你满足了（）里面的条件时执行大括号里面的代码段当你不满足条件时 执行 else 里的代码段</p><p>if（条件）{</p><p>执行代码段</p><p>}else{</p><p>执行语句</p><p>}</p><p>多分支语句就是有多个条件 如果第一个条件不满足时判断第二个是否满足</p><p>else if（）</p><h4 id="5-4-三元表达式"><a href="#5-4-三元表达式" class="headerlink" title="5.4 三元表达式"></a>5.4 三元表达式</h4><p>条件判断 ？ 条件为真时返回这个:条件为假时返回这个；</p><p>10&gt;5? ‘是的’:’不是的’</p><h4 id="5-5-switch-语句"><a href="#5-5-switch-语句" class="headerlink" title="5.5 switch 语句"></a>5.5 switch 语句</h4><p>switch 是通过特定的值来进行准确匹配比 if else 更快速精准</p><p>开发中一般表达式用变量保存 所以写变量</p><p>我们 switch（）中的值和 case 选项值是全等要求全等===</p><p>switch(条件表达式){</p><p>case 匹配选项值:</p><p>执行代码；</p><p>break；</p><p>default 匹配不上：</p><p>执行代码</p><p>}</p><h4 id="5-6-switch-和-ifelse-的区别"><a href="#5-6-switch-和-ifelse-的区别" class="headerlink" title="5.6 switch 和 ifelse 的区别"></a>5.6 switch 和 ifelse 的区别</h4><ul><li>if else 更适合用于判断范围类 switch 适合用于知道准确的值</li><li>分支多的情况下用 switch 效率更高</li><li>分支少的时候用 if else 更好</li></ul><h3 id="6-循环"><a href="#6-循环" class="headerlink" title="6. 循环"></a>6. 循环</h3><h4 id="6-1-循环的目的"><a href="#6-1-循环的目的" class="headerlink" title="6.1 循环的目的"></a>6.1 循环的目的</h4><p>可以重复执行一些代码</p><h4 id="6-2-for-循环"><a href="#6-2-for-循环" class="headerlink" title="6.2 for 循环"></a>6.2 for 循环</h4><p>for（条件表达式）{</p><p>循环体</p><p>}</p><h4 id="6-3-双重-for-循环"><a href="#6-3-双重-for-循环" class="headerlink" title="6.3 双重 for 循环"></a>6.3 双重 for 循环</h4><p>循环嵌套:第一层 for 循环是决定要循环几次内层 for 循环决定了你一次循环要操作几次。</p><h4 id="6-4-while-循环"><a href="#6-4-while-循环" class="headerlink" title="6.4 while 循环"></a>6.4 while 循环</h4><p>while（当条件为真时）{</p><p>执行循环体</p><p>计数器的更新</p><p>}</p><h4 id="6-5-do-while-循环"><a href="#6-5-do-while-循环" class="headerlink" title="6.5 do while 循环"></a>6.5 do while 循环</h4><p>do{</p><p>循环体</p><p>更新计数器；</p><p>}while（条件表达式）</p><p>do while 循环不论条件是否为真，都至少执行一次循环。</p><h4 id="6-6-continue-和-break-关键字"><a href="#6-6-continue-和-break-关键字" class="headerlink" title="6.6 continue 和 break 关键字"></a>6.6 continue 和 break 关键字</h4><p><strong>continue：跳过本次循环，执行后面的循环。</strong></p><p><strong>break：直接终止循环，后面的也不执行</strong></p><h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h3><h4 id="7-1-什么是数组"><a href="#7-1-什么是数组" class="headerlink" title="7.1 什么是数组"></a>7.1 什么是数组</h4><p>数组就是一组数据存放在一个变量下的集合</p><h4 id="7-2-创建数组"><a href="#7-2-创建数组" class="headerlink" title="7.2 创建数组"></a>7.2 创建数组</h4><ul><li>var 变量名= new Array（）</li><li>利用数组字面量[] 来创建</li></ul><h4 id="7-3-访问数组元素"><a href="#7-3-访问数组元素" class="headerlink" title="7.3 访问数组元素"></a>7.3 访问数组元素</h4><p>数组当中有许多元素 想要获取某一个元素我们需要使用下标。</p><p>下标是从数组的第一个元素开始从 0 开始</p><p>数组名[你想获取元素的下标号]</p><h4 id="7-4-遍历数组"><a href="#7-4-遍历数组" class="headerlink" title="7.4 遍历数组"></a>7.4 遍历数组</h4><ul><li>使用 for 循环遍历数组</li><li>for each 循环</li><li>for of 循环</li><li>map 遍历</li><li>some 遍历</li><li>find 遍历</li><li>every 遍历</li><li>filter 遍历</li><li>reduce 遍历</li></ul><h4 id="7-5-数组的长度"><a href="#7-5-数组的长度" class="headerlink" title="7.5 数组的长度"></a>7.5 数组的长度</h4><p>length 属性就是长度</p><p>数组名.length</p><h2 id="day-04"><a href="#day-04" class="headerlink" title="day-04"></a>day-04</h2><h4 id="7-6-数组新增元素"><a href="#7-6-数组新增元素" class="headerlink" title="7.6 数组新增元素"></a>7.6 数组新增元素</h4><ul><li>通过 arr.length 修改长度来扩展数组 但是多出来的元素由于你没有赋值所以是空元素</li><li>通过索引 当数组里没有这个索引时就会扩充数组 如果已经有这个索引就会覆盖</li></ul><h3 id="8-函数-function（）"><a href="#8-函数-function（）" class="headerlink" title="8. 函数 function（）"></a>8. 函数 function（）</h3><h4 id="8-1-函数的概念"><a href="#8-1-函数的概念" class="headerlink" title="8.1 函数的概念"></a>8.1 函数的概念</h4><p>函数就是把一些重复使用率高的代码块封装到一起</p><h4 id="8-2-函数的使用"><a href="#8-2-函数的使用" class="headerlink" title="8.2 函数的使用"></a>8.2 函数的使用</h4><p>声明函数： function 函数名（）{ 函数体的代码}</p><p>调用函数：函数名（）</p><h4 id="8-3-参数的使用"><a href="#8-3-参数的使用" class="headerlink" title="8.3 参数的使用"></a>8.3 参数的使用</h4><p>参数分为：形参 和实参</p><ul><li>形参：在函数声明时小括号里的参数就是形参 可以把参数看成 赋值 形参=实参</li><li>实参：在调用函数时小括号里的参数就是实参</li></ul><p>作用：参数的作用主要是让函数体执行不同的代码</p><p>形参和实参个数匹配</p><ul><li>形参个数多余实参的个数 形参回去匹配实参 多出来的默认值是 undefined</li><li>形参少于实参 多出来的形参默认值是 undefined</li><li>形参等于实参 一切正常</li></ul><p><strong>JS 中函数形参的默认值是 undefined</strong></p><h4 id="8-4-函数的返回值"><a href="#8-4-函数的返回值" class="headerlink" title="8.4 函数的返回值"></a>8.4 函数的返回值</h4><p>函数只是执行一段代码 最终的结果返回给调用者我们需要 用 return</p><p>return 要返回的结果</p><p>可以看成 return 返回的结果 = 调用者（）</p><p><strong>实际开发中用一个变量来接受函数返回值</strong></p><p><strong>函数返回值的注意事项：</strong></p><ul><li>return 既是返回结果又是终止函数 return 后面的代码就不会执行了</li><li>return 只能返回一个结果如果有多个结果的话以最后一个为准 如果想要返回多个结果 可以以数组的形式</li><li>如果函数体内有 return 那么将返回 return 后面的结果 如果没有 return 的话那么将返回 undefined</li></ul><p><strong>break，continue，return 的区别</strong></p><ul><li><strong>break：结束当前循环体；</strong></li><li><strong>continue：跳出本次循环，执行下一次循环；</strong></li><li><strong>return：不仅可以退出循环，还可以返回 return 语句中的值，同时还可以结束当前函数体的代码。</strong></li></ul><h4 id="8-5-Arguments-的使用"><a href="#8-5-Arguments-的使用" class="headerlink" title="8.5 Arguments 的使用"></a>8.5 Arguments 的使用</h4><p>arguments 是函数中内置的一个对象 ，当我们不知道要传入几个参数的时候 我们在使用 arguments。</p><p>arguments 是一个伪数组 ，具有数组的某一些特性。</p><p><strong>伪数组</strong>:</p><ul><li>具有数组的 length 属性</li><li>可以使用索引</li><li>但是他没有真正数组的方法比如 pop（） push（） shift（）等</li></ul><h4 id="8-6-函数可以调用另一个函数"><a href="#8-6-函数可以调用另一个函数" class="headerlink" title="8.6 函数可以调用另一个函数"></a>8.6 函数可以调用另一个函数</h4><h3 id="9-Javascript-作用域"><a href="#9-Javascript-作用域" class="headerlink" title="9. Javascript 作用域"></a>9. Javascript 作用域</h3><h4 id="9-1-什么是作用域"><a href="#9-1-什么是作用域" class="headerlink" title="9.1 什么是作用域"></a>9.1 什么是作用域</h4><p>作用域：就是代码名字有效的范围就叫作用域</p><p>目的：是为了减少变量冲突</p><p>全局作用域：在整个 script 标签或者外部 js 文件中的作用范围。</p><p>局部作用域：在函数内部就是局部作用域。</p><h4 id="9-2-全局变量和局部变量"><a href="#9-2-全局变量和局部变量" class="headerlink" title="9.2 全局变量和局部变量"></a>9.2 全局变量和局部变量</h4><p>全局变量：全局变量在全部作用域下都可以使用，包括函数内。</p><p>局部变量：局部变量只能在局部使用。</p><p>区别：全局变量比较影响内存要关闭浏览器才会销毁，而局部变量只要代码块运行结束后就会销毁占用内存少。</p><p><strong>es5 中没有块级作用域</strong></p><p>块级作用域：{}内就是块级作用域</p><h4 id="9-3-作用域链"><a href="#9-3-作用域链" class="headerlink" title="9.3 作用域链"></a>9.3 作用域链</h4><p>作用域链：内部函数访问外部函数变量，要向上查找如果外部函数没有就在往上一级查找，这种链式结构我们称为作用域链。</p><h3 id="10-预解析"><a href="#10-预解析" class="headerlink" title="10. 预解析"></a>10. 预解析</h3><p>JS 引擎执行代码的过程：</p><ol><li>先预解析 当碰到 var 关键字时会把声明变量提升到当前作用域的最前面但是赋值不提升 当碰到 funtion 声明函数时会把 function 包括里面一整段全部提升到当前作用域最前面但是如果是函数表达式时只提升 var 函数名 所以函数表达式写法必须写声明在调用。</li><li>在执行代码 按照书写的顺序从上往下依次执行。</li></ol><h3 id="11-对象"><a href="#11-对象" class="headerlink" title="11. 对象"></a>11. 对象</h3><h4 id="11-1-什么是对象"><a href="#11-1-什么是对象" class="headerlink" title="11.1 什么是对象"></a>11.1 什么是对象</h4><p>JS 中对象是一组无序的属性和方法的集合，所有的事务都是对象，比如字符串 ， 数值，数组，函数等。</p><p>对象由属性和方法组成。</p><h4 id="11-2-为什么需要对象"><a href="#11-2-为什么需要对象" class="headerlink" title="11.2 为什么需要对象"></a>11.2 为什么需要对象</h4><p>对象保存的信息更加清晰</p><h4 id="11-3-创建对象"><a href="#11-3-创建对象" class="headerlink" title="11.3 创建对象"></a>11.3 创建对象</h4><h5 id="11-3-1-字面量创建对象"><a href="#11-3-1-字面量创建对象" class="headerlink" title="11.3-1 字面量创建对象"></a>11.3-1 字面量创建对象</h5><p>var obj={添写对象属性，方法}</p><p>调用对象：对象名.属性名 对象名.方法名()</p><p>属性 ，变量，函数，方法的区别：</p><ul><li>变量是单独声明的 可以单独使用</li><li>属性声明在对象里 调用的时候 对象.属性名</li><li>函数是单独声明 调用时 函数名（）</li><li>方法生命在对象里 调用的时候 对象名.方法名（）</li></ul><h5 id="11-3-2-new-Object-创建对象"><a href="#11-3-2-new-Object-创建对象" class="headerlink" title="11.3-2 new Object 创建对象"></a>11.3-2 new Object 创建对象</h5><p>var 对象名 = new Object（）；</p><p>添加属性方法时: 对象名.属性名= 内容 对象名.方法名=function（）{要执行的操作}</p><p>这个方法我们是利用变量赋值的形式来创建的</p><h5 id="11-3-3-构造函数创建对象"><a href="#11-3-3-构造函数创建对象" class="headerlink" title="11.3-3 构造函数创建对象"></a>11.3-3 构造函数创建对象</h5><p>构造函数可以抽取公共的属性和方法 可以复用</p><p>function Obj（）{</p><p>this.属性名=属性值；</p><p>this.方法名=function（）{</p><p>}</p><p>}</p><p>调用：new Obj（）</p><p>注意：</p><ul><li>构造函数名开头必须大写</li><li>调用构造函数时必须 new 一下</li><li>构造函数不需要 return 自己就能返回结果</li><li>属性方法前面必须要加 this</li><li>我们只需要 new 方法名() 就能调用函数创建一个对象</li></ul><h4 id="11-4-构造函数和对象的区别"><a href="#11-4-构造函数和对象的区别" class="headerlink" title="11.4 构造函数和对象的区别"></a>11.4 构造函数和对象的区别</h4><p>构造函数：抽取了对象的公共部分 泛指某一类 比如 球类。</p><p>对象：具体到某一个事物 比如篮球</p><p>new 构造函数（）出一个对象也叫实例化！！</p><h4 id="11-5-new-关键字的执行过程"><a href="#11-5-new-关键字的执行过程" class="headerlink" title="11.5 new 关键字的执行过程"></a>11.5 new 关键字的执行过程</h4><ol><li>首先在内存中开辟了一个空间来存放空对象</li><li>this 指向了我们创建的空对象</li><li>执行代码块 给空对象添加属性方法</li><li>返回这个对象 所以构造函数不需要 return</li></ol><h4 id="11-6-遍历对象"><a href="#11-6-遍历对象" class="headerlink" title="11.6 遍历对象"></a>11.6 遍历对象</h4><p>for（变量 in 对象名）{</p><p>console.log(变量 )输出的是属性名</p><p>console.log（对象名【变量】）输出的是属性值</p><p>}</p><p>变量名最好使用 k 或者 key。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你会用到的15个前端小知识</title>
      <link href="2021/060219214.html"/>
      <url>2021/060219214.html</url>
      
        <content type="html"><![CDATA[<h1 id="你会用到的-15-个前端小知识"><a href="#你会用到的-15-个前端小知识" class="headerlink" title="你会用到的 15 个前端小知识"></a>你会用到的 15 个前端小知识</h1><h3 id="1-css-一行文本超出…"><a href="#1-css-一行文本超出…" class="headerlink" title="1. css 一行文本超出…"></a>1. css 一行文本超出…</h3><pre><code class="css">overflow: hidden;text-overflow:ellipsis;white-space: nowrap;</code></pre><h3 id="2-多行文本超出显示…"><a href="#2-多行文本超出显示…" class="headerlink" title="2.多行文本超出显示…"></a>2.多行文本超出显示…</h3><pre><code class="css">display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;</code></pre><h3 id="3-IOS-手机容器滚动条滑动不流畅"><a href="#3-IOS-手机容器滚动条滑动不流畅" class="headerlink" title="3.IOS 手机容器滚动条滑动不流畅"></a>3.IOS 手机容器滚动条滑动不流畅</h3><pre><code class="css">overflow: auto;-webkit-overflow-scrolling: touch;</code></pre><h3 id="4-修改滚动条样式"><a href="#4-修改滚动条样式" class="headerlink" title="4.修改滚动条样式"></a>4.修改滚动条样式</h3><p>隐藏 div 元素的滚动条</p><pre><code class="css">cdiv::-webkit-scrollbar &#123;``    display: none;&#125;</code></pre><ul><li>div::-webkit-scrollbar 滚动条整体部分</li><li>div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条</li><li>div::-webkit-scrollbar-track 滚动条的轨道（里面装有 Thumb</li><li>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置</li><li>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去</li><li>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</li><li>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。</li></ul><h3 id="5-使用-css-写出一个三角形角标"><a href="#5-使用-css-写出一个三角形角标" class="headerlink" title="5.使用 css 写出一个三角形角标"></a>5.使用 css 写出一个三角形角标</h3><p>元素宽高设置为 0，通过 border 属性来设置，让其它三个方向的 border 颜色为透明或者和背景色保持一致，剩余一条 border 的颜色设置为需要的颜色。</p><pre><code class="css">div &#123;    width: 0;    height: 0;    border: 5px solid #transparent;    border-top-color: red;&#125;</code></pre><h3 id="6-解决-ios-audio-无法自动播放、循环播放的问题"><a href="#6-解决-ios-audio-无法自动播放、循环播放的问题" class="headerlink" title="6.解决 ios audio 无法自动播放、循环播放的问题"></a>6.解决 ios audio 无法自动播放、循环播放的问题</h3><p>ios 手机在使用 audio 或者 video 播放的时候，个别机型无法实现自动播放，可使用下面的代码 hack。</p><pre><code class="js">// 解决ios audio无法自动播放、循环播放的问题var music = document.getElementById(&#39;video&#39;);var state = 0;document.addEventListener(&#39;touchstart&#39;, function()&#123;    if(state==0)&#123;        music.play();        state=1;    &#125;&#125;, false);document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123;    music.play();&#125;, false);//循环播放music.onended = function () &#123;    music.load();    music.play();&#125;</code></pre><h3 id="7-水平垂直居中"><a href="#7-水平垂直居中" class="headerlink" title="7.水平垂直居中"></a>7.水平垂直居中</h3><p>我一般只使用两种方式 定位 或者 flex，我觉得够用了。</p><pre><code class="css">div &#123;    width: 100px;    height: 100px;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;&#125;</code></pre><p>父级控制子集居中</p><pre><code class="css">.parent &#123;    display: flex;    justify-content: center;    align-items: center;&#125;</code></pre><h3 id="8-隐藏页面元素"><a href="#8-隐藏页面元素" class="headerlink" title="8.隐藏页面元素"></a>8.隐藏页面元素</h3><ul><li>display-none: 元素不存在，从 dom 中删除</li><li>opacity-0: 元素透明度将为 0，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</li><li>visibility-hidden：元素隐藏，但元素仍旧存在，页面中无法触发该元素的事件。</li></ul><h3 id="9-前端工程化"><a href="#9-前端工程化" class="headerlink" title="9.前端工程化"></a>9.前端工程化</h3><p>一提到前端工程化很多人想到的都是 webpack，这是不对的，webpack 仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。 前端工程化是通过工具提升效率，降低成本的一种手段。 近些年被广泛的关注和探讨，究其原因主要是因为现代化前端应用功能要求不断提高，业务逻辑日益复杂，作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半壁江山。从传统的网站，到现在的 H5,移动 App,桌面应用，以及小程序。前端技术几乎是无所不能的全面覆盖。 在这些表象的背后呢，实际上是行业对开发人员的要求发生了天翻地覆的变化，以往前端写 demo，套模板，调页面这种刀耕火种的方式已经完全不符合当下对开发效率的要求，前端工程化就是在这样一个背景下被提上台面，成为前端工程师必备的手段之一。 一般来说前端工程包含，项目初始化，项目开发，集成，构建，打包，测试，部署等流程。工程化就是以工程的角度来解决这些问题。比如项目初始化我们一般使用 npm init, 创建页面模板使用 plop，我们喜欢使用 ES6+开发，但是需要通过 babel 编码成 ES5，持续集成的时候我们使用 git，但是为了保持开发规范我们引入了 ESLint，部署一般使用 ci/cd 或者 jenkins 等等。 前端工程化是一个比较大的话题，后面我们会单开话题来讲。</p><h3 id="10-contenteditable"><a href="#10-contenteditable" class="headerlink" title="10.contenteditable"></a>10.contenteditable</h3><p>html 中大部分标签都是不可以编辑的，但是添加了 contenteditable 属性之后，标签会变成可编辑状态。</p><pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><p>不过通过这个属性把标签变为可编辑状态后只有 input 事件，没有 change 事件。也不能像表单一样通过 maxlength 控制最大长度。我也忘记我在什么情况下用到过了，后面想起来再补吧。</p><h3 id="11-calc"><a href="#11-calc" class="headerlink" title="11.calc"></a>11.calc</h3><p>这是一个 css 属性，我一般称之为 css 表达式。可以计算 css 的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出 20px 是啥。</p><pre><code class="css">div &#123;    width: calc(25% - 20px);&#125;</code></pre><h3 id="12-Proxy-和-Object-defineProperty-区别"><a href="#12-Proxy-和-Object-defineProperty-区别" class="headerlink" title="12.Proxy 和 Object.defineProperty 区别"></a>12.Proxy 和 Object.defineProperty 区别</h3><p>Proxy 的意思是代理，我一般教他拦截器，可以拦截对象上的一个操作。用法如下，通过 new 的方式创建对象，第一个参数是被拦截的对象，第二个参数是对象操作的描述。实例化后返回一个新的对象，当我们对这个新的对象进行操作时就会调用我们描述中对应的方法。</p><pre><code class="js">new Proxy(target, &#123;    get(target, property) &#123;    &#125;,    set(target, property) &#123;    &#125;,    deleteProperty(target, property) &#123;    &#125;&#125;)</code></pre><p>Proxy 区别于 Object.definedProperty。 Object.defineProperty 只能监听到属性的读写，而 Proxy 除读写外还可以监听属性的删除，方法的调用等。 通常情况下我们想要监视数组的变化，基本要依靠重写数组方法的方式实现，这也是 Vue 的实现方式，而 Proxy 可以直接监视数组的变化。</p><pre><code class="js">const list = [1, 2, 3];const listproxy = new Proxy(list, &#123;    set(target, property, value) &#123;        target[property] = value;        return true; // 标识设置成功    &#125;&#125;);list.push(4);</code></pre><p>Proxy 是以非入侵的方式监管了对象的读写，而 defineProperty 需要按特定的方式定义对象的属性。</p><h3 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13.Reflect"></a>13.Reflect</h3><p>他是 ES2015 新增的对象，纯静态对象也就是不能被实例画，只能通过静态方法的方式调用，和 Math 对象类似，只能类似 Math.random 的方式调用。 Reflect 内部封装了一系列对对象的底层操作，一共 14 个，其中 1 个被废弃，还剩下 13 个。 Reflect 的静态方法和 Proxy 描述中的方法完全一致。也就是说 Reflect 成员方法就是 Proxy 处理对象的默认实现。 Proxy 对象默认的方法就是调用了 Reflect 内部的处理逻辑，也就是如果我们调用 get 方法，那么在内部，proxy 就是将 get 原封不动的交给了 Reflect，如下。</p><pre><code class="js">const proxy = new Proxy(obj, &#123;    get(target, property) &#123;        return Reflect.get(target, property);    &#125;&#125;)</code></pre><p>Reflect 和 Proxy 没有绝对的关系，我们一般将他们两个放在一起讲是为了方便对二者的理解。 那为什么会有 Reflect 对象呢，其实他最大的用处就是提供了一套统一操作 Object 的 API。判断对象是否存在某一个属性，可以使用 in 操作符，但是不够优雅，还可以使用 Reflect.has(obj, name); 删除一个属性可以使用 delete，也可以使用 Reflect.deleteProperty(obj, name); 获取所有属性名可以使用 Object.keys, 也可以使用 Reflect.ownKeys(obj); 我们更推荐使用 Reflect 的 API 来操作对象，因为他才是未来。</p><h3 id="14-解析-get-参数"><a href="#14-解析-get-参数" class="headerlink" title="14.解析 get 参数"></a>14.解析 get 参数</h3><p>通过 replace 方法获取 url 中的参数键值对，可以快速解析 get 参数。</p><pre><code class="js">const q = &#123;&#125;;location.search.replace(/([^?&amp;=]+)=([^&amp;]+)/g,(_,k,v)=&gt;q[k]=v);console.log(q);</code></pre><h3 id="15-解析连接-url"><a href="#15-解析连接-url" class="headerlink" title="15.解析连接 url"></a>15.解析连接 url</h3><p>可以通过创建 a 标签，给 a 标签赋值 href 属性的方式，获取到协议，pathname，origin 等 location 对象上的属性。</p><pre><code class="js">// 创建a标签const aEle = document.createElement(&#39;a&#39;);// 给a标签赋值href路径aEle.href = &#39;/test.html&#39;;// 访问aEle中的属性aEle.protocol; // 获取协议aEle.pathname; // 获取pathaEle.origin;aEle.host;aEle.search;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3+vite创建项目</title>
      <link href="2021/051326278.html"/>
      <url>2021/051326278.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue3-vite创建项目"><a href="#vue3-vite创建项目" class="headerlink" title="vue3+vite创建项目"></a>vue3+vite创建项目</h1><h2 id="1-全局安装create-vite-app"><a href="#1-全局安装create-vite-app" class="headerlink" title="1. 全局安装create-vite-app"></a>1. 全局安装create-vite-app</h2><ol><li>yarn global add <a href="mailto:&#x63;&#114;&#101;&#x61;&#x74;&#101;&#x2d;&#x76;&#105;&#x74;&#x65;&#x2d;&#x61;&#112;&#112;&#x40;&#49;&#x2e;&#49;&#x38;&#x2e;&#48;">&#x63;&#114;&#101;&#x61;&#x74;&#101;&#x2d;&#x76;&#105;&#x74;&#x65;&#x2d;&#x61;&#112;&#112;&#x40;&#49;&#x2e;&#49;&#x38;&#x2e;&#48;</a></li></ol><h2 id="2-创建项目目录"><a href="#2-创建项目目录" class="headerlink" title="2.创建项目目录"></a>2.创建项目目录</h2><pre><code> cva vue3-ui 或者 create-vite-app vue3-ui    </code></pre><h2 id="Vue-2-和-Vue-3-的区别"><a href="#Vue-2-和-Vue-3-的区别" class="headerlink" title="Vue 2 和 Vue 3 的区别"></a>Vue 2 和 Vue 3 的区别</h2><p>90% 的写法完全一致，除了以下几点</p><ul><li>Vue 3 的 Template 支持多个根标签，Vue 2 不支持</li><li>Vue 3 有 createApp()，而 Vue 2 的是 new Vue()</li><li>createApp(组件)，new Vue({template, render})</li></ul><h2 id="3-引入Vue-Router4"><a href="#3-引入Vue-Router4" class="headerlink" title="3.引入Vue Router4"></a>3.引入Vue Router4</h2><p><img src="/2021/051326278/1.jpg"></p><h3 id="3-1-使用命令行查看vue-router-所有版本号"><a href="#3-1-使用命令行查看vue-router-所有版本号" class="headerlink" title="3.1. 使用命令行查看vue-router 所有版本号"></a>3.1. 使用命令行查看vue-router 所有版本号</h3><ol><li>npm info vue-router versions</li></ol><h3 id="安装最新的-118-x75-101-45-114-111-x75-x74-101-114-x40-x34-x2e-x30-x2e-48-x2d-98-x65-x74-x61-x2e-x36"><a href="#安装最新的-118-x75-101-45-114-111-x75-x74-101-114-x40-x34-x2e-x30-x2e-48-x2d-98-x65-x74-x61-x2e-x36" class="headerlink" title="安装最新的&#118;&#x75;&#101;&#45;&#114;&#111;&#x75;&#x74;&#101;&#114;&#x40;&#x34;&#x2e;&#x30;&#x2e;&#48;&#x2d;&#98;&#x65;&#x74;&#x61;&#x2e;&#x36;"></a>安装最新的<a href="mailto:&#118;&#x75;&#101;&#45;&#114;&#111;&#x75;&#x74;&#101;&#114;&#x40;&#x34;&#x2e;&#x30;&#x2e;&#48;&#x2d;&#98;&#x65;&#x74;&#x61;&#x2e;&#x36;">&#118;&#x75;&#101;&#45;&#114;&#111;&#x75;&#x74;&#101;&#114;&#x40;&#x34;&#x2e;&#x30;&#x2e;&#48;&#x2d;&#98;&#x65;&#x74;&#x61;&#x2e;&#x36;</a></h3><ol><li>yarn add <a href="mailto:&#x76;&#117;&#101;&#45;&#114;&#x6f;&#x75;&#116;&#101;&#x72;&#64;&#52;&#46;&#48;&#x2e;&#48;&#x2d;&#x62;&#101;&#x74;&#x61;&#46;&#54;">&#x76;&#117;&#101;&#45;&#114;&#x6f;&#x75;&#116;&#101;&#x72;&#64;&#52;&#46;&#48;&#x2e;&#48;&#x2d;&#x62;&#101;&#x74;&#x61;&#46;&#54;</a></li></ol><h3 id="3-2-初始化vue-router"><a href="#3-2-初始化vue-router" class="headerlink" title="3.2. 初始化vue-router"></a>3.2. 初始化vue-router</h3><h4 id="1-新建-history-对象"><a href="#1-新建-history-对象" class="headerlink" title="(1).新建 history 对象"></a>(1).新建 history 对象</h4><ol><li>import {createWebHashHistory, createRouter} from ‘vue-router’</li><li>const history = createWebHashHistory()</li></ol><h4 id="2-新建-router-对象"><a href="#2-新建-router-对象" class="headerlink" title="(2). 新建 router 对象"></a>(2). 新建 router 对象</h4><ol><li>const router = createRouter()</li></ol><h4 id="3-引入typescript"><a href="#3-引入typescript" class="headerlink" title="(3)引入typescript"></a>(3)引入typescript</h4><p>把main.js文件改为main.ts，我们会发现有很多报错 报错1：createRouter里面需要传入一个参数，但我们却传入了0个 解决：</p><blockquote></blockquote><pre><code>const router = createRouter(&#123;     history,     routes: [     &#123; path: &#39;/&#39;, component: Lifa &#125;    ]&#125;)</code></pre><blockquote></blockquote><p>报错2：.vue类型的文件提示cannot find module xxx.vue 原因ts只能理解.ts为后缀的文件，无法理解.vue文件 解决方法:</p><ul><li>Google 搜索 Vue 3 can not find module</li><li>创建 xxx.d.ts，告诉 TS 如何理解 .vue 文件</li><li>src/shims-vue.d.ts</li></ul><blockquote></blockquote><pre><code>declare module &#39;*.vue&#39; &#123; import &#123; Component &#125; from &#39;vue&#39; const component: Component export default component&#125;   </code></pre><blockquote></blockquote><p>这里要注意如果我们用的是vscode这时报错已经没了，但是如果我们用的是webstrom编辑器它还是会 报同样的错误，我们需要再额外的安装ts，然后初始化ts配置</p><blockquote></blockquote><pre><code>yarn add typescript -Dtsc --init</code></pre><blockquote></blockquote><p>这样报错就会解决了</p><h4 id="4-使用router"><a href="#4-使用router" class="headerlink" title="(4)使用router"></a>(4)使用router</h4><blockquote></blockquote><pre><code>const app = createApp(App)app.use(router)app.mount(&#39;#app&#39;)</code></pre><blockquote></blockquote><h4 id="5-添加-router-view"><a href="#5-添加-router-view" class="headerlink" title="(5)添加 router-view"></a>(5)添加 router-view</h4><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code>&lt;template&gt;  &lt;div&gt;hi&lt;/div&gt;  &lt;router-view/&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name: &#39;App&#39;&#125;&lt;/script&gt;</code></pre><blockquote></blockquote><h4 id="6-添加router-link"><a href="#6-添加router-link" class="headerlink" title="(6)添加router-link"></a>(6)添加router-link</h4><blockquote></blockquote><pre><code>&lt;div&gt;导航栏 | &lt;router-link to=&quot;/&quot;&gt;lifa&lt;/router-link&gt; &lt;router-link to=&quot;xxx&quot;&gt;lifa2&lt;/router-link&gt;&lt;/div&gt;</code></pre><blockquote></blockquote><h2 id="3-安装sass"><a href="#3-安装sass" class="headerlink" title="3.安装sass"></a>3.安装sass</h2><blockquote></blockquote><pre><code>yarn add sass</code></pre><blockquote></blockquote><p>发现控制台报错 <img src="/2021/051326278/2.jpg"></p><p>解决方法：</p><h3 id="4-1-打开package-json"><a href="#4-1-打开package-json" class="headerlink" title="4.1 打开package.json"></a>4.1 打开package.json</h3><h3 id="4-2-把dependencies里的sass这一行，移到devDependencies"><a href="#4-2-把dependencies里的sass这一行，移到devDependencies" class="headerlink" title="4.2. 把dependencies里的sass这一行，移到devDependencies"></a>4.2. 把dependencies里的sass这一行，移到devDependencies</h3><p><img src="/2021/051326278/3.jpg"></p><h3 id="4-3-重新运行yarn-install"><a href="#4-3-重新运行yarn-install" class="headerlink" title="4.3. 重新运行yarn install"></a>4.3. 重新运行yarn install</h3><h2 id="5-使用provide和inject实现父子组件通信"><a href="#5-使用provide和inject实现父子组件通信" class="headerlink" title="5. 使用provide和inject实现父子组件通信"></a>5. 使用provide和inject实现父子组件通信</h2><h3 id="5-1-在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值"><a href="#5-1-在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值" class="headerlink" title="5.1. 在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值"></a>5.1. 在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值</h3><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code>&lt;script lang=&quot;ts&quot;&gt; import &#123; ref, provide &#125; from &#39;vue&#39; export default &#123;  name: &#39;App&#39;,  setup() &#123;   const menuVisible = ref(false)    provide(&#39;xxx&#39;, menuVisible)  &#125;&#125;</code></pre><blockquote></blockquote><h3 id="5-2-在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值"><a href="#5-2-在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值" class="headerlink" title="5.2. 在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值"></a>5.2. 在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值</h3><ul><li>topnav.vue</li></ul><blockquote></blockquote><pre><code> import &#123; inject, Ref &#125; from &#39;vue&#39; export default &#123;  name: &#39;TopNav&#39;,  setup() &#123;  const menuVisible = inject&lt;Ref&lt;boolean&gt;&gt;(&#39;xxx&#39;)  console.log(menuVisible.value, &#39;topNav menuvisible&#39;)  &#125;&#125;</code></pre><blockquote></blockquote><h2 id="6-路由间切换"><a href="#6-路由间切换" class="headerlink" title="6.路由间切换"></a>6.路由间切换</h2><ul><li>Doc.vue</li></ul><blockquote></blockquote><pre><code>&lt;li&gt;    &lt;router-link to=&quot;/doc/switch&quot;&gt;Switch 组件&lt;/router-link&gt;&lt;/li&gt;&lt;main&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/main&gt;</code></pre><blockquote></blockquote><ul><li>mian.ts</li></ul><blockquote></blockquote><pre><code>const router = createRouter(&#123; history, routes: [    &#123; path: &#39;/&#39;, component: Home &#125;,    &#123; path: &#39;/doc&#39;, component: Doc, children: [      &#123; path: &#39;switch&#39;, component: SwitchDemo &#125;    ]  &#125; ]&#125;)router.afterEach(() =&gt; &#123; console.log(&#39;路由切换了&#39;)&#125;)</code></pre><blockquote></blockquote><p>实现点击菜单跳转关闭左侧菜单栏 我们需要在路由离开的时候将menuVisible的值设为false，但是我们在main.ts里拿不到 menuVisible这个变量，那如果我们把router.afterEach放在App里就可以访问这个变量了，但是 这样的话App里又访问不到我们的router了，所以我们需要单独构建一个router.ts文件</p><ul><li>router.ts</li></ul><blockquote></blockquote><pre><code>import &#123;createWebHashHistory, createRouter&#125; from &#39;vue-router&#39;import Home from &#39;./views/Home.vue&#39;import Doc from &#39;./views/Doc.vue&#39;import SwitchDemo from &#39;./views/SwitchDemo.vue&#39;  const history = createWebHashHistory()  export const router = createRouter(&#123;    history,    routes: [        &#123; path: &#39;/&#39;, component: Home &#125;,        &#123; path: &#39;/doc&#39;, component: Doc, children: [        &#123; path: &#39;switch&#39;, component: SwitchDemo &#125;    ]  &#125; ]&#125;)</code></pre><blockquote></blockquote><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code> import &#123; router &#125; from &quot;./router&quot;; setup() &#123;    const width = document.documentElement.clientWidth    const menuVisible = ref(width &gt; 500 ? true : false)    provide(&#39;xxx&#39;, menuVisible)  +   router.afterEach(() =&gt; &#123;  +      menuVisible.value = false  +    &#125;)   &#125;</code></pre><blockquote></blockquote><ul><li>main.ts</li></ul><blockquote></blockquote><pre><code>import &#123;router&#125; from &#39;./router&#39;const app = createApp(App)app.use(router)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 新特性</title>
      <link href="2021/05124429.html"/>
      <url>2021/05124429.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-新特性"><a href="#Vue3-新特性" class="headerlink" title="Vue3 新特性"></a>Vue3 新特性</h1><p>vue3新增了很多新的特性，目前可以使用 安装 vue-compisition-api 包进行尝鲜，vue3将会对vue2进行向下兼容，因此不必担心因为使用vue3 后 vue2的特性不能够使用</p><h2 id="安装包、使用包"><a href="#安装包、使用包" class="headerlink" title="安装包、使用包"></a>安装包、使用包</h2><ol><li><p>npm install @vue/composition-api –save</p></li><li><p>import VueCompositionApi from ‘@vue/composition-api’</p></li><li><p>Vue.use(VueCompositionApi)</p></li></ol><h2 id="1-setup"><a href="#1-setup" class="headerlink" title="1.setup"></a>1.setup</h2><p>setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口。</p><h3 id="1-1-执行时机"><a href="#1-1-执行时机" class="headerlink" title="1.1 执行时机"></a>1.1 执行时机</h3><p>setup 函数会在 beforeCreate 之后、created 之前执行!!!</p><h3 id="1-2-接收-props-数据"><a href="#1-2-接收-props-数据" class="headerlink" title="1.2 接收 props 数据"></a>1.2 接收 props 数据</h3><p>在 props 中定义当前组件允许外界传递过来的参数名称： props: { p1: String }<br>通过 setup 函数的第一个形参，接收 props 数据： setup(props) { console.log(props.p1) }</p><h3 id="1-3-context"><a href="#1-3-context" class="headerlink" title="1.3 context"></a>1.3 context</h3><p>setup 函数的第二个形参是一个上下文对象，这个上下文对象中包含了一些有用的属性，这些属性在 vue 2.x 中需要通过 this 才能访问到，在 vue 3.x 中，它们的访问方式如下：</p><ol><li>const MyComponent = {</li><li>setup(props, context) {</li><li>   context.attrs</li><li>   context.slots</li><li>   context.parent</li><li>   context.root</li><li>   context.emit</li><li>   context.refs</li><li>  }</li><li>}</li></ol><p>注意：在 setup() 函数中无法访问到 this !!!!!!!!!!!!!</p><h2 id="2-reactive"><a href="#2-reactive" class="headerlink" title="2.reactive"></a>2.reactive</h2><p>reactive() 函数接收一个普通对象，返回一个响应式的数据对象。</p><h3 id="2-1基本语法"><a href="#2-1基本语法" class="headerlink" title="2.1基本语法"></a>2.1基本语法</h3><p>等价于 vue 2.x 中的 Vue.observable() 函数，vue 3.x 中提供了 reactive() 函数，用来创建响应式的数据对象，基本代码示例如下：</p><ol><li>import { reactive } from ‘@vue/composition-api’</li><li>// 创建响应式数据对象，得到的 state 类似于 vue 2.x 中 data() 返回的响应式对象</li><li>const state = reactive({ count: 0 })</li></ol><h3 id="2-2-定义响应式数据供-template-使用"><a href="#2-2-定义响应式数据供-template-使用" class="headerlink" title="2.2 定义响应式数据供 template 使用"></a>2.2 定义响应式数据供 template 使用</h3><p>按需导入 reactive 函数：</p><ol><li>import { reactive } from ‘@vue/composition-api’</li></ol><ul><li>在 setup() 函数中调用 reactive() 函数，创建响应式数据对象：</li></ul><ol><li>setup() {</li><li><pre><code>// 创建响应式数据对象</code></pre></li><li>   const state = reactive({count: 0})</li><li></li><li><pre><code>// setup 函数中将响应式数据对象 return 出去，供 template 使用</code></pre></li><li>   return state</li><li>}</li></ol><ul><li>在 template 中访问响应式数据：</li></ul><ol><li><p>当前的 count 值为：</p></li><li><p>ref</p><h3 id="3-1基本语法"><a href="#3-1基本语法" class="headerlink" title="3.1基本语法"></a>3.1基本语法</h3><p>ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性：</p></li><li><p>import { ref } from ‘@vue/composition-api’</p></li><li></li><li><p>// 创建响应式数据对象 count，初始值为 0</p></li><li><p>const count = ref(0)</p></li><li></li><li><p>// 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以</p></li><li><p>console.log(count.value) // 输出 0</p></li><li><p>// 让 count 的值 +1</p></li><li><p>count.value++</p></li><li><p>// 再次打印 count 的值</p></li><li><p>console.log(count.value) // 输出 1</p></li></ol><h3 id="3-2-在-template-中访问-ref-创建的响应式数据"><a href="#3-2-在-template-中访问-ref-创建的响应式数据" class="headerlink" title="3.2 在 template 中访问 ref 创建的响应式数据"></a>3.2 在 template 中访问 ref 创建的响应式数据</h3><p>在 setup() 中创建响应式数据：</p><ol><li>import { ref } from ‘@vue/composition-api’</li><li></li><li>setup() {</li><li>   const count = ref(0)</li><li></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>    count,</code></pre></li><li><pre><code>    name: ref(&#39;zs&#39;)</code></pre></li><li><pre><code>&#125;</code></pre></li><li>}</li></ol><ul><li>在 template 中访问响应式数据：</li></ul><ol><li><template></template></li><li> <p> --- </p></li><li></li></ol><h2 id="3-3-在-reactive-对象中访问-ref-创建的响应式数据"><a href="#3-3-在-reactive-对象中访问-ref-创建的响应式数据" class="headerlink" title="3.3 在 reactive 对象中访问 ref 创建的响应式数据"></a>3.3 在 reactive 对象中访问 ref 创建的响应式数据</h2><p>当把 ref() 创建出来的响应式数据对象，挂载到 reactive() 上时，会自动把响应式数据对象展开为原始的值，不需通过 .value 就可以直接被访问，例如：</p><ol><li>const count = ref(0)</li><li>const state = reactive({</li><li>  count</li><li>})</li><li></li><li>console.log(state.count) // 输出 0</li><li>state.count++ // 此处不需要通过 .value 就能直接访问原始值</li><li>console.log(count) // 输出 1</li></ol><p>注意：新的 ref 会覆盖旧的 ref，示例代码如下：</p><ol><li>// 创建 ref 并挂载到 reactive 中</li><li>const c1 = ref(0)</li><li>const state = reactive({</li><li>  c1</li><li>})</li><li></li><li>// 再次创建 ref，命名为 c2</li><li>const c2 = ref(9)</li><li>// 将 旧 ref c1 替换为 新 ref c2</li><li>state.c1 = c2</li><li>state.c1++</li><li></li><li>console.log(state.c1) // 输出 10</li><li>console.log(c2.value) // 输出 10</li><li>console.log(c1.value) // 输出 0</li></ol><h2 id="4-isRef"><a href="#4-isRef" class="headerlink" title="4. isRef"></a>4. isRef</h2><p>isRef() 用来判断某个值是否为 ref() 创建出来的对象；应用场景：当需要展开某个可能为 ref() 创建出来的值的时候，例如：</p><ol><li>import { isRef } from ‘@vue/composition-api’</li><li></li><li>const unwrapped = isRef(foo) ? foo.value : foo</li></ol><h2 id="5-toRefs"><a href="#5-toRefs" class="headerlink" title="5.toRefs"></a>5.toRefs</h2><p>toRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据，最常见的应用场景如下：</p><ol><li>import { toRefs } from ‘@vue/composition-api’</li><li></li><li>setup() {</li><li><pre><code>// 定义响应式数据对象</code></pre></li><li><pre><code>const state = reactive(&#123;</code></pre></li><li><pre><code>  count: 0</code></pre></li><li><pre><code>&#125;)</code></pre></li><li></li><li><pre><code>// 定义页面上可用的事件处理函数</code></pre></li><li><pre><code>const increment = () =&gt; &#123;</code></pre></li><li><pre><code>  state.count++</code></pre></li><li><pre><code>&#125;</code></pre></li><li></li><li><pre><code>// 在 setup 中返回一个对象供页面使用</code></pre></li><li><pre><code>// 这个对象中可以包含响应式的数据，也可以包含事件处理函数</code></pre></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>  // 将 state 上的每个属性，都转化为 ref 形式的响应式数据</code></pre></li><li><pre><code>  ...toRefs(state),</code></pre></li><li><pre><code>  // 自增的事件处理函数</code></pre></li><li><pre><code>  increment</code></pre></li><li><pre><code>&#125;</code></pre></li><li>}</li></ol><p>页面上可以直接访问 setup() 中 return 出来的响应式数据：</p><template>  <div>     <p>当前的count值为：</p>    <button @click="increment">+1</button>  </div></template><h2 id="6-computed"><a href="#6-computed" class="headerlink" title="6.computed"></a>6.computed</h2><p>computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入：</p><ol><li>import { computed } from ‘@vue/composition-api’</li></ol><h3 id="6-1-创建只读计算属性"><a href="#6-1-创建只读计算属性" class="headerlink" title="6.1 创建只读计算属性"></a>6.1 创建只读计算属性</h3><p>在调用 computed() 函数期间，传入一个 function 函数，可以得到一个只读的计算属性，示例代码如下：</p><ol><li>// 创建一个 ref 响应式数据</li><li>const count = ref(1)</li><li></li><li>// 根据 count 的值，创建一个响应式的计算属性 plusOne</li><li>// 它会根据依赖的 ref 自动计算并返回一个新的 ref</li><li>const plusOne = computed(() =&gt; count.value + 1)</li><li></li><li>console.log(plusOne.value) // 输出 2</li><li>plusOne.value++ // error</li></ol><h3 id="6-2-创建可读可写的计算属性"><a href="#6-2-创建可读可写的计算属性" class="headerlink" title="6.2.创建可读可写的计算属性"></a>6.2.创建可读可写的计算属性</h3><p>在调用 computed() 函数期间，传入一个包含 get 和 set 函数的对象，可以得到一个可读可写的计算属性，示例代码如下：</p><ol><li>// 创建一个 ref 响应式数据</li><li>const count = ref(1)</li><li></li><li>// 创建一个 computed 计算属性</li><li>const plusOne = computed({</li><li>  // 取值函数</li><li>  get: () =&gt; count.value + 1,</li><li>  // 赋值函数</li><li>  set: val =&gt; {</li><li><pre><code>count.value = val - 1</code></pre></li><li>  }</li><li>})</li><li></li><li>// 为计算属性赋值的操作，会触发 set 函数</li><li>plusOne.value = 9</li><li>// 触发 set 函数后，count 的值会被更新</li><li>console.log(count.value) // 输出 8</li></ol><h2 id="7-watch"><a href="#7-watch" class="headerlink" title="7.watch"></a>7.watch</h2><p>watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入：</p><ol><li>import { watch } from ‘@vue/composition-api’<br>1<h3 id="7-1基本用法"><a href="#7-1基本用法" class="headerlink" title="7.1基本用法"></a>7.1基本用法</h3></li><li>const count = ref(0)</li><li></li><li>// 定义 watch，只要 count 值变化，就会触发 watch 回调</li><li>// watch 会在创建时会自动调用一次</li><li>watch(() =&gt; console.log(count.value))</li><li>// 输出 0</li><li></li><li>setTimeout(() =&gt; {</li><li>  count.value++</li><li>  // 输出 1</li><li>}, 1000)</li></ol><h3 id="7-2-监视指定的数据源"><a href="#7-2-监视指定的数据源" class="headerlink" title="7.2 监视指定的数据源"></a>7.2 监视指定的数据源</h3><p>监视 reactive 类型的数据源：</p><ol><li>// 定义数据源</li><li>const state = reactive({ count: 0 })</li><li>// 监视 state.count 这个数据节点的变化</li><li>watch(</li><li>  () =&gt; state.count,</li><li>  (count, prevCount) =&gt; {</li><li><pre><code>/* ... */</code></pre></li><li>  }</li><li>)</li></ol><p>监视 ref 类型的数据源：</p><ol><li>// 定义数据源</li><li>const count = ref(0)</li><li>// 指定要监视的数据源</li><li>watch(count, (count, prevCount) =&gt; {</li><li>  /* … */</li><li>})</li></ol><h3 id="7-3-监视多个数据源"><a href="#7-3-监视多个数据源" class="headerlink" title="7.3 监视多个数据源"></a>7.3 监视多个数据源</h3><p>监视 reactive 类型的数据源：</p><ol><li>const state = reactive({ count: 0, name: ‘zs’ })</li><li></li><li>watch(</li><li> [() =&gt; state.count, () =&gt; state.name], // Object.values(toRefs(state)),</li><li> ([count, name], [prevCount, prevName]) =&gt; {</li><li> console.log(count) // 新的 count 值</li><li> console.log(name) // 新的 name 值</li><li> console.log(‘————‘)</li><li> console.log(prevCount) // 旧的 count 值</li><li>console.log(prevName) // 新的 name 值</li><li>},</li><li> {</li><li>  lazy: true // 在 watch 被创建的时候，不执行回调函数中的代码</li><li> }</li><li>) </li><li></li><li>setTimeout(() =&gt; {</li><li> state.count++</li><li> state.name = ‘ls’</li><li>}, 1000)</li></ol><p>监视 ref 类型的数据源：</p><ol><li>const count = ref(0)</li><li>const name = ref(‘zs’)</li><li></li><li>watch(</li><li>  [count, name], // 需要被监视的多个 ref 数据源</li><li>  ([count, name], [prevCount, prevName]) =&gt; {</li><li><pre><code>console.log(count)</code></pre></li><li><pre><code>console.log(name)</code></pre></li><li><pre><code>console.log(&#39;-------------&#39;)</code></pre></li><li><pre><code>console.log(prevCount)</code></pre></li><li><pre><code>console.log(prevName)</code></pre></li><li>  },</li><li>  {</li><li><pre><code>lazy: true</code></pre></li><li>  }</li><li>)</li><li></li><li>setTimeout(() =&gt; {</li><li>  count.value++</li><li>  name.value = ‘xiaomaolv’</li><li>}, 1000)</li></ol><h3 id="7-4-清除监视"><a href="#7-4-清除监视" class="headerlink" title="7.4 清除监视"></a>7.4 清除监视</h3><p>在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下：</p><ol><li>// 创建监视，并得到 停止函数</li><li>const stop = watch(() =&gt; {</li><li>  /* … */</li><li>})</li><li></li><li>// 调用停止函数，清除对应的监视</li><li>stop()</li><li><h3 id="7-5-在watch中清除无效的异步任务"><a href="#7-5-在watch中清除无效的异步任务" class="headerlink" title="7.5 在watch中清除无效的异步任务"></a>7.5 在watch中清除无效的异步任务</h3>有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用：</li></ol><ul><li>watch 被重复执行了</li><li>watch 被强制 stop 了<h4 id="Template-中的代码示例如下："><a href="#Template-中的代码示例如下：" class="headerlink" title="Template 中的代码示例如下："></a>Template 中的代码示例如下：</h4></li></ul><ol><li>/* template 中的代码 */ <input type="text" v-model="keywords"></li></ol><h4 id="Script-中的代码示例如下："><a href="#Script-中的代码示例如下：" class="headerlink" title="Script 中的代码示例如下："></a>Script 中的代码示例如下：</h4><ol><li>// 定义响应式数据 keywords</li><li>const keywords = ref(‘’)</li><li></li><li>// 异步任务：打印用户输入的关键词</li><li>const asyncPrint = val =&gt; {</li><li>  // 延时 1 秒后打印</li><li>  return setTimeout(() =&gt; {</li><li><pre><code>console.log(val)</code></pre></li><li>  }, 1000)</li><li>}</li><li></li><li>// 定义 watch 监听</li><li>watch(</li><li>  keywords,</li><li>  (keywords, prevKeywords, onCleanup) =&gt; {</li><li><pre><code>// 执行异步任务，并得到关闭异步任务的 timerId</code></pre></li><li><pre><code>const timerId = asyncPrint(keywords)</code></pre></li><li></li><li><pre><code>// 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务</code></pre></li><li><pre><code>onCleanup(() =&gt; clearTimeout(timerId))</code></pre></li><li>  },</li><li>  // watch 刚被创建的时候不执行</li><li>  { lazy: true }</li><li>)</li><li></li><li>// 把 template 中需要的数据 return 出去</li><li>return {</li><li>  keywords</li><li>}</li></ol><h2 id="8-LifeCycle-Hooks"><a href="#8-LifeCycle-Hooks" class="headerlink" title="8.LifeCycle Hooks"></a>8.LifeCycle Hooks</h2><p>新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下：</p><ol><li>import { onMounted, onUpdated, onUnmounted } from ‘@vue/composition-api’</li><li></li><li>const MyComponent = {</li><li>  setup() {</li><li><pre><code>onMounted(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;mounted!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li><pre><code>onUpdated(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;updated!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li><pre><code>onUnmounted(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;unmounted!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li>  }</li><li>}</li></ol><p>下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系：</p><ul><li>beforeCreate -&gt; use setup()</li><li>created -&gt; use setup()</li><li>beforeMount -&gt; onBeforeMount</li><li>mounted -&gt; onMounted</li><li>beforeUpdate -&gt; onBeforeUpdate</li><li>updated -&gt; onUpdated</li><li>beforeDestroy -&gt; onBeforeUnmount</li><li>destroyed -&gt; onUnmounted</li><li>errorCaptured -&gt; onErrorCaptured<h2 id="9-provide-amp-inject"><a href="#9-provide-amp-inject" class="headerlink" title="9. provide &amp; inject"></a>9. provide &amp; inject</h2>provide() 和 inject() 可以实现嵌套组件之间的数据传递。这两个函数只能在 setup() 函数中使用。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据。</li></ul><h3 id="9-1-共享普通数据"><a href="#9-1-共享普通数据" class="headerlink" title="9.1 共享普通数据"></a>9.1 共享普通数据</h3><p>App.vue 根组件：</p><template>   <div id="app">     <h1>App 根组件</h1>    <hr>    <LevelOne>  </LevelOne></div></template><script>import LevelOne from './components/LevelOne' // 1. 按需导入 provideimport { provide } from '@vue/composition-api'export default {  name: 'app',  setup() {    // 2. App 根组件作为父级组件，通过 provide 函数向子级组件共享数据（不限层级）    //    provide('要共享的数据名称', 被共享的数据)    provide('globalColor', 'red')  },  components: {    LevelOne  }}</script><p>LevelOne.vue 组件：</p><template>  <div>    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->    <h3 :style="{color: themeColor}">Level One</h3>    <hr>    <LevelTwo>  </LevelTwo></div></template><script>import LevelTwo from './LevelTwo'// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default {  setup() {    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据    const themeColor = inject('globalColor')    // 3. 把接收到的共享数据 return 给 Template 使用    return {      themeColor    }  },  components: {    LevelTwo  }}</script><p>LevelTwo.vue 组件：</p><template>  <div>    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->    <h5 :style="{color: themeColor}">Level Two</h5>  </div></template><script>// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default {  setup() {    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据    const themeColor = inject('globalColor')    // 3. 把接收到的共享数据 return 给 Template 使用    return {      themeColor    }  }}</script><h3 id="9-2-共享ref-响应式数据"><a href="#9-2-共享ref-响应式数据" class="headerlink" title="9.2 共享ref 响应式数据"></a>9.2 共享ref 响应式数据</h3><p>如下代码实现了点按钮切换主题颜色的功能，主要修改了 App.vue 组件中的代码，LevelOne.vue 和 LevelTwo.vue 中的代码不受任何改变：</p><template>  <div id="app">    <h1>App 根组件</h1><pre><code>&lt;!-- 点击 App.vue 中的按钮，切换子组件中文字的颜色 --&gt;&lt;button @click=&quot;themeColor=&#39;red&#39;&quot;&gt;红色&lt;/button&gt;&lt;button @click=&quot;themeColor=&#39;blue&#39;&quot;&gt;蓝色&lt;/button&gt;&lt;button @click=&quot;themeColor=&#39;orange&#39;&quot;&gt;橘黄色&lt;/button&gt;&lt;hr /&gt;&lt;LevelOne /&gt;</code></pre>  </div></template><script>import LevelOne from './components/LevelOne'import { provide, ref } from '@vue/composition-api'export default {  name: 'app',  setup() {    // 定义 ref 响应式数据    const themeColor = ref('red')    // 把 ref 数据通过 provide 提供的子组件使用    provide('globalColor', themeColor)    // setup 中 return 数据供当前组件的 Template 使用    return {      themeColor    }  },  components: {    LevelOne  }}</script><h2 id="10-template-refs"><a href="#10-template-refs" class="headerlink" title="10. template refs"></a>10. template refs</h2><p>通过 ref() 还可以引用页面上的元素或组件。</p><h3 id="10-1-元素的引用"><a href="#10-1-元素的引用" class="headerlink" title="10.1 元素的引用"></a>10.1 元素的引用</h3><template>   <div>    <h3 ref="h3Ref">TemplateRefOne</h3>  </div></template><script>import { ref, onMounted } from '@vue/composition-api'export default {  setup() {    // 创建一个 DOM 引用    const h3Ref = ref(null)    // 在 DOM 首次加载完毕之后，才能获取到元素的引用    onMounted(() => {      // 为 dom 元素设置字体颜色      // h3Ref.value 是原生DOM对象      h3Ref.value.style.color = 'red'    })    // 把创建的引用 return 出去    return {      h3Ref    }  }}</script><h3 id="10-2-组件的引用"><a href="#10-2-组件的引用" class="headerlink" title="10.2 组件的引用"></a>10.2 组件的引用</h3><p>TemplateRefOne.vue 中的示例代码如下：</p><template>  <div>    <h3>TemplateRefOne</h3><pre><code>&lt;!-- 4. 点击按钮展示子组件的 count 值 --&gt;&lt;button @click=&quot;showNumber&quot;&gt;获取TemplateRefTwo中的count值&lt;/button&gt;&lt;hr /&gt;&lt;!-- 3. 为组件添加 ref 引用 --&gt;&lt;TemplateRefTwo ref=&quot;comRef&quot; /&gt;</code></pre>  </div></template><script>import { ref } from '@vue/composition-api'import TemplateRefTwo from './TemplateRefTwo'export default {  setup() {    // 1. 创建一个组件的 ref 引用    const comRef = ref(null)    // 5. 展示子组件中 count 的值    const showNumber = () => {      console.log(comRef.value.count)    }    // 2. 把创建的引用 return 出去    return {      comRef,      showNumber    }  },  components: {    TemplateRefTwo  }}</script><p>TemplateRefTwo.vue 中的示例代码：</p><ol><li>import { ref } from ‘@vue/composition-api’</li><li></li><li>export default {</li><li>  setup() {</li><li><pre><code>// 1. 定义响应式的数据</code></pre></li><li><pre><code>const count = ref(0)</code></pre></li><li></li><li><pre><code>// 2. 把响应式数据 return 给 Template 使用</code></pre></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>  count</code></pre></li><li><pre><code>&#125;</code></pre></li><li>  }</li><li>}<br></li></ol><h2 id="11-createComponent"><a href="#11-createComponent" class="headerlink" title="11.createComponent"></a>11.createComponent</h2><p>这个函数不是必须的，除非你想要完美结合 TypeScript 提供的类型推断来进行项目的开发。</p><p>这个函数仅仅提供了类型推断，方便在结合 TypeScript 书写代码时，能为 setup() 中的 props 提供完整的类型推断。</p><ol><li>import { createComponent } from ‘vue’</li><li></li><li>export default createComponent({</li><li>  props: {</li><li><pre><code>foo: String</code></pre></li><li>  },</li><li>  setup(props) {</li><li><pre><code>props.foo // &lt;- type: string</code></pre></li><li>  }</li><li>})</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/051216107.html"/>
      <url>2021/051216107.html</url>
      
        <content type="html"><![CDATA[<h1 id="Welcome-to-我的博客-！"><a href="#Welcome-to-我的博客-！" class="headerlink" title="Welcome to 我的博客 ！"></a>Welcome to 我的博客 ！</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
