<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端学习</title>
      <link href="2021/120712750.html"/>
      <url>2021/120712750.html</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript-基础"><a href="#Javascript-基础" class="headerlink" title="Javascript 基础"></a>Javascript 基础</h1><h3 id="day-01"><a href="#day-01" class="headerlink" title="day-01"></a>day-01</h3><h3 id="1-初识-JavaScript"><a href="#1-初识-JavaScript" class="headerlink" title="1. 初识 JavaScript"></a>1. 初识 JavaScript</h3><h4 id="1-1-浏览器执行-JS"><a href="#1-1-浏览器执行-JS" class="headerlink" title="1.1 浏览器执行 JS"></a>1.1 浏览器执行 JS</h4><p><strong>JS 属于高级程序语言</strong></p><p>浏览器分成两部分 渲染引擎和 js 引擎</p><ul><li>渲染引擎：用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的 blink，老版本的 webkit</li><li>Js 引擎：也称为 JS 解释器。用来读取网页中的 JavaScript 代码，对其处理后运行，比如 chrome 浏览器的 V8</li></ul><p><font color="red">浏览器本身并不会执行 JS 代码，而是通过内置 Javscript 引擎（解释器）来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后计算机去执行，所以 Javscript 语言被归为脚本语言，会逐行解释执行</font></p><h4 id="1-2-JS-的组成"><a href="#1-2-JS-的组成" class="headerlink" title="1.2 JS 的组成"></a>1.2 JS 的组成</h4><ul><li>ECMAScript js 语法规范</li><li>Dom 文档对象模型</li><li>Bom 浏览器模型</li></ul><h4 id="1-3-JS-的三中书写位置"><a href="#1-3-JS-的三中书写位置" class="headerlink" title="1.3 JS 的三中书写位置"></a>1.3 JS 的三中书写位置</h4><ul><li>行内写法直接写在 html 中</li><li>内联写法 写在 script 标签里</li><li>外部引入通过 script src 引入外部 js 文件</li></ul><h4 id="1-4-JS-注释"><a href="#1-4-JS-注释" class="headerlink" title="1.4 JS 注释"></a>1.4 JS 注释</h4><ul><li>单行注释 / /</li><li>多行注释 /* */</li></ul><h4 id="1-5-JS-的输出输入语句"><a href="#1-5-JS-的输出输入语句" class="headerlink" title="1.5 JS 的输出输入语句"></a>1.5 JS 的输出输入语句</h4><ul><li>输入语句 prompt（’’）；</li><li>输出语句 alert（’’） ；</li><li>浏览器控制台输出语句 console.log(‘’)；</li></ul><p><strong>总结：第一天简单回顾了一下 JS 的基础小知识 JS 的执行过程 JS 的组成 JS 的书写位置 JS 的注释写法 以及 JS 的输入输出语句 ，明天开始第二天的学习。</strong></p><h3 id="day-02"><a href="#day-02" class="headerlink" title="day-02"></a>day-02</h3><h4 id="1-6-什么是变量"><a href="#1-6-什么是变量" class="headerlink" title="1.6 什么是变量"></a>1.6 什么是变量</h4><p>变量就是在内存中开辟了一块空间来存储数据，通过变量名来找到变量</p><h4 id="1-7-变量的使用"><a href="#1-7-变量的使用" class="headerlink" title="1.7 变量的使用"></a>1.7 变量的使用</h4><ul><li>先声明变量 var 变量名</li><li>变量赋值</li><li>调用变量名</li></ul><p>var age=18； 声明变量并赋值叫做变量的初始化。</p><h4 id="1-8-变量语法扩展"><a href="#1-8-变量语法扩展" class="headerlink" title="1.8 变量语法扩展"></a>1.8 变量语法扩展</h4><ul><li>更新变量值 以最后变量值为准 因为 js 的执行机制</li><li>多个变量同时声明一个 var var name=18,age=36;</li><li>声明变量不赋值 直接调用 输出 undefined</li><li>不声明变量直接调用 控台报错</li><li>不声明变量 赋值 不报错但是作用域是全局作用域容易引起问题 不建议使用</li></ul><h4 id="1-9-变量名命名规范"><a href="#1-9-变量名命名规范" class="headerlink" title="1.9 变量名命名规范"></a>1.9 变量名命名规范</h4><ul><li>字母（A-Zz-a），数字（0-9），下划线（_）,美元符号（$）组成</li><li>严格区分大小写</li><li>不能以数字开头</li><li>不能是关键字 保留字</li><li>遵守驼峰命名 首字母小写 后面单词首字母需要大写</li><li>变量名要有意义</li></ul><h3 id="2-简单数据类型"><a href="#2-简单数据类型" class="headerlink" title="2. 简单数据类型"></a>2. 简单数据类型</h3><h4 id="2-1-为什么需要数据类型"><a href="#2-1-为什么需要数据类型" class="headerlink" title="2.1 为什么需要数据类型"></a>2.1 为什么需要数据类型</h4><p>因为数据的大小不同，所以我们根据变量的大小划分数据类型。</p><p>JS 的变量数据类型只有在程序运行过程中，根据等号右边的值来确定的。</p><p>JS 是动态语言，所以变量的数据类型是可以改变的。</p><p>数据类型分为：简单数据类型 引用数据类型。</p><p>简单数据类型： Number、String 、Undefined、null、Boolean、Symbol</p><p><em>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</em></p><p>引用数据类型：Object、Array、Function</p><h4 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h4><p>8 进制的数字 0-7 我们在数字前加 0 表示八进制</p><p>var num1=010 等于十进制的 8</p><p>16 进制的数字 0-9 a-f 数字前面加 0x 表示十六进制</p><p>var num2=0x9 等于十进制的 9</p><p>1.Number.max_value（）最大值</p><p>2.Number.min_value（）最小值</p><p>3.infinity 无穷大</p><p>4.-infinity 无穷小</p><p>5.NaN 非数字</p><p>consoloe.log（’woshiwenzi’-100）;//输出打印 NaN</p><p>6.isNaN（） 判断是不是一个非数</p><p>如果是一个数字类型将返回 false 如果不是数字类型将返回 true</p><h4 id="2-3-字符串类型-String"><a href="#2-3-字符串类型-String" class="headerlink" title="2.3 字符串类型 String"></a>2.3 字符串类型 String</h4><p>1.什么是字符串：只要带有单引号 或者双引号的不管是文字还是数字都是字符串类型。</p><p>2.字符串的嵌套：外面用单引号里面用双引号或者外面双引号里面单引号</p><p>3.字符串中还有转义字符:例如换行 \n 缩进\t 等等</p><p><img src="/2021/120712750/image-20211205163949909.png" alt="image-20211205163949909"></p><p>4.字符串的长度 用 length 这个属性 如：a 字符串的长度 = a.length</p><p>5.字符串的拼接需要用 +号来进行拼接</p><h4 id="任何类型和字符串相加都会变成字符串！！！"><a href="#任何类型和字符串相加都会变成字符串！！！" class="headerlink" title="任何类型和字符串相加都会变成字符串！！！"></a>任何类型和字符串相加都会变成字符串！！！</h4><h4 id="2-4-Boolean-布尔型"><a href="#2-4-Boolean-布尔型" class="headerlink" title="2.4 Boolean 布尔型"></a>2.4 Boolean 布尔型</h4><p>布尔型有两个值：true（真） 和 false（假）；</p><p>当参与数学运算时：true 可以当做 1 来运算， false 则可以当做 0 来运算。</p><h4 id="2-5-Undefined-和-null"><a href="#2-5-Undefined-和-null" class="headerlink" title="2.5 Undefined 和 null"></a>2.5 Undefined 和 null</h4><p>undefined：只声明了变量，但是并不赋值。如果进行相加时要注意结果。</p><p>null：一个变量给 null 值，里面存的值为空。</p><p>undefined+字符串=字符串类型</p><p>undefined+数字型=NaN</p><p>undefined+false/true=NaN</p><h3 id="3-获取数据类型"><a href="#3-获取数据类型" class="headerlink" title="3. 获取数据类型"></a>3. 获取数据类型</h3><h4 id="3-1-typeof-检验数据类型"><a href="#3-1-typeof-检验数据类型" class="headerlink" title="3.1 typeof 检验数据类型"></a>3.1 typeof 检验数据类型</h4><p>typeof 可以检验数据类型是那一种</p><p>var age=18；</p><p>console.log（typeof age）；</p><h4 id="3-2-字面量"><a href="#3-2-字面量" class="headerlink" title="3.2 字面量"></a>3.2 字面量</h4><p>字面量就是代码中固定值得表示法，就是你一看上去就知道这是个什么类型的值</p><ul><li>数字字面量：8,6,12</li><li>字符串字面量：’我好’,’你好’</li><li>布尔字面量：true ， false</li></ul><h4 id="3-3-转换字符串类型"><a href="#3-3-转换字符串类型" class="headerlink" title="3.3 转换字符串类型"></a>3.3 转换字符串类型</h4><ol><li><p>toString（）方法 变量.toString（）</p></li><li><p>String（） 方法 String（变量）</p></li><li><p>与字符串相加 转为字符串类型 隐式转换</p></li></ol><ul><li>通常最常用的就是与字符串相加的这种方法</li></ul><h4 id="3-4-转换数字型（重点-）"><a href="#3-4-转换数字型（重点-）" class="headerlink" title="3.4 转换数字型（重点*）"></a>3.4 转换数字型（重点*）</h4><ol><li>parseInt（变量） 取整数</li><li>parseFloat（变量）有小数点就保留小数</li><li>Number（变量）</li><li>隐式转换 运用 - / * 运算符 进行隐式转换</li></ol><h4 id="3-5-转换布尔型"><a href="#3-5-转换布尔型" class="headerlink" title="3.5 转换布尔型"></a>3.5 转换布尔型</h4><p>Boolean（变量）只有这一种方法</p><ul><li>当变量值为 ‘ ‘,0,NaN,undefined,null 这五种时会转为 false</li><li>其余值全转为 true</li></ul><h2 id="day-03"><a href="#day-03" class="headerlink" title="day-03"></a>day-03</h2><h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h3><h4 id="运算符都很多种分为"><a href="#运算符都很多种分为" class="headerlink" title="运算符都很多种分为"></a>运算符都很多种分为</h4><ul><li>算数运算符</li><li>逻辑运算符</li><li>递增递减运算符</li><li>比较运算符</li><li>赋值运算符</li></ul><h4 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h4><p>加减乘除 取余%</p><h4 id="4-2-递增递减运算符"><a href="#4-2-递增递减运算符" class="headerlink" title="4.2 递增递减运算符"></a>4.2 递增递减运算符</h4><ul><li>++在前先自增加一后返回值</li><li>++在后先返回值在自增加一</li></ul><p><strong>必须和变量搭配使用不能和数字使用</strong></p><p><strong>开发中经常使用后置++</strong></p><h4 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a>4.3 比较运算符</h4><p>就是用来两个值相比较的运算符会返回布尔值 一个=号是赋值 ！= 不等号 ===全等 要求数据类型 值全部一致 ==两个等号是等于的意思会转换数据类型</p><p>其余都是基本的运算符 &gt; &lt; = &gt;= &lt;=</p><p><img src="/2021/120712750/image-20211206093643887.png" alt="image-20211206093643887"></p><h4 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h4><p>&amp;&amp; 逻辑与 当在表达式中有一侧值为 false 结果就返回 false</p><p>||逻辑或 当表达式中有一侧为真 结果就为真</p><p>！非 取反</p><p><strong>逻辑中断（短路运算）</strong></p><ul><li>逻辑与的短路运算 当第一个值为 false 时 直接返回第一个值 当两个值都为 true 时返回第二个值</li><li>逻辑或的短路运算 当第一个值为 true 时 返回第一个值 当两个值都为 false 时返回第二个值</li></ul><h4 id="4-5-赋值运算符"><a href="#4-5-赋值运算符" class="headerlink" title="4.5 赋值运算符"></a>4.5 赋值运算符</h4><p>= += -= *= /= %=</p><ul><li>=号 赋值</li><li>+= 每次加完之后的结果赋值</li><li>-=和+=同理</li></ul><h4 id="4-6-运算符的优先级"><a href="#4-6-运算符的优先级" class="headerlink" title="4.6 运算符的优先级"></a>4.6 运算符的优先级</h4><p><img src="/2021/120712750/image-20211206100109347.png" alt="image-20211206100109347"></p><ul><li>一元运算符里面的逻辑非优先级很高</li><li>逻辑与比逻辑或优先级高</li></ul><h3 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a>5. 流程控制</h3><h4 id="5-1-什么是流程控制"><a href="#5-1-什么是流程控制" class="headerlink" title="5.1 什么是流程控制"></a>5.1 什么是流程控制</h4><p>流程控制分为：顺序流程控制 循环流程控制 分支流程控制 来控制你代码的执行</p><h4 id="5-2-顺序流程控制"><a href="#5-2-顺序流程控制" class="headerlink" title="5.2 顺序流程控制"></a>5.2 顺序流程控制</h4><p>按照你书写的顺序，从上往下执行。</p><h4 id="5-3-分支流程控制-if-else-语句"><a href="#5-3-分支流程控制-if-else-语句" class="headerlink" title="5.3 分支流程控制 if else 语句"></a>5.3 分支流程控制 if else 语句</h4><p>当你满足了（）里面的条件时执行大括号里面的代码段当你不满足条件时 执行 else 里的代码段</p><p>if（条件）{</p><p>执行代码段</p><p>}else{</p><p>执行语句</p><p>}</p><p>多分支语句就是有多个条件 如果第一个条件不满足时判断第二个是否满足</p><p>else if（）</p><h4 id="5-4-三元表达式"><a href="#5-4-三元表达式" class="headerlink" title="5.4 三元表达式"></a>5.4 三元表达式</h4><p>条件判断 ？ 条件为真时返回这个:条件为假时返回这个；</p><p>10&gt;5? ‘是的’:’不是的’</p><h4 id="5-5-switch-语句"><a href="#5-5-switch-语句" class="headerlink" title="5.5 switch 语句"></a>5.5 switch 语句</h4><p>switch 是通过特定的值来进行准确匹配比 if else 更快速精准</p><p>开发中一般表达式用变量保存 所以写变量</p><p>我们 switch（）中的值和 case 选项值是全等要求全等===</p><p>switch(条件表达式){</p><p>case 匹配选项值:</p><p>执行代码；</p><p>break；</p><p>default 匹配不上：</p><p>执行代码</p><p>}</p><h4 id="5-6-switch-和-ifelse-的区别"><a href="#5-6-switch-和-ifelse-的区别" class="headerlink" title="5.6 switch 和 ifelse 的区别"></a>5.6 switch 和 ifelse 的区别</h4><ul><li>if else 更适合用于判断范围类 switch 适合用于知道准确的值</li><li>分支多的情况下用 switch 效率更高</li><li>分支少的时候用 if else 更好</li></ul><h3 id="6-循环"><a href="#6-循环" class="headerlink" title="6. 循环"></a>6. 循环</h3><h4 id="6-1-循环的目的"><a href="#6-1-循环的目的" class="headerlink" title="6.1 循环的目的"></a>6.1 循环的目的</h4><p>可以重复执行一些代码</p><h4 id="6-2-for-循环"><a href="#6-2-for-循环" class="headerlink" title="6.2 for 循环"></a>6.2 for 循环</h4><p>for（条件表达式）{</p><p>循环体</p><p>}</p><h4 id="6-3-双重-for-循环"><a href="#6-3-双重-for-循环" class="headerlink" title="6.3 双重 for 循环"></a>6.3 双重 for 循环</h4><p>循环嵌套:第一层 for 循环是决定要循环几次内层 for 循环决定了你一次循环要操作几次。</p><h4 id="6-4-while-循环"><a href="#6-4-while-循环" class="headerlink" title="6.4 while 循环"></a>6.4 while 循环</h4><p>while（当条件为真时）{</p><p>执行循环体</p><p>计数器的更新</p><p>}</p><h4 id="6-5-do-while-循环"><a href="#6-5-do-while-循环" class="headerlink" title="6.5 do while 循环"></a>6.5 do while 循环</h4><p>do{</p><p>循环体</p><p>更新计数器；</p><p>}while（条件表达式）</p><p>do while 循环不论条件是否为真，都至少执行一次循环。</p><h4 id="6-6-continue-和-break-关键字"><a href="#6-6-continue-和-break-关键字" class="headerlink" title="6.6 continue 和 break 关键字"></a>6.6 continue 和 break 关键字</h4><p><strong>continue：跳过本次循环，执行后面的循环。</strong></p><p><strong>break：直接终止循环，后面的也不执行</strong></p><h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h3><h4 id="7-1-什么是数组"><a href="#7-1-什么是数组" class="headerlink" title="7.1 什么是数组"></a>7.1 什么是数组</h4><p>数组就是一组数据存放在一个变量下的集合</p><h4 id="7-2-创建数组"><a href="#7-2-创建数组" class="headerlink" title="7.2 创建数组"></a>7.2 创建数组</h4><ul><li>var 变量名= new Array（）</li><li>利用数组字面量[] 来创建</li></ul><h4 id="7-3-访问数组元素"><a href="#7-3-访问数组元素" class="headerlink" title="7.3 访问数组元素"></a>7.3 访问数组元素</h4><p>数组当中有许多元素 想要获取某一个元素我们需要使用下标。</p><p>下标是从数组的第一个元素开始从 0 开始</p><p>数组名[你想获取元素的下标号]</p><h4 id="7-4-遍历数组"><a href="#7-4-遍历数组" class="headerlink" title="7.4 遍历数组"></a>7.4 遍历数组</h4><ul><li>使用 for 循环遍历数组</li><li>for each 循环</li><li>for of 循环</li><li>map 遍历</li><li>some 遍历</li><li>find 遍历</li><li>every 遍历</li><li>filter 遍历</li><li>reduce 遍历</li></ul><h4 id="7-5-数组的长度"><a href="#7-5-数组的长度" class="headerlink" title="7.5 数组的长度"></a>7.5 数组的长度</h4><p>length 属性就是长度</p><p>数组名.length</p><h2 id="day-04"><a href="#day-04" class="headerlink" title="day-04"></a>day-04</h2><h4 id="7-6-数组新增元素"><a href="#7-6-数组新增元素" class="headerlink" title="7.6 数组新增元素"></a>7.6 数组新增元素</h4><ul><li>通过 arr.length 修改长度来扩展数组 但是多出来的元素由于你没有赋值所以是空元素</li><li>通过索引 当数组里没有这个索引时就会扩充数组 如果已经有这个索引就会覆盖</li></ul><h3 id="8-函数-function（）"><a href="#8-函数-function（）" class="headerlink" title="8. 函数 function（）"></a>8. 函数 function（）</h3><h4 id="8-1-函数的概念"><a href="#8-1-函数的概念" class="headerlink" title="8.1 函数的概念"></a>8.1 函数的概念</h4><p>函数就是把一些重复使用率高的代码块封装到一起</p><h4 id="8-2-函数的使用"><a href="#8-2-函数的使用" class="headerlink" title="8.2 函数的使用"></a>8.2 函数的使用</h4><p>声明函数： function 函数名（）{ 函数体的代码}</p><p>调用函数：函数名（）</p><h4 id="8-3-参数的使用"><a href="#8-3-参数的使用" class="headerlink" title="8.3 参数的使用"></a>8.3 参数的使用</h4><p>参数分为：形参 和实参</p><ul><li>形参：在函数声明时小括号里的参数就是形参 可以把参数看成 赋值 形参=实参</li><li>实参：在调用函数时小括号里的参数就是实参</li></ul><p>作用：参数的作用主要是让函数体执行不同的代码</p><p>形参和实参个数匹配</p><ul><li>形参个数多余实参的个数 形参回去匹配实参 多出来的默认值是 undefined</li><li>形参少于实参 多出来的形参默认值是 undefined</li><li>形参等于实参 一切正常</li></ul><p><strong>JS 中函数形参的默认值是 undefined</strong></p><h4 id="8-4-函数的返回值"><a href="#8-4-函数的返回值" class="headerlink" title="8.4 函数的返回值"></a>8.4 函数的返回值</h4><p>函数只是执行一段代码 最终的结果返回给调用者我们需要 用 return</p><p>return 要返回的结果</p><p>可以看成 return 返回的结果 = 调用者（）</p><p><strong>实际开发中用一个变量来接受函数返回值</strong></p><p><strong>函数返回值的注意事项：</strong></p><ul><li>return 既是返回结果又是终止函数 return 后面的代码就不会执行了</li><li>return 只能返回一个结果如果有多个结果的话以最后一个为准 如果想要返回多个结果 可以以数组的形式</li><li>如果函数体内有 return 那么将返回 return 后面的结果 如果没有 return 的话那么将返回 undefined</li></ul><p><strong>break，continue，return 的区别</strong></p><ul><li><strong>break：结束当前循环体；</strong></li><li><strong>continue：跳出本次循环，执行下一次循环；</strong></li><li><strong>return：不仅可以退出循环，还可以返回 return 语句中的值，同时还可以结束当前函数体的代码。</strong></li></ul><h4 id="8-5-Arguments-的使用"><a href="#8-5-Arguments-的使用" class="headerlink" title="8.5 Arguments 的使用"></a>8.5 Arguments 的使用</h4><p>arguments 是函数中内置的一个对象 ，当我们不知道要传入几个参数的时候 我们在使用 arguments。</p><p>arguments 是一个伪数组 ，具有数组的某一些特性。</p><p><strong>伪数组</strong>:</p><ul><li>具有数组的 length 属性</li><li>可以使用索引</li><li>但是他没有真正数组的方法比如 pop（） push（） shift（）等</li></ul><h4 id="8-6-函数可以调用另一个函数"><a href="#8-6-函数可以调用另一个函数" class="headerlink" title="8.6 函数可以调用另一个函数"></a>8.6 函数可以调用另一个函数</h4><h3 id="9-Javascript-作用域"><a href="#9-Javascript-作用域" class="headerlink" title="9. Javascript 作用域"></a>9. Javascript 作用域</h3><h4 id="9-1-什么是作用域"><a href="#9-1-什么是作用域" class="headerlink" title="9.1 什么是作用域"></a>9.1 什么是作用域</h4><p>作用域：就是代码名字有效的范围就叫作用域</p><p>目的：是为了减少变量冲突</p><p>全局作用域：在整个 script 标签或者外部 js 文件中的作用范围。</p><p>局部作用域：在函数内部就是局部作用域。</p><h4 id="9-2-全局变量和局部变量"><a href="#9-2-全局变量和局部变量" class="headerlink" title="9.2 全局变量和局部变量"></a>9.2 全局变量和局部变量</h4><p>全局变量：全局变量在全部作用域下都可以使用，包括函数内。</p><p>局部变量：局部变量只能在局部使用。</p><p>区别：全局变量比较影响内存要关闭浏览器才会销毁，而局部变量只要代码块运行结束后就会销毁占用内存少。</p><p><strong>es5 中没有块级作用域</strong></p><p>块级作用域：{}内就是块级作用域</p><h4 id="9-3-作用域链"><a href="#9-3-作用域链" class="headerlink" title="9.3 作用域链"></a>9.3 作用域链</h4><p>作用域链：内部函数访问外部函数变量，要向上查找如果外部函数没有就在往上一级查找，这种链式结构我们称为作用域链。</p><h3 id="10-预解析"><a href="#10-预解析" class="headerlink" title="10. 预解析"></a>10. 预解析</h3><p>JS 引擎执行代码的过程：</p><ol><li>先预解析 当碰到 var 关键字时会把声明变量提升到当前作用域的最前面但是赋值不提升 当碰到 funtion 声明函数时会把 function 包括里面一整段全部提升到当前作用域最前面但是如果是函数表达式时只提升 var 函数名 所以函数表达式写法必须写声明在调用。</li><li>在执行代码 按照书写的顺序从上往下依次执行。</li></ol><h3 id="11-对象"><a href="#11-对象" class="headerlink" title="11. 对象"></a>11. 对象</h3><h4 id="11-1-什么是对象"><a href="#11-1-什么是对象" class="headerlink" title="11.1 什么是对象"></a>11.1 什么是对象</h4><p>JS 中对象是一组无序的属性和方法的集合，所有的事务都是对象，比如字符串 ， 数值，数组，函数等。</p><p>对象由属性和方法组成。</p><h4 id="11-2-为什么需要对象"><a href="#11-2-为什么需要对象" class="headerlink" title="11.2 为什么需要对象"></a>11.2 为什么需要对象</h4><p>对象保存的信息更加清晰</p><h4 id="11-3-创建对象"><a href="#11-3-创建对象" class="headerlink" title="11.3 创建对象"></a>11.3 创建对象</h4><h5 id="11-3-1-字面量创建对象"><a href="#11-3-1-字面量创建对象" class="headerlink" title="11.3-1 字面量创建对象"></a>11.3-1 字面量创建对象</h5><p>var obj={添写对象属性，方法}</p><p>调用对象：对象名.属性名 对象名.方法名()</p><p>属性 ，变量，函数，方法的区别：</p><ul><li>变量是单独声明的 可以单独使用</li><li>属性声明在对象里 调用的时候 对象.属性名</li><li>函数是单独声明 调用时 函数名（）</li><li>方法生命在对象里 调用的时候 对象名.方法名（）</li></ul><h5 id="11-3-2-new-Object-创建对象"><a href="#11-3-2-new-Object-创建对象" class="headerlink" title="11.3-2 new Object 创建对象"></a>11.3-2 new Object 创建对象</h5><p>var 对象名 = new Object（）；</p><p>添加属性方法时: 对象名.属性名= 内容 对象名.方法名=function（）{要执行的操作}</p><p>这个方法我们是利用变量赋值的形式来创建的</p><h5 id="11-3-3-构造函数创建对象"><a href="#11-3-3-构造函数创建对象" class="headerlink" title="11.3-3 构造函数创建对象"></a>11.3-3 构造函数创建对象</h5><p>构造函数可以抽取公共的属性和方法 可以复用</p><p>function Obj（）{</p><p>this.属性名=属性值；</p><p>this.方法名=function（）{</p><p>}</p><p>}</p><p>调用：new Obj（）</p><p>注意：</p><ul><li>构造函数名开头必须大写</li><li>调用构造函数时必须 new 一下</li><li>构造函数不需要 return 自己就能返回结果</li><li>属性方法前面必须要加 this</li><li>我们只需要 new 方法名() 就能调用函数创建一个对象</li></ul><h4 id="11-4-构造函数和对象的区别"><a href="#11-4-构造函数和对象的区别" class="headerlink" title="11.4 构造函数和对象的区别"></a>11.4 构造函数和对象的区别</h4><p>构造函数：抽取了对象的公共部分 泛指某一类 比如 球类。</p><p>对象：具体到某一个事物 比如篮球</p><p>new 构造函数（）出一个对象也叫实例化！！</p><h4 id="11-5-new-关键字的执行过程"><a href="#11-5-new-关键字的执行过程" class="headerlink" title="11.5 new 关键字的执行过程"></a>11.5 new 关键字的执行过程</h4><ol><li>首先在内存中开辟了一个空间来存放空对象</li><li>this 指向了我们创建的空对象</li><li>执行代码块 给空对象添加属性方法</li><li>返回这个对象 所以构造函数不需要 return</li></ol><h4 id="11-6-遍历对象"><a href="#11-6-遍历对象" class="headerlink" title="11.6 遍历对象"></a>11.6 遍历对象</h4><p>for（变量 in 对象名）{</p><p>console.log(变量 )输出的是属性名</p><p>console.log（对象名【变量】）输出的是属性值</p><p>}</p><p>变量名最好使用 k 或者 key。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你会用到的15个前端小知识</title>
      <link href="2021/060219214.html"/>
      <url>2021/060219214.html</url>
      
        <content type="html"><![CDATA[<h1 id="你会用到的-15-个前端小知识"><a href="#你会用到的-15-个前端小知识" class="headerlink" title="你会用到的 15 个前端小知识"></a>你会用到的 15 个前端小知识</h1><h3 id="1-css-一行文本超出…"><a href="#1-css-一行文本超出…" class="headerlink" title="1. css 一行文本超出…"></a>1. css 一行文本超出…</h3><pre><code class="css">overflow: hidden;text-overflow:ellipsis;white-space: nowrap;</code></pre><h3 id="2-多行文本超出显示…"><a href="#2-多行文本超出显示…" class="headerlink" title="2.多行文本超出显示…"></a>2.多行文本超出显示…</h3><pre><code class="css">display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;</code></pre><h3 id="3-IOS-手机容器滚动条滑动不流畅"><a href="#3-IOS-手机容器滚动条滑动不流畅" class="headerlink" title="3.IOS 手机容器滚动条滑动不流畅"></a>3.IOS 手机容器滚动条滑动不流畅</h3><pre><code class="css">overflow: auto;-webkit-overflow-scrolling: touch;</code></pre><h3 id="4-修改滚动条样式"><a href="#4-修改滚动条样式" class="headerlink" title="4.修改滚动条样式"></a>4.修改滚动条样式</h3><p>隐藏 div 元素的滚动条</p><pre><code class="css">cdiv::-webkit-scrollbar &#123;``    display: none;&#125;</code></pre><ul><li>div::-webkit-scrollbar 滚动条整体部分</li><li>div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条</li><li>div::-webkit-scrollbar-track 滚动条的轨道（里面装有 Thumb</li><li>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置</li><li>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去</li><li>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</li><li>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。</li></ul><h3 id="5-使用-css-写出一个三角形角标"><a href="#5-使用-css-写出一个三角形角标" class="headerlink" title="5.使用 css 写出一个三角形角标"></a>5.使用 css 写出一个三角形角标</h3><p>元素宽高设置为 0，通过 border 属性来设置，让其它三个方向的 border 颜色为透明或者和背景色保持一致，剩余一条 border 的颜色设置为需要的颜色。</p><pre><code class="css">div &#123;    width: 0;    height: 0;    border: 5px solid #transparent;    border-top-color: red;&#125;</code></pre><h3 id="6-解决-ios-audio-无法自动播放、循环播放的问题"><a href="#6-解决-ios-audio-无法自动播放、循环播放的问题" class="headerlink" title="6.解决 ios audio 无法自动播放、循环播放的问题"></a>6.解决 ios audio 无法自动播放、循环播放的问题</h3><p>ios 手机在使用 audio 或者 video 播放的时候，个别机型无法实现自动播放，可使用下面的代码 hack。</p><pre><code class="js">// 解决ios audio无法自动播放、循环播放的问题var music = document.getElementById(&#39;video&#39;);var state = 0;document.addEventListener(&#39;touchstart&#39;, function()&#123;    if(state==0)&#123;        music.play();        state=1;    &#125;&#125;, false);document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123;    music.play();&#125;, false);//循环播放music.onended = function () &#123;    music.load();    music.play();&#125;</code></pre><h3 id="7-水平垂直居中"><a href="#7-水平垂直居中" class="headerlink" title="7.水平垂直居中"></a>7.水平垂直居中</h3><p>我一般只使用两种方式 定位 或者 flex，我觉得够用了。</p><pre><code class="css">div &#123;    width: 100px;    height: 100px;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;&#125;</code></pre><p>父级控制子集居中</p><pre><code class="css">.parent &#123;    display: flex;    justify-content: center;    align-items: center;&#125;</code></pre><h3 id="8-隐藏页面元素"><a href="#8-隐藏页面元素" class="headerlink" title="8.隐藏页面元素"></a>8.隐藏页面元素</h3><ul><li>display-none: 元素不存在，从 dom 中删除</li><li>opacity-0: 元素透明度将为 0，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</li><li>visibility-hidden：元素隐藏，但元素仍旧存在，页面中无法触发该元素的事件。</li></ul><h3 id="9-前端工程化"><a href="#9-前端工程化" class="headerlink" title="9.前端工程化"></a>9.前端工程化</h3><p>一提到前端工程化很多人想到的都是 webpack，这是不对的，webpack 仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。 前端工程化是通过工具提升效率，降低成本的一种手段。 近些年被广泛的关注和探讨，究其原因主要是因为现代化前端应用功能要求不断提高，业务逻辑日益复杂，作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半壁江山。从传统的网站，到现在的 H5,移动 App,桌面应用，以及小程序。前端技术几乎是无所不能的全面覆盖。 在这些表象的背后呢，实际上是行业对开发人员的要求发生了天翻地覆的变化，以往前端写 demo，套模板，调页面这种刀耕火种的方式已经完全不符合当下对开发效率的要求，前端工程化就是在这样一个背景下被提上台面，成为前端工程师必备的手段之一。 一般来说前端工程包含，项目初始化，项目开发，集成，构建，打包，测试，部署等流程。工程化就是以工程的角度来解决这些问题。比如项目初始化我们一般使用 npm init, 创建页面模板使用 plop，我们喜欢使用 ES6+开发，但是需要通过 babel 编码成 ES5，持续集成的时候我们使用 git，但是为了保持开发规范我们引入了 ESLint，部署一般使用 ci/cd 或者 jenkins 等等。 前端工程化是一个比较大的话题，后面我们会单开话题来讲。</p><h3 id="10-contenteditable"><a href="#10-contenteditable" class="headerlink" title="10.contenteditable"></a>10.contenteditable</h3><p>html 中大部分标签都是不可以编辑的，但是添加了 contenteditable 属性之后，标签会变成可编辑状态。</p><pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><p>不过通过这个属性把标签变为可编辑状态后只有 input 事件，没有 change 事件。也不能像表单一样通过 maxlength 控制最大长度。我也忘记我在什么情况下用到过了，后面想起来再补吧。</p><h3 id="11-calc"><a href="#11-calc" class="headerlink" title="11.calc"></a>11.calc</h3><p>这是一个 css 属性，我一般称之为 css 表达式。可以计算 css 的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出 20px 是啥。</p><pre><code class="css">div &#123;    width: calc(25% - 20px);&#125;</code></pre><h3 id="12-Proxy-和-Object-defineProperty-区别"><a href="#12-Proxy-和-Object-defineProperty-区别" class="headerlink" title="12.Proxy 和 Object.defineProperty 区别"></a>12.Proxy 和 Object.defineProperty 区别</h3><p>Proxy 的意思是代理，我一般教他拦截器，可以拦截对象上的一个操作。用法如下，通过 new 的方式创建对象，第一个参数是被拦截的对象，第二个参数是对象操作的描述。实例化后返回一个新的对象，当我们对这个新的对象进行操作时就会调用我们描述中对应的方法。</p><pre><code class="js">new Proxy(target, &#123;    get(target, property) &#123;    &#125;,    set(target, property) &#123;    &#125;,    deleteProperty(target, property) &#123;    &#125;&#125;)</code></pre><p>Proxy 区别于 Object.definedProperty。 Object.defineProperty 只能监听到属性的读写，而 Proxy 除读写外还可以监听属性的删除，方法的调用等。 通常情况下我们想要监视数组的变化，基本要依靠重写数组方法的方式实现，这也是 Vue 的实现方式，而 Proxy 可以直接监视数组的变化。</p><pre><code class="js">const list = [1, 2, 3];const listproxy = new Proxy(list, &#123;    set(target, property, value) &#123;        target[property] = value;        return true; // 标识设置成功    &#125;&#125;);list.push(4);</code></pre><p>Proxy 是以非入侵的方式监管了对象的读写，而 defineProperty 需要按特定的方式定义对象的属性。</p><h3 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13.Reflect"></a>13.Reflect</h3><p>他是 ES2015 新增的对象，纯静态对象也就是不能被实例画，只能通过静态方法的方式调用，和 Math 对象类似，只能类似 Math.random 的方式调用。 Reflect 内部封装了一系列对对象的底层操作，一共 14 个，其中 1 个被废弃，还剩下 13 个。 Reflect 的静态方法和 Proxy 描述中的方法完全一致。也就是说 Reflect 成员方法就是 Proxy 处理对象的默认实现。 Proxy 对象默认的方法就是调用了 Reflect 内部的处理逻辑，也就是如果我们调用 get 方法，那么在内部，proxy 就是将 get 原封不动的交给了 Reflect，如下。</p><pre><code class="js">const proxy = new Proxy(obj, &#123;    get(target, property) &#123;        return Reflect.get(target, property);    &#125;&#125;)</code></pre><p>Reflect 和 Proxy 没有绝对的关系，我们一般将他们两个放在一起讲是为了方便对二者的理解。 那为什么会有 Reflect 对象呢，其实他最大的用处就是提供了一套统一操作 Object 的 API。判断对象是否存在某一个属性，可以使用 in 操作符，但是不够优雅，还可以使用 Reflect.has(obj, name); 删除一个属性可以使用 delete，也可以使用 Reflect.deleteProperty(obj, name); 获取所有属性名可以使用 Object.keys, 也可以使用 Reflect.ownKeys(obj); 我们更推荐使用 Reflect 的 API 来操作对象，因为他才是未来。</p><h3 id="14-解析-get-参数"><a href="#14-解析-get-参数" class="headerlink" title="14.解析 get 参数"></a>14.解析 get 参数</h3><p>通过 replace 方法获取 url 中的参数键值对，可以快速解析 get 参数。</p><pre><code class="js">const q = &#123;&#125;;location.search.replace(/([^?&amp;=]+)=([^&amp;]+)/g,(_,k,v)=&gt;q[k]=v);console.log(q);</code></pre><h3 id="15-解析连接-url"><a href="#15-解析连接-url" class="headerlink" title="15.解析连接 url"></a>15.解析连接 url</h3><p>可以通过创建 a 标签，给 a 标签赋值 href 属性的方式，获取到协议，pathname，origin 等 location 对象上的属性。</p><pre><code class="js">// 创建a标签const aEle = document.createElement(&#39;a&#39;);// 给a标签赋值href路径aEle.href = &#39;/test.html&#39;;// 访问aEle中的属性aEle.protocol; // 获取协议aEle.pathname; // 获取pathaEle.origin;aEle.host;aEle.search;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3+vite创建项目</title>
      <link href="2021/051326278.html"/>
      <url>2021/051326278.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue3-vite创建项目"><a href="#vue3-vite创建项目" class="headerlink" title="vue3+vite创建项目"></a>vue3+vite创建项目</h1><h2 id="1-全局安装create-vite-app"><a href="#1-全局安装create-vite-app" class="headerlink" title="1. 全局安装create-vite-app"></a>1. 全局安装create-vite-app</h2><ol><li>yarn global add <a href="mailto:&#x63;&#x72;&#101;&#97;&#x74;&#x65;&#45;&#x76;&#105;&#116;&#101;&#x2d;&#x61;&#112;&#x70;&#x40;&#x31;&#x2e;&#x31;&#56;&#46;&#x30;">&#x63;&#x72;&#101;&#97;&#x74;&#x65;&#45;&#x76;&#105;&#116;&#101;&#x2d;&#x61;&#112;&#x70;&#x40;&#x31;&#x2e;&#x31;&#56;&#46;&#x30;</a></li></ol><h2 id="2-创建项目目录"><a href="#2-创建项目目录" class="headerlink" title="2.创建项目目录"></a>2.创建项目目录</h2><pre><code> cva vue3-ui 或者 create-vite-app vue3-ui    </code></pre><h2 id="Vue-2-和-Vue-3-的区别"><a href="#Vue-2-和-Vue-3-的区别" class="headerlink" title="Vue 2 和 Vue 3 的区别"></a>Vue 2 和 Vue 3 的区别</h2><p>90% 的写法完全一致，除了以下几点</p><ul><li>Vue 3 的 Template 支持多个根标签，Vue 2 不支持</li><li>Vue 3 有 createApp()，而 Vue 2 的是 new Vue()</li><li>createApp(组件)，new Vue({template, render})</li></ul><h2 id="3-引入Vue-Router4"><a href="#3-引入Vue-Router4" class="headerlink" title="3.引入Vue Router4"></a>3.引入Vue Router4</h2><p><img src="/2021/051326278/1.jpg"></p><h3 id="3-1-使用命令行查看vue-router-所有版本号"><a href="#3-1-使用命令行查看vue-router-所有版本号" class="headerlink" title="3.1. 使用命令行查看vue-router 所有版本号"></a>3.1. 使用命令行查看vue-router 所有版本号</h3><ol><li>npm info vue-router versions</li></ol><h3 id="安装最新的-x76-x75-x65-45-x72-x6f-117-x74-101-114-x40-x34-x2e-x30-x2e-48-45-x62-x65-116-97-x2e-x36"><a href="#安装最新的-x76-x75-x65-45-x72-x6f-117-x74-101-114-x40-x34-x2e-x30-x2e-48-45-x62-x65-116-97-x2e-x36" class="headerlink" title="安装最新的&#x76;&#x75;&#x65;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#114;&#x40;&#x34;&#x2e;&#x30;&#x2e;&#48;&#45;&#x62;&#x65;&#116;&#97;&#x2e;&#x36;"></a>安装最新的<a href="mailto:&#x76;&#x75;&#x65;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#114;&#x40;&#x34;&#x2e;&#x30;&#x2e;&#48;&#45;&#x62;&#x65;&#116;&#97;&#x2e;&#x36;">&#x76;&#x75;&#x65;&#45;&#x72;&#x6f;&#117;&#x74;&#101;&#114;&#x40;&#x34;&#x2e;&#x30;&#x2e;&#48;&#45;&#x62;&#x65;&#116;&#97;&#x2e;&#x36;</a></h3><ol><li>yarn add <a href="mailto:&#x76;&#x75;&#x65;&#x2d;&#114;&#x6f;&#x75;&#116;&#101;&#x72;&#64;&#x34;&#x2e;&#x30;&#46;&#x30;&#x2d;&#x62;&#x65;&#x74;&#97;&#x2e;&#x36;">&#x76;&#x75;&#x65;&#x2d;&#114;&#x6f;&#x75;&#116;&#101;&#x72;&#64;&#x34;&#x2e;&#x30;&#46;&#x30;&#x2d;&#x62;&#x65;&#x74;&#97;&#x2e;&#x36;</a></li></ol><h3 id="3-2-初始化vue-router"><a href="#3-2-初始化vue-router" class="headerlink" title="3.2. 初始化vue-router"></a>3.2. 初始化vue-router</h3><h4 id="1-新建-history-对象"><a href="#1-新建-history-对象" class="headerlink" title="(1).新建 history 对象"></a>(1).新建 history 对象</h4><ol><li>import {createWebHashHistory, createRouter} from ‘vue-router’</li><li>const history = createWebHashHistory()</li></ol><h4 id="2-新建-router-对象"><a href="#2-新建-router-对象" class="headerlink" title="(2). 新建 router 对象"></a>(2). 新建 router 对象</h4><ol><li>const router = createRouter()</li></ol><h4 id="3-引入typescript"><a href="#3-引入typescript" class="headerlink" title="(3)引入typescript"></a>(3)引入typescript</h4><p>把main.js文件改为main.ts，我们会发现有很多报错 报错1：createRouter里面需要传入一个参数，但我们却传入了0个 解决：</p><blockquote></blockquote><pre><code>const router = createRouter(&#123;     history,     routes: [     &#123; path: &#39;/&#39;, component: Lifa &#125;    ]&#125;)</code></pre><blockquote></blockquote><p>报错2：.vue类型的文件提示cannot find module xxx.vue 原因ts只能理解.ts为后缀的文件，无法理解.vue文件 解决方法:</p><ul><li>Google 搜索 Vue 3 can not find module</li><li>创建 xxx.d.ts，告诉 TS 如何理解 .vue 文件</li><li>src/shims-vue.d.ts</li></ul><blockquote></blockquote><pre><code>declare module &#39;*.vue&#39; &#123; import &#123; Component &#125; from &#39;vue&#39; const component: Component export default component&#125;   </code></pre><blockquote></blockquote><p>这里要注意如果我们用的是vscode这时报错已经没了，但是如果我们用的是webstrom编辑器它还是会 报同样的错误，我们需要再额外的安装ts，然后初始化ts配置</p><blockquote></blockquote><pre><code>yarn add typescript -Dtsc --init</code></pre><blockquote></blockquote><p>这样报错就会解决了</p><h4 id="4-使用router"><a href="#4-使用router" class="headerlink" title="(4)使用router"></a>(4)使用router</h4><blockquote></blockquote><pre><code>const app = createApp(App)app.use(router)app.mount(&#39;#app&#39;)</code></pre><blockquote></blockquote><h4 id="5-添加-router-view"><a href="#5-添加-router-view" class="headerlink" title="(5)添加 router-view"></a>(5)添加 router-view</h4><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code>&lt;template&gt;  &lt;div&gt;hi&lt;/div&gt;  &lt;router-view/&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name: &#39;App&#39;&#125;&lt;/script&gt;</code></pre><blockquote></blockquote><h4 id="6-添加router-link"><a href="#6-添加router-link" class="headerlink" title="(6)添加router-link"></a>(6)添加router-link</h4><blockquote></blockquote><pre><code>&lt;div&gt;导航栏 | &lt;router-link to=&quot;/&quot;&gt;lifa&lt;/router-link&gt; &lt;router-link to=&quot;xxx&quot;&gt;lifa2&lt;/router-link&gt;&lt;/div&gt;</code></pre><blockquote></blockquote><h2 id="3-安装sass"><a href="#3-安装sass" class="headerlink" title="3.安装sass"></a>3.安装sass</h2><blockquote></blockquote><pre><code>yarn add sass</code></pre><blockquote></blockquote><p>发现控制台报错 <img src="/2021/051326278/2.jpg"></p><p>解决方法：</p><h3 id="4-1-打开package-json"><a href="#4-1-打开package-json" class="headerlink" title="4.1 打开package.json"></a>4.1 打开package.json</h3><h3 id="4-2-把dependencies里的sass这一行，移到devDependencies"><a href="#4-2-把dependencies里的sass这一行，移到devDependencies" class="headerlink" title="4.2. 把dependencies里的sass这一行，移到devDependencies"></a>4.2. 把dependencies里的sass这一行，移到devDependencies</h3><p><img src="/2021/051326278/3.jpg"></p><h3 id="4-3-重新运行yarn-install"><a href="#4-3-重新运行yarn-install" class="headerlink" title="4.3. 重新运行yarn install"></a>4.3. 重新运行yarn install</h3><h2 id="5-使用provide和inject实现父子组件通信"><a href="#5-使用provide和inject实现父子组件通信" class="headerlink" title="5. 使用provide和inject实现父子组件通信"></a>5. 使用provide和inject实现父子组件通信</h2><h3 id="5-1-在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值"><a href="#5-1-在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值" class="headerlink" title="5.1. 在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值"></a>5.1. 在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值</h3><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code>&lt;script lang=&quot;ts&quot;&gt; import &#123; ref, provide &#125; from &#39;vue&#39; export default &#123;  name: &#39;App&#39;,  setup() &#123;   const menuVisible = ref(false)    provide(&#39;xxx&#39;, menuVisible)  &#125;&#125;</code></pre><blockquote></blockquote><h3 id="5-2-在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值"><a href="#5-2-在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值" class="headerlink" title="5.2. 在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值"></a>5.2. 在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值</h3><ul><li>topnav.vue</li></ul><blockquote></blockquote><pre><code> import &#123; inject, Ref &#125; from &#39;vue&#39; export default &#123;  name: &#39;TopNav&#39;,  setup() &#123;  const menuVisible = inject&lt;Ref&lt;boolean&gt;&gt;(&#39;xxx&#39;)  console.log(menuVisible.value, &#39;topNav menuvisible&#39;)  &#125;&#125;</code></pre><blockquote></blockquote><h2 id="6-路由间切换"><a href="#6-路由间切换" class="headerlink" title="6.路由间切换"></a>6.路由间切换</h2><ul><li>Doc.vue</li></ul><blockquote></blockquote><pre><code>&lt;li&gt;    &lt;router-link to=&quot;/doc/switch&quot;&gt;Switch 组件&lt;/router-link&gt;&lt;/li&gt;&lt;main&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/main&gt;</code></pre><blockquote></blockquote><ul><li>mian.ts</li></ul><blockquote></blockquote><pre><code>const router = createRouter(&#123; history, routes: [    &#123; path: &#39;/&#39;, component: Home &#125;,    &#123; path: &#39;/doc&#39;, component: Doc, children: [      &#123; path: &#39;switch&#39;, component: SwitchDemo &#125;    ]  &#125; ]&#125;)router.afterEach(() =&gt; &#123; console.log(&#39;路由切换了&#39;)&#125;)</code></pre><blockquote></blockquote><p>实现点击菜单跳转关闭左侧菜单栏 我们需要在路由离开的时候将menuVisible的值设为false，但是我们在main.ts里拿不到 menuVisible这个变量，那如果我们把router.afterEach放在App里就可以访问这个变量了，但是 这样的话App里又访问不到我们的router了，所以我们需要单独构建一个router.ts文件</p><ul><li>router.ts</li></ul><blockquote></blockquote><pre><code>import &#123;createWebHashHistory, createRouter&#125; from &#39;vue-router&#39;import Home from &#39;./views/Home.vue&#39;import Doc from &#39;./views/Doc.vue&#39;import SwitchDemo from &#39;./views/SwitchDemo.vue&#39;  const history = createWebHashHistory()  export const router = createRouter(&#123;    history,    routes: [        &#123; path: &#39;/&#39;, component: Home &#125;,        &#123; path: &#39;/doc&#39;, component: Doc, children: [        &#123; path: &#39;switch&#39;, component: SwitchDemo &#125;    ]  &#125; ]&#125;)</code></pre><blockquote></blockquote><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code> import &#123; router &#125; from &quot;./router&quot;; setup() &#123;    const width = document.documentElement.clientWidth    const menuVisible = ref(width &gt; 500 ? true : false)    provide(&#39;xxx&#39;, menuVisible)  +   router.afterEach(() =&gt; &#123;  +      menuVisible.value = false  +    &#125;)   &#125;</code></pre><blockquote></blockquote><ul><li>main.ts</li></ul><blockquote></blockquote><pre><code>import &#123;router&#125; from &#39;./router&#39;const app = createApp(App)app.use(router)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 新特性</title>
      <link href="2021/05124429.html"/>
      <url>2021/05124429.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-新特性"><a href="#Vue3-新特性" class="headerlink" title="Vue3 新特性"></a>Vue3 新特性</h1><p>vue3新增了很多新的特性，目前可以使用 安装 vue-compisition-api 包进行尝鲜，vue3将会对vue2进行向下兼容，因此不必担心因为使用vue3 后 vue2的特性不能够使用</p><h2 id="安装包、使用包"><a href="#安装包、使用包" class="headerlink" title="安装包、使用包"></a>安装包、使用包</h2><ol><li><p>npm install @vue/composition-api –save</p></li><li><p>import VueCompositionApi from ‘@vue/composition-api’</p></li><li><p>Vue.use(VueCompositionApi)</p></li></ol><h2 id="1-setup"><a href="#1-setup" class="headerlink" title="1.setup"></a>1.setup</h2><p>setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口。</p><h3 id="1-1-执行时机"><a href="#1-1-执行时机" class="headerlink" title="1.1 执行时机"></a>1.1 执行时机</h3><p>setup 函数会在 beforeCreate 之后、created 之前执行!!!</p><h3 id="1-2-接收-props-数据"><a href="#1-2-接收-props-数据" class="headerlink" title="1.2 接收 props 数据"></a>1.2 接收 props 数据</h3><p>在 props 中定义当前组件允许外界传递过来的参数名称： props: { p1: String }<br>通过 setup 函数的第一个形参，接收 props 数据： setup(props) { console.log(props.p1) }</p><h3 id="1-3-context"><a href="#1-3-context" class="headerlink" title="1.3 context"></a>1.3 context</h3><p>setup 函数的第二个形参是一个上下文对象，这个上下文对象中包含了一些有用的属性，这些属性在 vue 2.x 中需要通过 this 才能访问到，在 vue 3.x 中，它们的访问方式如下：</p><ol><li>const MyComponent = {</li><li>setup(props, context) {</li><li>   context.attrs</li><li>   context.slots</li><li>   context.parent</li><li>   context.root</li><li>   context.emit</li><li>   context.refs</li><li>  }</li><li>}</li></ol><p>注意：在 setup() 函数中无法访问到 this !!!!!!!!!!!!!</p><h2 id="2-reactive"><a href="#2-reactive" class="headerlink" title="2.reactive"></a>2.reactive</h2><p>reactive() 函数接收一个普通对象，返回一个响应式的数据对象。</p><h3 id="2-1基本语法"><a href="#2-1基本语法" class="headerlink" title="2.1基本语法"></a>2.1基本语法</h3><p>等价于 vue 2.x 中的 Vue.observable() 函数，vue 3.x 中提供了 reactive() 函数，用来创建响应式的数据对象，基本代码示例如下：</p><ol><li>import { reactive } from ‘@vue/composition-api’</li><li>// 创建响应式数据对象，得到的 state 类似于 vue 2.x 中 data() 返回的响应式对象</li><li>const state = reactive({ count: 0 })</li></ol><h3 id="2-2-定义响应式数据供-template-使用"><a href="#2-2-定义响应式数据供-template-使用" class="headerlink" title="2.2 定义响应式数据供 template 使用"></a>2.2 定义响应式数据供 template 使用</h3><p>按需导入 reactive 函数：</p><ol><li>import { reactive } from ‘@vue/composition-api’</li></ol><ul><li>在 setup() 函数中调用 reactive() 函数，创建响应式数据对象：</li></ul><ol><li>setup() {</li><li><pre><code>// 创建响应式数据对象</code></pre></li><li>   const state = reactive({count: 0})</li><li></li><li><pre><code>// setup 函数中将响应式数据对象 return 出去，供 template 使用</code></pre></li><li>   return state</li><li>}</li></ol><ul><li>在 template 中访问响应式数据：</li></ul><ol><li><p>当前的 count 值为：</p></li><li><p>ref</p><h3 id="3-1基本语法"><a href="#3-1基本语法" class="headerlink" title="3.1基本语法"></a>3.1基本语法</h3><p>ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性：</p></li><li><p>import { ref } from ‘@vue/composition-api’</p></li><li></li><li><p>// 创建响应式数据对象 count，初始值为 0</p></li><li><p>const count = ref(0)</p></li><li></li><li><p>// 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以</p></li><li><p>console.log(count.value) // 输出 0</p></li><li><p>// 让 count 的值 +1</p></li><li><p>count.value++</p></li><li><p>// 再次打印 count 的值</p></li><li><p>console.log(count.value) // 输出 1</p></li></ol><h3 id="3-2-在-template-中访问-ref-创建的响应式数据"><a href="#3-2-在-template-中访问-ref-创建的响应式数据" class="headerlink" title="3.2 在 template 中访问 ref 创建的响应式数据"></a>3.2 在 template 中访问 ref 创建的响应式数据</h3><p>在 setup() 中创建响应式数据：</p><ol><li>import { ref } from ‘@vue/composition-api’</li><li></li><li>setup() {</li><li>   const count = ref(0)</li><li></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>    count,</code></pre></li><li><pre><code>    name: ref(&#39;zs&#39;)</code></pre></li><li><pre><code>&#125;</code></pre></li><li>}</li></ol><ul><li>在 template 中访问响应式数据：</li></ul><ol><li><template></template></li><li> <p> --- </p></li><li></li></ol><h2 id="3-3-在-reactive-对象中访问-ref-创建的响应式数据"><a href="#3-3-在-reactive-对象中访问-ref-创建的响应式数据" class="headerlink" title="3.3 在 reactive 对象中访问 ref 创建的响应式数据"></a>3.3 在 reactive 对象中访问 ref 创建的响应式数据</h2><p>当把 ref() 创建出来的响应式数据对象，挂载到 reactive() 上时，会自动把响应式数据对象展开为原始的值，不需通过 .value 就可以直接被访问，例如：</p><ol><li>const count = ref(0)</li><li>const state = reactive({</li><li>  count</li><li>})</li><li></li><li>console.log(state.count) // 输出 0</li><li>state.count++ // 此处不需要通过 .value 就能直接访问原始值</li><li>console.log(count) // 输出 1</li></ol><p>注意：新的 ref 会覆盖旧的 ref，示例代码如下：</p><ol><li>// 创建 ref 并挂载到 reactive 中</li><li>const c1 = ref(0)</li><li>const state = reactive({</li><li>  c1</li><li>})</li><li></li><li>// 再次创建 ref，命名为 c2</li><li>const c2 = ref(9)</li><li>// 将 旧 ref c1 替换为 新 ref c2</li><li>state.c1 = c2</li><li>state.c1++</li><li></li><li>console.log(state.c1) // 输出 10</li><li>console.log(c2.value) // 输出 10</li><li>console.log(c1.value) // 输出 0</li></ol><h2 id="4-isRef"><a href="#4-isRef" class="headerlink" title="4. isRef"></a>4. isRef</h2><p>isRef() 用来判断某个值是否为 ref() 创建出来的对象；应用场景：当需要展开某个可能为 ref() 创建出来的值的时候，例如：</p><ol><li>import { isRef } from ‘@vue/composition-api’</li><li></li><li>const unwrapped = isRef(foo) ? foo.value : foo</li></ol><h2 id="5-toRefs"><a href="#5-toRefs" class="headerlink" title="5.toRefs"></a>5.toRefs</h2><p>toRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据，最常见的应用场景如下：</p><ol><li>import { toRefs } from ‘@vue/composition-api’</li><li></li><li>setup() {</li><li><pre><code>// 定义响应式数据对象</code></pre></li><li><pre><code>const state = reactive(&#123;</code></pre></li><li><pre><code>  count: 0</code></pre></li><li><pre><code>&#125;)</code></pre></li><li></li><li><pre><code>// 定义页面上可用的事件处理函数</code></pre></li><li><pre><code>const increment = () =&gt; &#123;</code></pre></li><li><pre><code>  state.count++</code></pre></li><li><pre><code>&#125;</code></pre></li><li></li><li><pre><code>// 在 setup 中返回一个对象供页面使用</code></pre></li><li><pre><code>// 这个对象中可以包含响应式的数据，也可以包含事件处理函数</code></pre></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>  // 将 state 上的每个属性，都转化为 ref 形式的响应式数据</code></pre></li><li><pre><code>  ...toRefs(state),</code></pre></li><li><pre><code>  // 自增的事件处理函数</code></pre></li><li><pre><code>  increment</code></pre></li><li><pre><code>&#125;</code></pre></li><li>}</li></ol><p>页面上可以直接访问 setup() 中 return 出来的响应式数据：</p><template>  <div>     <p>当前的count值为：</p>    <button @click="increment">+1</button>  </div></template><h2 id="6-computed"><a href="#6-computed" class="headerlink" title="6.computed"></a>6.computed</h2><p>computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入：</p><ol><li>import { computed } from ‘@vue/composition-api’</li></ol><h3 id="6-1-创建只读计算属性"><a href="#6-1-创建只读计算属性" class="headerlink" title="6.1 创建只读计算属性"></a>6.1 创建只读计算属性</h3><p>在调用 computed() 函数期间，传入一个 function 函数，可以得到一个只读的计算属性，示例代码如下：</p><ol><li>// 创建一个 ref 响应式数据</li><li>const count = ref(1)</li><li></li><li>// 根据 count 的值，创建一个响应式的计算属性 plusOne</li><li>// 它会根据依赖的 ref 自动计算并返回一个新的 ref</li><li>const plusOne = computed(() =&gt; count.value + 1)</li><li></li><li>console.log(plusOne.value) // 输出 2</li><li>plusOne.value++ // error</li></ol><h3 id="6-2-创建可读可写的计算属性"><a href="#6-2-创建可读可写的计算属性" class="headerlink" title="6.2.创建可读可写的计算属性"></a>6.2.创建可读可写的计算属性</h3><p>在调用 computed() 函数期间，传入一个包含 get 和 set 函数的对象，可以得到一个可读可写的计算属性，示例代码如下：</p><ol><li>// 创建一个 ref 响应式数据</li><li>const count = ref(1)</li><li></li><li>// 创建一个 computed 计算属性</li><li>const plusOne = computed({</li><li>  // 取值函数</li><li>  get: () =&gt; count.value + 1,</li><li>  // 赋值函数</li><li>  set: val =&gt; {</li><li><pre><code>count.value = val - 1</code></pre></li><li>  }</li><li>})</li><li></li><li>// 为计算属性赋值的操作，会触发 set 函数</li><li>plusOne.value = 9</li><li>// 触发 set 函数后，count 的值会被更新</li><li>console.log(count.value) // 输出 8</li></ol><h2 id="7-watch"><a href="#7-watch" class="headerlink" title="7.watch"></a>7.watch</h2><p>watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入：</p><ol><li>import { watch } from ‘@vue/composition-api’<br>1<h3 id="7-1基本用法"><a href="#7-1基本用法" class="headerlink" title="7.1基本用法"></a>7.1基本用法</h3></li><li>const count = ref(0)</li><li></li><li>// 定义 watch，只要 count 值变化，就会触发 watch 回调</li><li>// watch 会在创建时会自动调用一次</li><li>watch(() =&gt; console.log(count.value))</li><li>// 输出 0</li><li></li><li>setTimeout(() =&gt; {</li><li>  count.value++</li><li>  // 输出 1</li><li>}, 1000)</li></ol><h3 id="7-2-监视指定的数据源"><a href="#7-2-监视指定的数据源" class="headerlink" title="7.2 监视指定的数据源"></a>7.2 监视指定的数据源</h3><p>监视 reactive 类型的数据源：</p><ol><li>// 定义数据源</li><li>const state = reactive({ count: 0 })</li><li>// 监视 state.count 这个数据节点的变化</li><li>watch(</li><li>  () =&gt; state.count,</li><li>  (count, prevCount) =&gt; {</li><li><pre><code>/* ... */</code></pre></li><li>  }</li><li>)</li></ol><p>监视 ref 类型的数据源：</p><ol><li>// 定义数据源</li><li>const count = ref(0)</li><li>// 指定要监视的数据源</li><li>watch(count, (count, prevCount) =&gt; {</li><li>  /* … */</li><li>})</li></ol><h3 id="7-3-监视多个数据源"><a href="#7-3-监视多个数据源" class="headerlink" title="7.3 监视多个数据源"></a>7.3 监视多个数据源</h3><p>监视 reactive 类型的数据源：</p><ol><li>const state = reactive({ count: 0, name: ‘zs’ })</li><li></li><li>watch(</li><li> [() =&gt; state.count, () =&gt; state.name], // Object.values(toRefs(state)),</li><li> ([count, name], [prevCount, prevName]) =&gt; {</li><li> console.log(count) // 新的 count 值</li><li> console.log(name) // 新的 name 值</li><li> console.log(‘————‘)</li><li> console.log(prevCount) // 旧的 count 值</li><li>console.log(prevName) // 新的 name 值</li><li>},</li><li> {</li><li>  lazy: true // 在 watch 被创建的时候，不执行回调函数中的代码</li><li> }</li><li>) </li><li></li><li>setTimeout(() =&gt; {</li><li> state.count++</li><li> state.name = ‘ls’</li><li>}, 1000)</li></ol><p>监视 ref 类型的数据源：</p><ol><li>const count = ref(0)</li><li>const name = ref(‘zs’)</li><li></li><li>watch(</li><li>  [count, name], // 需要被监视的多个 ref 数据源</li><li>  ([count, name], [prevCount, prevName]) =&gt; {</li><li><pre><code>console.log(count)</code></pre></li><li><pre><code>console.log(name)</code></pre></li><li><pre><code>console.log(&#39;-------------&#39;)</code></pre></li><li><pre><code>console.log(prevCount)</code></pre></li><li><pre><code>console.log(prevName)</code></pre></li><li>  },</li><li>  {</li><li><pre><code>lazy: true</code></pre></li><li>  }</li><li>)</li><li></li><li>setTimeout(() =&gt; {</li><li>  count.value++</li><li>  name.value = ‘xiaomaolv’</li><li>}, 1000)</li></ol><h3 id="7-4-清除监视"><a href="#7-4-清除监视" class="headerlink" title="7.4 清除监视"></a>7.4 清除监视</h3><p>在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下：</p><ol><li>// 创建监视，并得到 停止函数</li><li>const stop = watch(() =&gt; {</li><li>  /* … */</li><li>})</li><li></li><li>// 调用停止函数，清除对应的监视</li><li>stop()</li><li><h3 id="7-5-在watch中清除无效的异步任务"><a href="#7-5-在watch中清除无效的异步任务" class="headerlink" title="7.5 在watch中清除无效的异步任务"></a>7.5 在watch中清除无效的异步任务</h3>有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用：</li></ol><ul><li>watch 被重复执行了</li><li>watch 被强制 stop 了<h4 id="Template-中的代码示例如下："><a href="#Template-中的代码示例如下：" class="headerlink" title="Template 中的代码示例如下："></a>Template 中的代码示例如下：</h4></li></ul><ol><li>/* template 中的代码 */ <input type="text" v-model="keywords"></li></ol><h4 id="Script-中的代码示例如下："><a href="#Script-中的代码示例如下：" class="headerlink" title="Script 中的代码示例如下："></a>Script 中的代码示例如下：</h4><ol><li>// 定义响应式数据 keywords</li><li>const keywords = ref(‘’)</li><li></li><li>// 异步任务：打印用户输入的关键词</li><li>const asyncPrint = val =&gt; {</li><li>  // 延时 1 秒后打印</li><li>  return setTimeout(() =&gt; {</li><li><pre><code>console.log(val)</code></pre></li><li>  }, 1000)</li><li>}</li><li></li><li>// 定义 watch 监听</li><li>watch(</li><li>  keywords,</li><li>  (keywords, prevKeywords, onCleanup) =&gt; {</li><li><pre><code>// 执行异步任务，并得到关闭异步任务的 timerId</code></pre></li><li><pre><code>const timerId = asyncPrint(keywords)</code></pre></li><li></li><li><pre><code>// 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务</code></pre></li><li><pre><code>onCleanup(() =&gt; clearTimeout(timerId))</code></pre></li><li>  },</li><li>  // watch 刚被创建的时候不执行</li><li>  { lazy: true }</li><li>)</li><li></li><li>// 把 template 中需要的数据 return 出去</li><li>return {</li><li>  keywords</li><li>}</li></ol><h2 id="8-LifeCycle-Hooks"><a href="#8-LifeCycle-Hooks" class="headerlink" title="8.LifeCycle Hooks"></a>8.LifeCycle Hooks</h2><p>新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下：</p><ol><li>import { onMounted, onUpdated, onUnmounted } from ‘@vue/composition-api’</li><li></li><li>const MyComponent = {</li><li>  setup() {</li><li><pre><code>onMounted(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;mounted!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li><pre><code>onUpdated(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;updated!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li><pre><code>onUnmounted(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;unmounted!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li>  }</li><li>}</li></ol><p>下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系：</p><ul><li>beforeCreate -&gt; use setup()</li><li>created -&gt; use setup()</li><li>beforeMount -&gt; onBeforeMount</li><li>mounted -&gt; onMounted</li><li>beforeUpdate -&gt; onBeforeUpdate</li><li>updated -&gt; onUpdated</li><li>beforeDestroy -&gt; onBeforeUnmount</li><li>destroyed -&gt; onUnmounted</li><li>errorCaptured -&gt; onErrorCaptured<h2 id="9-provide-amp-inject"><a href="#9-provide-amp-inject" class="headerlink" title="9. provide &amp; inject"></a>9. provide &amp; inject</h2>provide() 和 inject() 可以实现嵌套组件之间的数据传递。这两个函数只能在 setup() 函数中使用。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据。</li></ul><h3 id="9-1-共享普通数据"><a href="#9-1-共享普通数据" class="headerlink" title="9.1 共享普通数据"></a>9.1 共享普通数据</h3><p>App.vue 根组件：</p><template>   <div id="app">     <h1>App 根组件</h1>    <hr>    <LevelOne>  </LevelOne></div></template><script>import LevelOne from './components/LevelOne' // 1. 按需导入 provideimport { provide } from '@vue/composition-api'export default {  name: 'app',  setup() {    // 2. App 根组件作为父级组件，通过 provide 函数向子级组件共享数据（不限层级）    //    provide('要共享的数据名称', 被共享的数据)    provide('globalColor', 'red')  },  components: {    LevelOne  }}</script><p>LevelOne.vue 组件：</p><template>  <div>    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->    <h3 :style="{color: themeColor}">Level One</h3>    <hr>    <LevelTwo>  </LevelTwo></div></template><script>import LevelTwo from './LevelTwo'// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default {  setup() {    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据    const themeColor = inject('globalColor')    // 3. 把接收到的共享数据 return 给 Template 使用    return {      themeColor    }  },  components: {    LevelTwo  }}</script><p>LevelTwo.vue 组件：</p><template>  <div>    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->    <h5 :style="{color: themeColor}">Level Two</h5>  </div></template><script>// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default {  setup() {    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据    const themeColor = inject('globalColor')    // 3. 把接收到的共享数据 return 给 Template 使用    return {      themeColor    }  }}</script><h3 id="9-2-共享ref-响应式数据"><a href="#9-2-共享ref-响应式数据" class="headerlink" title="9.2 共享ref 响应式数据"></a>9.2 共享ref 响应式数据</h3><p>如下代码实现了点按钮切换主题颜色的功能，主要修改了 App.vue 组件中的代码，LevelOne.vue 和 LevelTwo.vue 中的代码不受任何改变：</p><template>  <div id="app">    <h1>App 根组件</h1><pre><code>&lt;!-- 点击 App.vue 中的按钮，切换子组件中文字的颜色 --&gt;&lt;button @click=&quot;themeColor=&#39;red&#39;&quot;&gt;红色&lt;/button&gt;&lt;button @click=&quot;themeColor=&#39;blue&#39;&quot;&gt;蓝色&lt;/button&gt;&lt;button @click=&quot;themeColor=&#39;orange&#39;&quot;&gt;橘黄色&lt;/button&gt;&lt;hr /&gt;&lt;LevelOne /&gt;</code></pre>  </div></template><script>import LevelOne from './components/LevelOne'import { provide, ref } from '@vue/composition-api'export default {  name: 'app',  setup() {    // 定义 ref 响应式数据    const themeColor = ref('red')    // 把 ref 数据通过 provide 提供的子组件使用    provide('globalColor', themeColor)    // setup 中 return 数据供当前组件的 Template 使用    return {      themeColor    }  },  components: {    LevelOne  }}</script><h2 id="10-template-refs"><a href="#10-template-refs" class="headerlink" title="10. template refs"></a>10. template refs</h2><p>通过 ref() 还可以引用页面上的元素或组件。</p><h3 id="10-1-元素的引用"><a href="#10-1-元素的引用" class="headerlink" title="10.1 元素的引用"></a>10.1 元素的引用</h3><template>   <div>    <h3 ref="h3Ref">TemplateRefOne</h3>  </div></template><script>import { ref, onMounted } from '@vue/composition-api'export default {  setup() {    // 创建一个 DOM 引用    const h3Ref = ref(null)    // 在 DOM 首次加载完毕之后，才能获取到元素的引用    onMounted(() => {      // 为 dom 元素设置字体颜色      // h3Ref.value 是原生DOM对象      h3Ref.value.style.color = 'red'    })    // 把创建的引用 return 出去    return {      h3Ref    }  }}</script><h3 id="10-2-组件的引用"><a href="#10-2-组件的引用" class="headerlink" title="10.2 组件的引用"></a>10.2 组件的引用</h3><p>TemplateRefOne.vue 中的示例代码如下：</p><template>  <div>    <h3>TemplateRefOne</h3><pre><code>&lt;!-- 4. 点击按钮展示子组件的 count 值 --&gt;&lt;button @click=&quot;showNumber&quot;&gt;获取TemplateRefTwo中的count值&lt;/button&gt;&lt;hr /&gt;&lt;!-- 3. 为组件添加 ref 引用 --&gt;&lt;TemplateRefTwo ref=&quot;comRef&quot; /&gt;</code></pre>  </div></template><script>import { ref } from '@vue/composition-api'import TemplateRefTwo from './TemplateRefTwo'export default {  setup() {    // 1. 创建一个组件的 ref 引用    const comRef = ref(null)    // 5. 展示子组件中 count 的值    const showNumber = () => {      console.log(comRef.value.count)    }    // 2. 把创建的引用 return 出去    return {      comRef,      showNumber    }  },  components: {    TemplateRefTwo  }}</script><p>TemplateRefTwo.vue 中的示例代码：</p><ol><li>import { ref } from ‘@vue/composition-api’</li><li></li><li>export default {</li><li>  setup() {</li><li><pre><code>// 1. 定义响应式的数据</code></pre></li><li><pre><code>const count = ref(0)</code></pre></li><li></li><li><pre><code>// 2. 把响应式数据 return 给 Template 使用</code></pre></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>  count</code></pre></li><li><pre><code>&#125;</code></pre></li><li>  }</li><li>}<br></li></ol><h2 id="11-createComponent"><a href="#11-createComponent" class="headerlink" title="11.createComponent"></a>11.createComponent</h2><p>这个函数不是必须的，除非你想要完美结合 TypeScript 提供的类型推断来进行项目的开发。</p><p>这个函数仅仅提供了类型推断，方便在结合 TypeScript 书写代码时，能为 setup() 中的 props 提供完整的类型推断。</p><ol><li>import { createComponent } from ‘vue’</li><li></li><li>export default createComponent({</li><li>  props: {</li><li><pre><code>foo: String</code></pre></li><li>  },</li><li>  setup(props) {</li><li><pre><code>props.foo // &lt;- type: string</code></pre></li><li>  }</li><li>})</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/051216107.html"/>
      <url>2021/051216107.html</url>
      
        <content type="html"><![CDATA[<h1 id="Welcome-to-我的博客-！"><a href="#Welcome-to-我的博客-！" class="headerlink" title="Welcome to 我的博客 ！"></a>Welcome to 我的博客 ！</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
