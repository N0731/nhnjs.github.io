<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你会用到的15个前端小知识</title>
      <link href="2021/060219214.html"/>
      <url>2021/060219214.html</url>
      
        <content type="html"><![CDATA[<h1 id="你会用到的-15-个前端小知识"><a href="#你会用到的-15-个前端小知识" class="headerlink" title="你会用到的 15 个前端小知识"></a>你会用到的 15 个前端小知识</h1><h3 id="1-css-一行文本超出…"><a href="#1-css-一行文本超出…" class="headerlink" title="1. css 一行文本超出…"></a>1. css 一行文本超出…</h3><pre><code class="css">overflow: hidden;text-overflow:ellipsis;white-space: nowrap;</code></pre><h3 id="2-多行文本超出显示…"><a href="#2-多行文本超出显示…" class="headerlink" title="2.多行文本超出显示…"></a>2.多行文本超出显示…</h3><pre><code class="css">display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;</code></pre><h3 id="3-IOS-手机容器滚动条滑动不流畅"><a href="#3-IOS-手机容器滚动条滑动不流畅" class="headerlink" title="3.IOS 手机容器滚动条滑动不流畅"></a>3.IOS 手机容器滚动条滑动不流畅</h3><pre><code class="css">overflow: auto;-webkit-overflow-scrolling: touch;</code></pre><h3 id="4-修改滚动条样式"><a href="#4-修改滚动条样式" class="headerlink" title="4.修改滚动条样式"></a>4.修改滚动条样式</h3><p>隐藏 div 元素的滚动条</p><pre><code class="css">cdiv::-webkit-scrollbar &#123;``    display: none;&#125;</code></pre><ul><li>div::-webkit-scrollbar 滚动条整体部分</li><li>div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条</li><li>div::-webkit-scrollbar-track 滚动条的轨道（里面装有 Thumb</li><li>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置</li><li>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去</li><li>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</li><li>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。</li></ul><h3 id="5-使用-css-写出一个三角形角标"><a href="#5-使用-css-写出一个三角形角标" class="headerlink" title="5.使用 css 写出一个三角形角标"></a>5.使用 css 写出一个三角形角标</h3><p>元素宽高设置为 0，通过 border 属性来设置，让其它三个方向的 border 颜色为透明或者和背景色保持一致，剩余一条 border 的颜色设置为需要的颜色。</p><pre><code class="css">div &#123;    width: 0;    height: 0;    border: 5px solid #transparent;    border-top-color: red;&#125;</code></pre><h3 id="6-解决-ios-audio-无法自动播放、循环播放的问题"><a href="#6-解决-ios-audio-无法自动播放、循环播放的问题" class="headerlink" title="6.解决 ios audio 无法自动播放、循环播放的问题"></a>6.解决 ios audio 无法自动播放、循环播放的问题</h3><p>ios 手机在使用 audio 或者 video 播放的时候，个别机型无法实现自动播放，可使用下面的代码 hack。</p><pre><code class="js">// 解决ios audio无法自动播放、循环播放的问题var music = document.getElementById(&#39;video&#39;);var state = 0;document.addEventListener(&#39;touchstart&#39;, function()&#123;    if(state==0)&#123;        music.play();        state=1;    &#125;&#125;, false);document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123;    music.play();&#125;, false);//循环播放music.onended = function () &#123;    music.load();    music.play();&#125;</code></pre><h3 id="7-水平垂直居中"><a href="#7-水平垂直居中" class="headerlink" title="7.水平垂直居中"></a>7.水平垂直居中</h3><p>我一般只使用两种方式 定位 或者 flex，我觉得够用了。</p><pre><code class="css">div &#123;    width: 100px;    height: 100px;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    margin: auto;&#125;</code></pre><p>父级控制子集居中</p><pre><code class="css">.parent &#123;    display: flex;    justify-content: center;    align-items: center;&#125;</code></pre><h3 id="8-隐藏页面元素"><a href="#8-隐藏页面元素" class="headerlink" title="8.隐藏页面元素"></a>8.隐藏页面元素</h3><ul><li>display-none: 元素不存在，从 dom 中删除</li><li>opacity-0: 元素透明度将为 0，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</li><li>visibility-hidden：元素隐藏，但元素仍旧存在，页面中无法触发该元素的事件。</li></ul><h3 id="9-前端工程化"><a href="#9-前端工程化" class="headerlink" title="9.前端工程化"></a>9.前端工程化</h3><p>一提到前端工程化很多人想到的都是 webpack，这是不对的，webpack 仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。 前端工程化是通过工具提升效率，降低成本的一种手段。 近些年被广泛的关注和探讨，究其原因主要是因为现代化前端应用功能要求不断提高，业务逻辑日益复杂，作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半壁江山。从传统的网站，到现在的 H5,移动 App,桌面应用，以及小程序。前端技术几乎是无所不能的全面覆盖。 在这些表象的背后呢，实际上是行业对开发人员的要求发生了天翻地覆的变化，以往前端写 demo，套模板，调页面这种刀耕火种的方式已经完全不符合当下对开发效率的要求，前端工程化就是在这样一个背景下被提上台面，成为前端工程师必备的手段之一。 一般来说前端工程包含，项目初始化，项目开发，集成，构建，打包，测试，部署等流程。工程化就是以工程的角度来解决这些问题。比如项目初始化我们一般使用 npm init, 创建页面模板使用 plop，我们喜欢使用 ES6+开发，但是需要通过 babel 编码成 ES5，持续集成的时候我们使用 git，但是为了保持开发规范我们引入了 ESLint，部署一般使用 ci/cd 或者 jenkins 等等。 前端工程化是一个比较大的话题，后面我们会单开话题来讲。</p><h3 id="10-contenteditable"><a href="#10-contenteditable" class="headerlink" title="10.contenteditable"></a>10.contenteditable</h3><p>html 中大部分标签都是不可以编辑的，但是添加了 contenteditable 属性之后，标签会变成可编辑状态。</p><pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><p>不过通过这个属性把标签变为可编辑状态后只有 input 事件，没有 change 事件。也不能像表单一样通过 maxlength 控制最大长度。我也忘记我在什么情况下用到过了，后面想起来再补吧。</p><h3 id="11-calc"><a href="#11-calc" class="headerlink" title="11.calc"></a>11.calc</h3><p>这是一个 css 属性，我一般称之为 css 表达式。可以计算 css 的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出 20px 是啥。</p><pre><code class="css">div &#123;    width: calc(25% - 20px);&#125;</code></pre><h3 id="12-Proxy-和-Object-defineProperty-区别"><a href="#12-Proxy-和-Object-defineProperty-区别" class="headerlink" title="12.Proxy 和 Object.defineProperty 区别"></a>12.Proxy 和 Object.defineProperty 区别</h3><p>Proxy 的意思是代理，我一般教他拦截器，可以拦截对象上的一个操作。用法如下，通过 new 的方式创建对象，第一个参数是被拦截的对象，第二个参数是对象操作的描述。实例化后返回一个新的对象，当我们对这个新的对象进行操作时就会调用我们描述中对应的方法。</p><pre><code class="js">new Proxy(target, &#123;    get(target, property) &#123;    &#125;,    set(target, property) &#123;    &#125;,    deleteProperty(target, property) &#123;    &#125;&#125;)</code></pre><p>Proxy 区别于 Object.definedProperty。 Object.defineProperty 只能监听到属性的读写，而 Proxy 除读写外还可以监听属性的删除，方法的调用等。 通常情况下我们想要监视数组的变化，基本要依靠重写数组方法的方式实现，这也是 Vue 的实现方式，而 Proxy 可以直接监视数组的变化。</p><pre><code class="js">const list = [1, 2, 3];const listproxy = new Proxy(list, &#123;    set(target, property, value) &#123;        target[property] = value;        return true; // 标识设置成功    &#125;&#125;);list.push(4);</code></pre><p>Proxy 是以非入侵的方式监管了对象的读写，而 defineProperty 需要按特定的方式定义对象的属性。</p><h3 id="13-Reflect"><a href="#13-Reflect" class="headerlink" title="13.Reflect"></a>13.Reflect</h3><p>他是 ES2015 新增的对象，纯静态对象也就是不能被实例画，只能通过静态方法的方式调用，和 Math 对象类似，只能类似 Math.random 的方式调用。 Reflect 内部封装了一系列对对象的底层操作，一共 14 个，其中 1 个被废弃，还剩下 13 个。 Reflect 的静态方法和 Proxy 描述中的方法完全一致。也就是说 Reflect 成员方法就是 Proxy 处理对象的默认实现。 Proxy 对象默认的方法就是调用了 Reflect 内部的处理逻辑，也就是如果我们调用 get 方法，那么在内部，proxy 就是将 get 原封不动的交给了 Reflect，如下。</p><pre><code class="js">const proxy = new Proxy(obj, &#123;    get(target, property) &#123;        return Reflect.get(target, property);    &#125;&#125;)</code></pre><p>Reflect 和 Proxy 没有绝对的关系，我们一般将他们两个放在一起讲是为了方便对二者的理解。 那为什么会有 Reflect 对象呢，其实他最大的用处就是提供了一套统一操作 Object 的 API。判断对象是否存在某一个属性，可以使用 in 操作符，但是不够优雅，还可以使用 Reflect.has(obj, name); 删除一个属性可以使用 delete，也可以使用 Reflect.deleteProperty(obj, name); 获取所有属性名可以使用 Object.keys, 也可以使用 Reflect.ownKeys(obj); 我们更推荐使用 Reflect 的 API 来操作对象，因为他才是未来。</p><h3 id="14-解析-get-参数"><a href="#14-解析-get-参数" class="headerlink" title="14.解析 get 参数"></a>14.解析 get 参数</h3><p>通过 replace 方法获取 url 中的参数键值对，可以快速解析 get 参数。</p><pre><code class="js">const q = &#123;&#125;;location.search.replace(/([^?&amp;=]+)=([^&amp;]+)/g,(_,k,v)=&gt;q[k]=v);console.log(q);</code></pre><h3 id="15-解析连接-url"><a href="#15-解析连接-url" class="headerlink" title="15.解析连接 url"></a>15.解析连接 url</h3><p>可以通过创建 a 标签，给 a 标签赋值 href 属性的方式，获取到协议，pathname，origin 等 location 对象上的属性。</p><pre><code class="js">// 创建a标签const aEle = document.createElement(&#39;a&#39;);// 给a标签赋值href路径aEle.href = &#39;/test.html&#39;;// 访问aEle中的属性aEle.protocol; // 获取协议aEle.pathname; // 获取pathaEle.origin;aEle.host;aEle.search;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3+vite创建项目</title>
      <link href="2021/051326278.html"/>
      <url>2021/051326278.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue3-vite创建项目"><a href="#vue3-vite创建项目" class="headerlink" title="vue3+vite创建项目"></a>vue3+vite创建项目</h1><h2 id="1-全局安装create-vite-app"><a href="#1-全局安装create-vite-app" class="headerlink" title="1. 全局安装create-vite-app"></a>1. 全局安装create-vite-app</h2><ol><li>yarn global add <a href="mailto:&#99;&#x72;&#101;&#x61;&#116;&#101;&#x2d;&#x76;&#x69;&#116;&#x65;&#45;&#x61;&#x70;&#x70;&#64;&#49;&#46;&#49;&#56;&#x2e;&#48;">&#99;&#x72;&#101;&#x61;&#116;&#101;&#x2d;&#x76;&#x69;&#116;&#x65;&#45;&#x61;&#x70;&#x70;&#64;&#49;&#46;&#49;&#56;&#x2e;&#48;</a></li></ol><h2 id="2-创建项目目录"><a href="#2-创建项目目录" class="headerlink" title="2.创建项目目录"></a>2.创建项目目录</h2><pre><code> cva vue3-ui 或者 create-vite-app vue3-ui    </code></pre><h2 id="Vue-2-和-Vue-3-的区别"><a href="#Vue-2-和-Vue-3-的区别" class="headerlink" title="Vue 2 和 Vue 3 的区别"></a>Vue 2 和 Vue 3 的区别</h2><p>90% 的写法完全一致，除了以下几点</p><ul><li>Vue 3 的 Template 支持多个根标签，Vue 2 不支持</li><li>Vue 3 有 createApp()，而 Vue 2 的是 new Vue()</li><li>createApp(组件)，new Vue({template, render})</li></ul><h2 id="3-引入Vue-Router4"><a href="#3-引入Vue-Router4" class="headerlink" title="3.引入Vue Router4"></a>3.引入Vue Router4</h2><p><img src="/2021/051326278/1.jpg"></p><h3 id="3-1-使用命令行查看vue-router-所有版本号"><a href="#3-1-使用命令行查看vue-router-所有版本号" class="headerlink" title="3.1. 使用命令行查看vue-router 所有版本号"></a>3.1. 使用命令行查看vue-router 所有版本号</h3><ol><li>npm info vue-router versions</li></ol><h3 id="安装最新的-x76-117-x65-45-114-111-117-x74-x65-x72-x40-52-46-48-46-x30-x2d-x62-101-116-97-46-x36"><a href="#安装最新的-x76-117-x65-45-114-111-117-x74-x65-x72-x40-52-46-48-46-x30-x2d-x62-101-116-97-46-x36" class="headerlink" title="安装最新的&#x76;&#117;&#x65;&#45;&#114;&#111;&#117;&#x74;&#x65;&#x72;&#x40;&#52;&#46;&#48;&#46;&#x30;&#x2d;&#x62;&#101;&#116;&#97;&#46;&#x36;"></a>安装最新的<a href="mailto:&#x76;&#117;&#x65;&#45;&#114;&#111;&#117;&#x74;&#x65;&#x72;&#x40;&#52;&#46;&#48;&#46;&#x30;&#x2d;&#x62;&#101;&#116;&#97;&#46;&#x36;">&#x76;&#117;&#x65;&#45;&#114;&#111;&#117;&#x74;&#x65;&#x72;&#x40;&#52;&#46;&#48;&#46;&#x30;&#x2d;&#x62;&#101;&#116;&#97;&#46;&#x36;</a></h3><ol><li>yarn add <a href="mailto:&#x76;&#117;&#x65;&#45;&#114;&#111;&#x75;&#x74;&#101;&#114;&#64;&#52;&#46;&#x30;&#46;&#x30;&#x2d;&#x62;&#x65;&#116;&#97;&#46;&#x36;">&#x76;&#117;&#x65;&#45;&#114;&#111;&#x75;&#x74;&#101;&#114;&#64;&#52;&#46;&#x30;&#46;&#x30;&#x2d;&#x62;&#x65;&#116;&#97;&#46;&#x36;</a></li></ol><h3 id="3-2-初始化vue-router"><a href="#3-2-初始化vue-router" class="headerlink" title="3.2. 初始化vue-router"></a>3.2. 初始化vue-router</h3><h4 id="1-新建-history-对象"><a href="#1-新建-history-对象" class="headerlink" title="(1).新建 history 对象"></a>(1).新建 history 对象</h4><ol><li>import {createWebHashHistory, createRouter} from ‘vue-router’</li><li>const history = createWebHashHistory()</li></ol><h4 id="2-新建-router-对象"><a href="#2-新建-router-对象" class="headerlink" title="(2). 新建 router 对象"></a>(2). 新建 router 对象</h4><ol><li>const router = createRouter()</li></ol><h4 id="3-引入typescript"><a href="#3-引入typescript" class="headerlink" title="(3)引入typescript"></a>(3)引入typescript</h4><p>把main.js文件改为main.ts，我们会发现有很多报错 报错1：createRouter里面需要传入一个参数，但我们却传入了0个 解决：</p><blockquote></blockquote><pre><code>const router = createRouter(&#123;     history,     routes: [     &#123; path: &#39;/&#39;, component: Lifa &#125;    ]&#125;)</code></pre><blockquote></blockquote><p>报错2：.vue类型的文件提示cannot find module xxx.vue 原因ts只能理解.ts为后缀的文件，无法理解.vue文件 解决方法:</p><ul><li>Google 搜索 Vue 3 can not find module</li><li>创建 xxx.d.ts，告诉 TS 如何理解 .vue 文件</li><li>src/shims-vue.d.ts</li></ul><blockquote></blockquote><pre><code>declare module &#39;*.vue&#39; &#123; import &#123; Component &#125; from &#39;vue&#39; const component: Component export default component&#125;   </code></pre><blockquote></blockquote><p>这里要注意如果我们用的是vscode这时报错已经没了，但是如果我们用的是webstrom编辑器它还是会 报同样的错误，我们需要再额外的安装ts，然后初始化ts配置</p><blockquote></blockquote><pre><code>yarn add typescript -Dtsc --init</code></pre><blockquote></blockquote><p>这样报错就会解决了</p><h4 id="4-使用router"><a href="#4-使用router" class="headerlink" title="(4)使用router"></a>(4)使用router</h4><blockquote></blockquote><pre><code>const app = createApp(App)app.use(router)app.mount(&#39;#app&#39;)</code></pre><blockquote></blockquote><h4 id="5-添加-router-view"><a href="#5-添加-router-view" class="headerlink" title="(5)添加 router-view"></a>(5)添加 router-view</h4><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code>&lt;template&gt;  &lt;div&gt;hi&lt;/div&gt;  &lt;router-view/&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name: &#39;App&#39;&#125;&lt;/script&gt;</code></pre><blockquote></blockquote><h4 id="6-添加router-link"><a href="#6-添加router-link" class="headerlink" title="(6)添加router-link"></a>(6)添加router-link</h4><blockquote></blockquote><pre><code>&lt;div&gt;导航栏 | &lt;router-link to=&quot;/&quot;&gt;lifa&lt;/router-link&gt; &lt;router-link to=&quot;xxx&quot;&gt;lifa2&lt;/router-link&gt;&lt;/div&gt;</code></pre><blockquote></blockquote><h2 id="3-安装sass"><a href="#3-安装sass" class="headerlink" title="3.安装sass"></a>3.安装sass</h2><blockquote></blockquote><pre><code>yarn add sass</code></pre><blockquote></blockquote><p>发现控制台报错 <img src="/2021/051326278/2.jpg"></p><p>解决方法：</p><h3 id="4-1-打开package-json"><a href="#4-1-打开package-json" class="headerlink" title="4.1 打开package.json"></a>4.1 打开package.json</h3><h3 id="4-2-把dependencies里的sass这一行，移到devDependencies"><a href="#4-2-把dependencies里的sass这一行，移到devDependencies" class="headerlink" title="4.2. 把dependencies里的sass这一行，移到devDependencies"></a>4.2. 把dependencies里的sass这一行，移到devDependencies</h3><p><img src="/2021/051326278/3.jpg"></p><h3 id="4-3-重新运行yarn-install"><a href="#4-3-重新运行yarn-install" class="headerlink" title="4.3. 重新运行yarn install"></a>4.3. 重新运行yarn install</h3><h2 id="5-使用provide和inject实现父子组件通信"><a href="#5-使用provide和inject实现父子组件通信" class="headerlink" title="5. 使用provide和inject实现父子组件通信"></a>5. 使用provide和inject实现父子组件通信</h2><h3 id="5-1-在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值"><a href="#5-1-在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值" class="headerlink" title="5.1. 在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值"></a>5.1. 在父组件里使用provide提供一个变量值，provide第一个参数是变量名，第二个是对应的值</h3><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code>&lt;script lang=&quot;ts&quot;&gt; import &#123; ref, provide &#125; from &#39;vue&#39; export default &#123;  name: &#39;App&#39;,  setup() &#123;   const menuVisible = ref(false)    provide(&#39;xxx&#39;, menuVisible)  &#125;&#125;</code></pre><blockquote></blockquote><h3 id="5-2-在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值"><a href="#5-2-在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值" class="headerlink" title="5.2. 在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值"></a>5.2. 在子组件里通过inject使用这个变量，括号里的就是你设置的provide的key值</h3><ul><li>topnav.vue</li></ul><blockquote></blockquote><pre><code> import &#123; inject, Ref &#125; from &#39;vue&#39; export default &#123;  name: &#39;TopNav&#39;,  setup() &#123;  const menuVisible = inject&lt;Ref&lt;boolean&gt;&gt;(&#39;xxx&#39;)  console.log(menuVisible.value, &#39;topNav menuvisible&#39;)  &#125;&#125;</code></pre><blockquote></blockquote><h2 id="6-路由间切换"><a href="#6-路由间切换" class="headerlink" title="6.路由间切换"></a>6.路由间切换</h2><ul><li>Doc.vue</li></ul><blockquote></blockquote><pre><code>&lt;li&gt;    &lt;router-link to=&quot;/doc/switch&quot;&gt;Switch 组件&lt;/router-link&gt;&lt;/li&gt;&lt;main&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/main&gt;</code></pre><blockquote></blockquote><ul><li>mian.ts</li></ul><blockquote></blockquote><pre><code>const router = createRouter(&#123; history, routes: [    &#123; path: &#39;/&#39;, component: Home &#125;,    &#123; path: &#39;/doc&#39;, component: Doc, children: [      &#123; path: &#39;switch&#39;, component: SwitchDemo &#125;    ]  &#125; ]&#125;)router.afterEach(() =&gt; &#123; console.log(&#39;路由切换了&#39;)&#125;)</code></pre><blockquote></blockquote><p>实现点击菜单跳转关闭左侧菜单栏 我们需要在路由离开的时候将menuVisible的值设为false，但是我们在main.ts里拿不到 menuVisible这个变量，那如果我们把router.afterEach放在App里就可以访问这个变量了，但是 这样的话App里又访问不到我们的router了，所以我们需要单独构建一个router.ts文件</p><ul><li>router.ts</li></ul><blockquote></blockquote><pre><code>import &#123;createWebHashHistory, createRouter&#125; from &#39;vue-router&#39;import Home from &#39;./views/Home.vue&#39;import Doc from &#39;./views/Doc.vue&#39;import SwitchDemo from &#39;./views/SwitchDemo.vue&#39;  const history = createWebHashHistory()  export const router = createRouter(&#123;    history,    routes: [        &#123; path: &#39;/&#39;, component: Home &#125;,        &#123; path: &#39;/doc&#39;, component: Doc, children: [        &#123; path: &#39;switch&#39;, component: SwitchDemo &#125;    ]  &#125; ]&#125;)</code></pre><blockquote></blockquote><ul><li>App.vue</li></ul><blockquote></blockquote><pre><code> import &#123; router &#125; from &quot;./router&quot;; setup() &#123;    const width = document.documentElement.clientWidth    const menuVisible = ref(width &gt; 500 ? true : false)    provide(&#39;xxx&#39;, menuVisible)  +   router.afterEach(() =&gt; &#123;  +      menuVisible.value = false  +    &#125;)   &#125;</code></pre><blockquote></blockquote><ul><li>main.ts</li></ul><blockquote></blockquote><pre><code>import &#123;router&#125; from &#39;./router&#39;const app = createApp(App)app.use(router)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 新特性</title>
      <link href="2021/05124429.html"/>
      <url>2021/05124429.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-新特性"><a href="#Vue3-新特性" class="headerlink" title="Vue3 新特性"></a>Vue3 新特性</h1><p>vue3新增了很多新的特性，目前可以使用 安装 vue-compisition-api 包进行尝鲜，vue3将会对vue2进行向下兼容，因此不必担心因为使用vue3 后 vue2的特性不能够使用</p><h2 id="安装包、使用包"><a href="#安装包、使用包" class="headerlink" title="安装包、使用包"></a>安装包、使用包</h2><ol><li><p>npm install @vue/composition-api –save</p></li><li><p>import VueCompositionApi from ‘@vue/composition-api’</p></li><li><p>Vue.use(VueCompositionApi)</p></li></ol><h2 id="1-setup"><a href="#1-setup" class="headerlink" title="1.setup"></a>1.setup</h2><p>setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口。</p><h3 id="1-1-执行时机"><a href="#1-1-执行时机" class="headerlink" title="1.1 执行时机"></a>1.1 执行时机</h3><p>setup 函数会在 beforeCreate 之后、created 之前执行!!!</p><h3 id="1-2-接收-props-数据"><a href="#1-2-接收-props-数据" class="headerlink" title="1.2 接收 props 数据"></a>1.2 接收 props 数据</h3><p>在 props 中定义当前组件允许外界传递过来的参数名称： props: { p1: String }<br>通过 setup 函数的第一个形参，接收 props 数据： setup(props) { console.log(props.p1) }</p><h3 id="1-3-context"><a href="#1-3-context" class="headerlink" title="1.3 context"></a>1.3 context</h3><p>setup 函数的第二个形参是一个上下文对象，这个上下文对象中包含了一些有用的属性，这些属性在 vue 2.x 中需要通过 this 才能访问到，在 vue 3.x 中，它们的访问方式如下：</p><ol><li>const MyComponent = {</li><li>setup(props, context) {</li><li>   context.attrs</li><li>   context.slots</li><li>   context.parent</li><li>   context.root</li><li>   context.emit</li><li>   context.refs</li><li>  }</li><li>}</li></ol><p>注意：在 setup() 函数中无法访问到 this !!!!!!!!!!!!!</p><h2 id="2-reactive"><a href="#2-reactive" class="headerlink" title="2.reactive"></a>2.reactive</h2><p>reactive() 函数接收一个普通对象，返回一个响应式的数据对象。</p><h3 id="2-1基本语法"><a href="#2-1基本语法" class="headerlink" title="2.1基本语法"></a>2.1基本语法</h3><p>等价于 vue 2.x 中的 Vue.observable() 函数，vue 3.x 中提供了 reactive() 函数，用来创建响应式的数据对象，基本代码示例如下：</p><ol><li>import { reactive } from ‘@vue/composition-api’</li><li>// 创建响应式数据对象，得到的 state 类似于 vue 2.x 中 data() 返回的响应式对象</li><li>const state = reactive({ count: 0 })</li></ol><h3 id="2-2-定义响应式数据供-template-使用"><a href="#2-2-定义响应式数据供-template-使用" class="headerlink" title="2.2 定义响应式数据供 template 使用"></a>2.2 定义响应式数据供 template 使用</h3><p>按需导入 reactive 函数：</p><ol><li>import { reactive } from ‘@vue/composition-api’</li></ol><ul><li>在 setup() 函数中调用 reactive() 函数，创建响应式数据对象：</li></ul><ol><li>setup() {</li><li><pre><code>// 创建响应式数据对象</code></pre></li><li>   const state = reactive({count: 0})</li><li></li><li><pre><code>// setup 函数中将响应式数据对象 return 出去，供 template 使用</code></pre></li><li>   return state</li><li>}</li></ol><ul><li>在 template 中访问响应式数据：</li></ul><ol><li><p>当前的 count 值为：</p></li><li><p>ref</p><h3 id="3-1基本语法"><a href="#3-1基本语法" class="headerlink" title="3.1基本语法"></a>3.1基本语法</h3><p>ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性：</p></li><li><p>import { ref } from ‘@vue/composition-api’</p></li><li></li><li><p>// 创建响应式数据对象 count，初始值为 0</p></li><li><p>const count = ref(0)</p></li><li></li><li><p>// 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以</p></li><li><p>console.log(count.value) // 输出 0</p></li><li><p>// 让 count 的值 +1</p></li><li><p>count.value++</p></li><li><p>// 再次打印 count 的值</p></li><li><p>console.log(count.value) // 输出 1</p></li></ol><h3 id="3-2-在-template-中访问-ref-创建的响应式数据"><a href="#3-2-在-template-中访问-ref-创建的响应式数据" class="headerlink" title="3.2 在 template 中访问 ref 创建的响应式数据"></a>3.2 在 template 中访问 ref 创建的响应式数据</h3><p>在 setup() 中创建响应式数据：</p><ol><li>import { ref } from ‘@vue/composition-api’</li><li></li><li>setup() {</li><li>   const count = ref(0)</li><li></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>    count,</code></pre></li><li><pre><code>    name: ref(&#39;zs&#39;)</code></pre></li><li><pre><code>&#125;</code></pre></li><li>}</li></ol><ul><li>在 template 中访问响应式数据：</li></ul><ol><li><template></template></li><li> <p> --- </p></li><li></li></ol><h2 id="3-3-在-reactive-对象中访问-ref-创建的响应式数据"><a href="#3-3-在-reactive-对象中访问-ref-创建的响应式数据" class="headerlink" title="3.3 在 reactive 对象中访问 ref 创建的响应式数据"></a>3.3 在 reactive 对象中访问 ref 创建的响应式数据</h2><p>当把 ref() 创建出来的响应式数据对象，挂载到 reactive() 上时，会自动把响应式数据对象展开为原始的值，不需通过 .value 就可以直接被访问，例如：</p><ol><li>const count = ref(0)</li><li>const state = reactive({</li><li>  count</li><li>})</li><li></li><li>console.log(state.count) // 输出 0</li><li>state.count++ // 此处不需要通过 .value 就能直接访问原始值</li><li>console.log(count) // 输出 1</li></ol><p>注意：新的 ref 会覆盖旧的 ref，示例代码如下：</p><ol><li>// 创建 ref 并挂载到 reactive 中</li><li>const c1 = ref(0)</li><li>const state = reactive({</li><li>  c1</li><li>})</li><li></li><li>// 再次创建 ref，命名为 c2</li><li>const c2 = ref(9)</li><li>// 将 旧 ref c1 替换为 新 ref c2</li><li>state.c1 = c2</li><li>state.c1++</li><li></li><li>console.log(state.c1) // 输出 10</li><li>console.log(c2.value) // 输出 10</li><li>console.log(c1.value) // 输出 0</li></ol><h2 id="4-isRef"><a href="#4-isRef" class="headerlink" title="4. isRef"></a>4. isRef</h2><p>isRef() 用来判断某个值是否为 ref() 创建出来的对象；应用场景：当需要展开某个可能为 ref() 创建出来的值的时候，例如：</p><ol><li>import { isRef } from ‘@vue/composition-api’</li><li></li><li>const unwrapped = isRef(foo) ? foo.value : foo</li></ol><h2 id="5-toRefs"><a href="#5-toRefs" class="headerlink" title="5.toRefs"></a>5.toRefs</h2><p>toRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据，最常见的应用场景如下：</p><ol><li>import { toRefs } from ‘@vue/composition-api’</li><li></li><li>setup() {</li><li><pre><code>// 定义响应式数据对象</code></pre></li><li><pre><code>const state = reactive(&#123;</code></pre></li><li><pre><code>  count: 0</code></pre></li><li><pre><code>&#125;)</code></pre></li><li></li><li><pre><code>// 定义页面上可用的事件处理函数</code></pre></li><li><pre><code>const increment = () =&gt; &#123;</code></pre></li><li><pre><code>  state.count++</code></pre></li><li><pre><code>&#125;</code></pre></li><li></li><li><pre><code>// 在 setup 中返回一个对象供页面使用</code></pre></li><li><pre><code>// 这个对象中可以包含响应式的数据，也可以包含事件处理函数</code></pre></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>  // 将 state 上的每个属性，都转化为 ref 形式的响应式数据</code></pre></li><li><pre><code>  ...toRefs(state),</code></pre></li><li><pre><code>  // 自增的事件处理函数</code></pre></li><li><pre><code>  increment</code></pre></li><li><pre><code>&#125;</code></pre></li><li>}</li></ol><p>页面上可以直接访问 setup() 中 return 出来的响应式数据：</p><template>  <div>     <p>当前的count值为：</p>    <button @click="increment">+1</button>  </div></template><h2 id="6-computed"><a href="#6-computed" class="headerlink" title="6.computed"></a>6.computed</h2><p>computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入：</p><ol><li>import { computed } from ‘@vue/composition-api’</li></ol><h3 id="6-1-创建只读计算属性"><a href="#6-1-创建只读计算属性" class="headerlink" title="6.1 创建只读计算属性"></a>6.1 创建只读计算属性</h3><p>在调用 computed() 函数期间，传入一个 function 函数，可以得到一个只读的计算属性，示例代码如下：</p><ol><li>// 创建一个 ref 响应式数据</li><li>const count = ref(1)</li><li></li><li>// 根据 count 的值，创建一个响应式的计算属性 plusOne</li><li>// 它会根据依赖的 ref 自动计算并返回一个新的 ref</li><li>const plusOne = computed(() =&gt; count.value + 1)</li><li></li><li>console.log(plusOne.value) // 输出 2</li><li>plusOne.value++ // error</li></ol><h3 id="6-2-创建可读可写的计算属性"><a href="#6-2-创建可读可写的计算属性" class="headerlink" title="6.2.创建可读可写的计算属性"></a>6.2.创建可读可写的计算属性</h3><p>在调用 computed() 函数期间，传入一个包含 get 和 set 函数的对象，可以得到一个可读可写的计算属性，示例代码如下：</p><ol><li>// 创建一个 ref 响应式数据</li><li>const count = ref(1)</li><li></li><li>// 创建一个 computed 计算属性</li><li>const plusOne = computed({</li><li>  // 取值函数</li><li>  get: () =&gt; count.value + 1,</li><li>  // 赋值函数</li><li>  set: val =&gt; {</li><li><pre><code>count.value = val - 1</code></pre></li><li>  }</li><li>})</li><li></li><li>// 为计算属性赋值的操作，会触发 set 函数</li><li>plusOne.value = 9</li><li>// 触发 set 函数后，count 的值会被更新</li><li>console.log(count.value) // 输出 8</li></ol><h2 id="7-watch"><a href="#7-watch" class="headerlink" title="7.watch"></a>7.watch</h2><p>watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入：</p><ol><li>import { watch } from ‘@vue/composition-api’<br>1<h3 id="7-1基本用法"><a href="#7-1基本用法" class="headerlink" title="7.1基本用法"></a>7.1基本用法</h3></li><li>const count = ref(0)</li><li></li><li>// 定义 watch，只要 count 值变化，就会触发 watch 回调</li><li>// watch 会在创建时会自动调用一次</li><li>watch(() =&gt; console.log(count.value))</li><li>// 输出 0</li><li></li><li>setTimeout(() =&gt; {</li><li>  count.value++</li><li>  // 输出 1</li><li>}, 1000)</li></ol><h3 id="7-2-监视指定的数据源"><a href="#7-2-监视指定的数据源" class="headerlink" title="7.2 监视指定的数据源"></a>7.2 监视指定的数据源</h3><p>监视 reactive 类型的数据源：</p><ol><li>// 定义数据源</li><li>const state = reactive({ count: 0 })</li><li>// 监视 state.count 这个数据节点的变化</li><li>watch(</li><li>  () =&gt; state.count,</li><li>  (count, prevCount) =&gt; {</li><li><pre><code>/* ... */</code></pre></li><li>  }</li><li>)</li></ol><p>监视 ref 类型的数据源：</p><ol><li>// 定义数据源</li><li>const count = ref(0)</li><li>// 指定要监视的数据源</li><li>watch(count, (count, prevCount) =&gt; {</li><li>  /* … */</li><li>})</li></ol><h3 id="7-3-监视多个数据源"><a href="#7-3-监视多个数据源" class="headerlink" title="7.3 监视多个数据源"></a>7.3 监视多个数据源</h3><p>监视 reactive 类型的数据源：</p><ol><li>const state = reactive({ count: 0, name: ‘zs’ })</li><li></li><li>watch(</li><li> [() =&gt; state.count, () =&gt; state.name], // Object.values(toRefs(state)),</li><li> ([count, name], [prevCount, prevName]) =&gt; {</li><li> console.log(count) // 新的 count 值</li><li> console.log(name) // 新的 name 值</li><li> console.log(‘————‘)</li><li> console.log(prevCount) // 旧的 count 值</li><li>console.log(prevName) // 新的 name 值</li><li>},</li><li> {</li><li>  lazy: true // 在 watch 被创建的时候，不执行回调函数中的代码</li><li> }</li><li>) </li><li></li><li>setTimeout(() =&gt; {</li><li> state.count++</li><li> state.name = ‘ls’</li><li>}, 1000)</li></ol><p>监视 ref 类型的数据源：</p><ol><li>const count = ref(0)</li><li>const name = ref(‘zs’)</li><li></li><li>watch(</li><li>  [count, name], // 需要被监视的多个 ref 数据源</li><li>  ([count, name], [prevCount, prevName]) =&gt; {</li><li><pre><code>console.log(count)</code></pre></li><li><pre><code>console.log(name)</code></pre></li><li><pre><code>console.log(&#39;-------------&#39;)</code></pre></li><li><pre><code>console.log(prevCount)</code></pre></li><li><pre><code>console.log(prevName)</code></pre></li><li>  },</li><li>  {</li><li><pre><code>lazy: true</code></pre></li><li>  }</li><li>)</li><li></li><li>setTimeout(() =&gt; {</li><li>  count.value++</li><li>  name.value = ‘xiaomaolv’</li><li>}, 1000)</li></ol><h3 id="7-4-清除监视"><a href="#7-4-清除监视" class="headerlink" title="7.4 清除监视"></a>7.4 清除监视</h3><p>在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下：</p><ol><li>// 创建监视，并得到 停止函数</li><li>const stop = watch(() =&gt; {</li><li>  /* … */</li><li>})</li><li></li><li>// 调用停止函数，清除对应的监视</li><li>stop()</li><li><h3 id="7-5-在watch中清除无效的异步任务"><a href="#7-5-在watch中清除无效的异步任务" class="headerlink" title="7.5 在watch中清除无效的异步任务"></a>7.5 在watch中清除无效的异步任务</h3>有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用：</li></ol><ul><li>watch 被重复执行了</li><li>watch 被强制 stop 了<h4 id="Template-中的代码示例如下："><a href="#Template-中的代码示例如下：" class="headerlink" title="Template 中的代码示例如下："></a>Template 中的代码示例如下：</h4></li></ul><ol><li>/* template 中的代码 */ <input type="text" v-model="keywords"></li></ol><h4 id="Script-中的代码示例如下："><a href="#Script-中的代码示例如下：" class="headerlink" title="Script 中的代码示例如下："></a>Script 中的代码示例如下：</h4><ol><li>// 定义响应式数据 keywords</li><li>const keywords = ref(‘’)</li><li></li><li>// 异步任务：打印用户输入的关键词</li><li>const asyncPrint = val =&gt; {</li><li>  // 延时 1 秒后打印</li><li>  return setTimeout(() =&gt; {</li><li><pre><code>console.log(val)</code></pre></li><li>  }, 1000)</li><li>}</li><li></li><li>// 定义 watch 监听</li><li>watch(</li><li>  keywords,</li><li>  (keywords, prevKeywords, onCleanup) =&gt; {</li><li><pre><code>// 执行异步任务，并得到关闭异步任务的 timerId</code></pre></li><li><pre><code>const timerId = asyncPrint(keywords)</code></pre></li><li></li><li><pre><code>// 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务</code></pre></li><li><pre><code>onCleanup(() =&gt; clearTimeout(timerId))</code></pre></li><li>  },</li><li>  // watch 刚被创建的时候不执行</li><li>  { lazy: true }</li><li>)</li><li></li><li>// 把 template 中需要的数据 return 出去</li><li>return {</li><li>  keywords</li><li>}</li></ol><h2 id="8-LifeCycle-Hooks"><a href="#8-LifeCycle-Hooks" class="headerlink" title="8.LifeCycle Hooks"></a>8.LifeCycle Hooks</h2><p>新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下：</p><ol><li>import { onMounted, onUpdated, onUnmounted } from ‘@vue/composition-api’</li><li></li><li>const MyComponent = {</li><li>  setup() {</li><li><pre><code>onMounted(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;mounted!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li><pre><code>onUpdated(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;updated!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li><pre><code>onUnmounted(() =&gt; &#123;</code></pre></li><li><pre><code>  console.log(&#39;unmounted!&#39;)</code></pre></li><li><pre><code>&#125;)</code></pre></li><li>  }</li><li>}</li></ol><p>下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系：</p><ul><li>beforeCreate -&gt; use setup()</li><li>created -&gt; use setup()</li><li>beforeMount -&gt; onBeforeMount</li><li>mounted -&gt; onMounted</li><li>beforeUpdate -&gt; onBeforeUpdate</li><li>updated -&gt; onUpdated</li><li>beforeDestroy -&gt; onBeforeUnmount</li><li>destroyed -&gt; onUnmounted</li><li>errorCaptured -&gt; onErrorCaptured<h2 id="9-provide-amp-inject"><a href="#9-provide-amp-inject" class="headerlink" title="9. provide &amp; inject"></a>9. provide &amp; inject</h2>provide() 和 inject() 可以实现嵌套组件之间的数据传递。这两个函数只能在 setup() 函数中使用。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据。</li></ul><h3 id="9-1-共享普通数据"><a href="#9-1-共享普通数据" class="headerlink" title="9.1 共享普通数据"></a>9.1 共享普通数据</h3><p>App.vue 根组件：</p><template>   <div id="app">     <h1>App 根组件</h1>    <hr>    <LevelOne>  </LevelOne></div></template><script>import LevelOne from './components/LevelOne' // 1. 按需导入 provideimport { provide } from '@vue/composition-api'export default {  name: 'app',  setup() {    // 2. App 根组件作为父级组件，通过 provide 函数向子级组件共享数据（不限层级）    //    provide('要共享的数据名称', 被共享的数据)    provide('globalColor', 'red')  },  components: {    LevelOne  }}</script><p>LevelOne.vue 组件：</p><template>  <div>    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->    <h3 :style="{color: themeColor}">Level One</h3>    <hr>    <LevelTwo>  </LevelTwo></div></template><script>import LevelTwo from './LevelTwo'// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default {  setup() {    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据    const themeColor = inject('globalColor')    // 3. 把接收到的共享数据 return 给 Template 使用    return {      themeColor    }  },  components: {    LevelTwo  }}</script><p>LevelTwo.vue 组件：</p><template>  <div>    <!-- 4. 通过属性绑定，为标签设置字体颜色 -->    <h5 :style="{color: themeColor}">Level Two</h5>  </div></template><script>// 1. 按需导入 injectimport { inject } from '@vue/composition-api'export default {  setup() {    // 2. 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据    const themeColor = inject('globalColor')    // 3. 把接收到的共享数据 return 给 Template 使用    return {      themeColor    }  }}</script><h3 id="9-2-共享ref-响应式数据"><a href="#9-2-共享ref-响应式数据" class="headerlink" title="9.2 共享ref 响应式数据"></a>9.2 共享ref 响应式数据</h3><p>如下代码实现了点按钮切换主题颜色的功能，主要修改了 App.vue 组件中的代码，LevelOne.vue 和 LevelTwo.vue 中的代码不受任何改变：</p><template>  <div id="app">    <h1>App 根组件</h1><pre><code>&lt;!-- 点击 App.vue 中的按钮，切换子组件中文字的颜色 --&gt;&lt;button @click=&quot;themeColor=&#39;red&#39;&quot;&gt;红色&lt;/button&gt;&lt;button @click=&quot;themeColor=&#39;blue&#39;&quot;&gt;蓝色&lt;/button&gt;&lt;button @click=&quot;themeColor=&#39;orange&#39;&quot;&gt;橘黄色&lt;/button&gt;&lt;hr /&gt;&lt;LevelOne /&gt;</code></pre>  </div></template><script>import LevelOne from './components/LevelOne'import { provide, ref } from '@vue/composition-api'export default {  name: 'app',  setup() {    // 定义 ref 响应式数据    const themeColor = ref('red')    // 把 ref 数据通过 provide 提供的子组件使用    provide('globalColor', themeColor)    // setup 中 return 数据供当前组件的 Template 使用    return {      themeColor    }  },  components: {    LevelOne  }}</script><h2 id="10-template-refs"><a href="#10-template-refs" class="headerlink" title="10. template refs"></a>10. template refs</h2><p>通过 ref() 还可以引用页面上的元素或组件。</p><h3 id="10-1-元素的引用"><a href="#10-1-元素的引用" class="headerlink" title="10.1 元素的引用"></a>10.1 元素的引用</h3><template>   <div>    <h3 ref="h3Ref">TemplateRefOne</h3>  </div></template><script>import { ref, onMounted } from '@vue/composition-api'export default {  setup() {    // 创建一个 DOM 引用    const h3Ref = ref(null)    // 在 DOM 首次加载完毕之后，才能获取到元素的引用    onMounted(() => {      // 为 dom 元素设置字体颜色      // h3Ref.value 是原生DOM对象      h3Ref.value.style.color = 'red'    })    // 把创建的引用 return 出去    return {      h3Ref    }  }}</script><h3 id="10-2-组件的引用"><a href="#10-2-组件的引用" class="headerlink" title="10.2 组件的引用"></a>10.2 组件的引用</h3><p>TemplateRefOne.vue 中的示例代码如下：</p><template>  <div>    <h3>TemplateRefOne</h3><pre><code>&lt;!-- 4. 点击按钮展示子组件的 count 值 --&gt;&lt;button @click=&quot;showNumber&quot;&gt;获取TemplateRefTwo中的count值&lt;/button&gt;&lt;hr /&gt;&lt;!-- 3. 为组件添加 ref 引用 --&gt;&lt;TemplateRefTwo ref=&quot;comRef&quot; /&gt;</code></pre>  </div></template><script>import { ref } from '@vue/composition-api'import TemplateRefTwo from './TemplateRefTwo'export default {  setup() {    // 1. 创建一个组件的 ref 引用    const comRef = ref(null)    // 5. 展示子组件中 count 的值    const showNumber = () => {      console.log(comRef.value.count)    }    // 2. 把创建的引用 return 出去    return {      comRef,      showNumber    }  },  components: {    TemplateRefTwo  }}</script><p>TemplateRefTwo.vue 中的示例代码：</p><ol><li>import { ref } from ‘@vue/composition-api’</li><li></li><li>export default {</li><li>  setup() {</li><li><pre><code>// 1. 定义响应式的数据</code></pre></li><li><pre><code>const count = ref(0)</code></pre></li><li></li><li><pre><code>// 2. 把响应式数据 return 给 Template 使用</code></pre></li><li><pre><code>return &#123;</code></pre></li><li><pre><code>  count</code></pre></li><li><pre><code>&#125;</code></pre></li><li>  }</li><li>}<br></li></ol><h2 id="11-createComponent"><a href="#11-createComponent" class="headerlink" title="11.createComponent"></a>11.createComponent</h2><p>这个函数不是必须的，除非你想要完美结合 TypeScript 提供的类型推断来进行项目的开发。</p><p>这个函数仅仅提供了类型推断，方便在结合 TypeScript 书写代码时，能为 setup() 中的 props 提供完整的类型推断。</p><ol><li>import { createComponent } from ‘vue’</li><li></li><li>export default createComponent({</li><li>  props: {</li><li><pre><code>foo: String</code></pre></li><li>  },</li><li>  setup(props) {</li><li><pre><code>props.foo // &lt;- type: string</code></pre></li><li>  }</li><li>})</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/051216107.html"/>
      <url>2021/051216107.html</url>
      
        <content type="html"><![CDATA[<h1 id="Welcome-to-我的博客-！"><a href="#Welcome-to-我的博客-！" class="headerlink" title="Welcome to 我的博客 ！"></a>Welcome to 我的博客 ！</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
